{"version":3,"file":"test.js","mappings":"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","sources":["webpack://jucys/./diagram.css?192a","webpack://jucys/webpack/bootstrap","webpack://jucys/./script.js","webpack://jucys/./test.js"],"sourcesContent":["module.exports = {\"g.line *\":{\"transition\":\"fill 0.3s, fill-opacity 0.3s, stroke 0.3s, stroke-opacity 0.3s\"},\"g.line path.bg,\\ng.line path.fg,\\ng.line path.hit\":{\"fill\":\"none\"},\"g.line path.bg\":{\"stroke\":\"#ffffff\",\"strokeOpacity\":0.7,\"strokeWidth\":10,\"strokeLinecap\":\"round\"},\"g.line path.hit\":{\"strokeOpacity\":0,\"strokeWidth\":25,\"strokeLinecap\":\"round\"},\"g.line:hover path.hit\":{\"stroke\":\"#e3bd2e\",\"strokeOpacity\":0.2},\"g.arrow:hover circle.hit\":{\"fill\":\"#e3bd2e\",\"fillOpacity\":0.2},\"g.node:hover circle.hit\":{\"fill\":\"#e3bd2e\",\"fillOpacity\":0.2},\"g.line path.fg\":{\"strokeWidth\":2,\"stroke\":\"#051308\"},\"g.line path.pith\":{\"fill\":\"none\",\"stroke\":\"none\"},\"g.line.summed path.fg\":{\"strokeWidth\":6},\"g.line.summed path.pith\":{\"stroke\":\"white\",\"strokeWidth\":2},\"g.line text.label\":{\"fill\":\"#051308\",\"alignmentBaseline\":\"middle\",\"textAnchor\":\"middle\",\"fontSize\":\"large\"},\"g.line.two-j text.label\":{\"fill\":\"#3274b0\"},\"g.line.two-j path.fg\":{\"stroke\":\"#3274b0\"},\"g.line.two-j .arrowhead\":{\"fill\":\"#3274b0\"},\"g.line.zero path.fg\":{\"stroke\":\"#a89a9f\",\"fontWeight\":\"bold\"},\"g.line.zero text.label\":{\"fill\":\"#a89a9f\",\"fontWeight\":\"bold\"},\"g.line.zero .arrowhead\":{\"fill\":\"#a89a9f\",\"fontWeight\":\"bold\"},\"g.arrow.ambient .arrowhead\":{\"opacity\":0.35},\"g.arrow.bad .hit\":{\"fill\":\"#e74551\"},\"g.arrow.bad .arrowhead\":{\"fill\":\"#e74551\"},\"g.arrow.bad.external .arrowhead\":{\"fill\":\"#dcb406\"},\"g.arrow.bad circle.arrowhead\":{\"opacity\":0.7},\"g.arrow circle.hit\":{\"fillOpacity\":0},\"g.node *\":{\"transition\":\"fill 0.3s, fill-opacity 0.3s\"},\"g.node circle.bg,\\ng.node circle.hit\":{\"fill\":\"#ffffff\",\"fillOpacity\":0},\"g.node circle.fg\":{\"fill\":\"#dddddd\"},\"g.node text.label\":{\"alignmentBaseline\":\"middle\",\"textAnchor\":\"middle\",\"fontSize\":\"large\"},\"g.node.w3j circle.fg\":{\"fill\":\"#21b0ae\"},\"g.node.w3j circle.fg.flipped\":{\"fill\":\"#8d74c5\"},\"g.node.w3j use.arrow\":{\"fill\":\"white\"},\"g.node.w3j use.arrow.flipped\":{\"transform\":\"scale(-1,1)\"},\"g.node.terminal circle.fg\":{\"fill\":\"#000000\",\"fillOpacity\":0.3},\"g.node.terminal:hover circle.fg\":{\"fill\":\"#646464\",\"fillOpacity\":0.3},\"g.node.terminal circle.fg.frozen\":{\"fillOpacity\":0}}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\"\n\nimport \"./style.css\"\nimport \"./diagram.css\"\nimport diagramStylesheet from \"./diagram.css?postcss\"\n\n//////////////////////////////////////////////////////////////////////////////\n// Utility: Generic\n\nfunction identity(x) {\n    return x\n}\n\nfunction defaultEq(x, y) {\n    return x == y\n}\n\nfunction defaultCmp(x, y) {\n    if (x < y) {\n        return -1\n    } else if (y < x) {\n        return 1\n    } else {\n        return 0\n    }\n}\n\nfunction lexicalCmp(xs, ys, cmp) {\n    const nx = xs.length\n    const ny = ys.length\n    const n = nx < ny ? nx : ny\n    for (let i = 0; i < n; ++i) {\n        const r = cmp(xs[i], ys[i])\n        if (r) {\n            return r\n        }\n    }\n    return defaultCmp(nx, ny)\n}\n\nexport function permutSign(xs, ys) {\n    let permut = new Map()\n    for (const [i, y] of ys.entries()) {\n        if (permut.has(y)) {\n            return 0 // not a permutation\n        }\n        permut.set(y, xs[i])\n    }\n    let visited = new Set(xs)\n    let sign = 1\n    while (visited.size) {\n        const x0 = visited.values().next().value\n        visited.delete(x0)\n        let x = x0\n        do {\n            if (!permut.has(x)) {\n                return 0 // not a permutation\n            }\n            x = permut.get(x)\n            visited.delete(x)\n            sign *= -1\n        } while (x != x0)\n        sign *= -1\n    }\n    return sign\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Utility: Basic math\n\nfunction sgn(x) {\n    return x > 0 ? 1 : x < 0 ? -1 : 0\n}\n\n/** Floored modulo */\nfunction mod(x, y) {\n    return (x % y + y) % y\n}\n\nfunction clamp(min, max, x) {\n    if (x < min) {\n        return min\n    } else if (x > max) {\n        return max\n    } else {\n        return x\n    }\n}\n\nfunction round(dx, x) {\n    if (!dx) {\n        return x\n    }\n    return x + dx / 2 - mod(x + dx / 2, dx)\n}\n\nfunction bitXor(x, y) {\n    return x ^ y\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Utility: Iterators\n\nfunction* range(start, stop) {\n    for (let i = start; i < stop; ++i) {\n        yield i\n    }\n}\n\nfunction* map(f, xs, start) {\n    start = start || 0\n    for (const x of xs) {\n        yield f(x, start)\n        start += 1\n    }\n}\n\nfunction* filter(f, xs) {\n    for (const x of xs) {\n        if (f(x)) {\n            yield x\n        }\n    }\n}\n\nfunction* take(n, xs) {\n    let i = 0\n    for (const x of xs) {\n        if (i >= n) {\n            break\n        }\n        yield x\n        i += 1\n    }\n}\n\nfunction sum(xs) {\n    let s = 0\n    for (const x of xs) {\n        s += x\n    }\n    return s\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Utility: Arrays\n\nfunction arrayEqual(xs, ys, cmp) {\n    if (!cmp) {\n        cmp = defaultCmp\n    }\n    const length = xs.length\n    if (length != ys.length) {\n        return false\n    }\n    for (let i = 0; i < length; ++i) {\n        if (xs[i] != ys[i]) {\n            return false\n        }\n    }\n    return true\n}\n\nfunction arrayRemoveMany(xs, indices) {\n    xs = xs.slice()\n    indices = Array.from(indices)\n    // sort in reverse order\n    indices.sort((x, y) => y - x)\n    const n = indices.length\n    for (let i = 0; i < n; ++i) {\n        if (indices[i] >= xs.length) {\n            throw new Error(\"index out of range\")\n        }\n        xs.splice(indices[i], 1)\n    }\n    return xs\n}\n\nfunction arrayIntercalate(sep, xs) {\n    const n = xs.length\n    let ys = []\n    for (let i = 0; i < n; ++i) {\n        if (i != 0) {\n            ys.push(sep)\n        }\n        ys.push(xs[i])\n    }\n    return ys\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Utility: Objects\n\n// Kind of a hack -- hopefully we won't need this in the future.\nlet currentId = 0\nconst idMap = new WeakMap()\nfunction objectId(obj) {\n    if (!idMap.has(obj)) {\n        idMap.set(obj, ++currentId)\n    }\n    return idMap.get(obj)\n}\n\nfunction propOr(obj, prop, def) {\n    return obj.hasOwnProperty(prop)\n         ? obj[prop]\n         : def\n}\n\nfunction cachedGet(map, key, getDefault) {\n    if (!map.has(key)) {\n        const x = getDefault()\n        map.set(key, x)\n        return x\n    }\n    return map.get(key)\n}\n\nfunction deduplicateObject(obj, image) {\n    const ks = Object.keys(obj)\n    if (ks.length != Object.keys(image).length) {\n        return obj\n    }\n    ks.forEach(k => {\n        if (!(image.hasOwnProperty(k) && obj[k] === image[k])) {\n            return obj\n        }\n    })\n    return image\n}\n\nfunction deepClone(x) {\n    return JSON.parse(JSON.stringify(x))\n}\n\nfunction deepFreeze(obj) {\n    if (Object.isFrozen(obj)) {\n        return obj\n    }\n    Object.freeze(obj)\n    const keys = Object.keys(obj)\n    let i = keys.length\n    while (i--) {\n        deepFreeze(obj[keys[i]])\n    }\n    return obj\n}\n\nfunction deepDiff(x, y) {\n    if (x === y) {\n        return null\n    }\n    if (typeof x != typeof y) {\n        return {type: \"typeMismatch\", left: x, right: y}\n    }\n\n    const xIsArray = Array.isArray(x)\n    const yIsArray = Array.isArray(y)\n    if (xIsArray || yIsArray) {\n        if (xIsArray != yIsArray) {\n            return {type: \"typeMismatch\", left: x, right: y}\n        }\n        const nx = x.length\n        const ny = y.length\n        if (nx != ny) {\n            return {type: \"lengthMismatch\", left: nx, right: ny}\n        }\n        for (const [i, xi] of x.entries()) {\n            const diff = deepDiff(xi, y[i])\n            if (diff) {\n                return {type: \"propertyValueMismatch\", prop: i, diff: diff}\n            }\n        }\n        return null\n    }\n\n    if (typeof x == \"object\") {\n        const xProto = Object.getPrototypeOf(x)\n        const yProto = Object.getPrototypeOf(y)\n        if (xProto != yProto) {\n            return {type: \"prototypeMismatch\", left: xProto, right: yProto}\n        }\n        for (const k of Object.keys(x)) {\n            if (!y.hasOwnProperty(k)) {\n                return {type: \"missingProperty\", left: k}\n            }\n            const diff = deepDiff(x[k], y[k])\n            if (diff) {\n                return {type: \"propertyValueMismatch\", prop: k, diff: diff}\n            }\n        }\n        for (const k of Object.keys(y)) {\n            if (!x.hasOwnProperty(k)) {\n                return {type: \"missingProperty\", right: k}\n            }\n        }\n        return null\n    }\n    return {type: \"notEqual\", left: x, right: y}\n}\n\nexport function assertEq(x, y) {\n    const diff = deepDiff(x, y)\n    if (diff != null) {\n        console.warn(x, y, diff)\n    }\n    console.assert(diff == null)\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Geometry\n\nfunction linePointDistance(x1, y1, x2, y2, x0, y0) {\n    const rx = x0 - x1\n    const ry = y0 - y1\n    const lx = x2 - x1\n    const ly = y2 - y1\n    const l = Math.sqrt(lx * lx + ly * ly)\n    const proj = (rx * lx + ry * ly) / l\n    if (proj < l) {\n        // projection is within segment\n        return Math.abs(ly * x0 - lx * y0 + x2 * y1 - y2 * x1) / l\n    } else if (proj < 0) {\n        // projection is to the left of segment\n        return Math.sqrt(rx * rx + ry * ry)\n    } else {\n        // projection is to the right of segment\n        return Math.sqrt(Math.pow(x0 - x2, 2) + Math.pow(y0 - y2, 2))\n    }\n}\n\nfunction arcInfo(lineLength, arcHeight) {\n    if (arcHeight == 0.0) {\n        return {\n            inclination: 0.0,\n            radius: Infinity,\n            large: false,\n            sweep: false,\n        }\n    }\n    const halfLength = lineLength / 2\n    const radius = (halfLength * halfLength / arcHeight + arcHeight) / 2\n    const large = Math.abs(arcHeight) > halfLength\n    const sweep = arcHeight < 0\n    const theta = Math.asin(halfLength / radius)\n    return {\n        inclination: (large ? (sweep ? -1 : 1) * Math.PI - theta : theta),\n        radius: radius,\n        large: large,\n        sweep: sweep,\n    }\n}\n\n/** Get the height of the arc between 1 and 2 that also passes through 0. */\nfunction threePointArc(x0, y0, x1, y1, x2, y2) {\n    const ax = x1 - x2\n    const ay = y1 - y2\n    const bx = x2 - x0\n    const by = y2 - y0\n    const cx = x0 - x1\n    const cy = y0 - y1\n    const det = ay * cx - cy * ax\n    if (det == 0) {\n        return 0.0\n    }\n    const t = (cx * bx + cy * by) / det\n    const radius = 0.5 * Math.sqrt(Math.pow(ax - ay * t, 2)\n                                 + Math.pow(ay + ax * t, 2))\n    const side = -sgn(ay * bx - ax * by)\n    const arcHeight = side * radius - t / 2 * Math.sqrt(ax * ax + ay * ay)\n    return arcHeight\n}\n\n/** Choose smoothness = 1 for a Catmull-Rom spline. */\nfunction cardinalSpline(xs, ys, smoothness) {\n    const length = xs.length\n    if (length != ys.length) {\n        throw new Error(\"xs and ys must have same length\")\n    }\n    let d = \"\"\n    let prevSecantX, prevSecantY\n    for (let i = 0; i < length; ++i) {\n        if (i == 0) {\n            // do nothing\n            d += `M ${xs[i]} ${ys[i]} `\n            continue\n        }\n        if (i == 1 && i == length - 1) {\n            d += `L ${xs[i]} ${ys[i]} `\n            continue\n        }\n        const x01 = xs[i] - xs[i - 1]\n        const y01 = ys[i] - ys[i - 1]\n        const d01 = Math.sqrt(x01 * x01 + y01 * y01)\n        const x12 = xs[i + 1] - xs[i]\n        const y12 = ys[i + 1] - ys[i]\n        const d12 = Math.sqrt(x12 * x12 + y12 * y12)\n        let secantX = smoothness * (xs[i + 1] - xs[i - 1]) / (d01 + d12)\n        let secantY = smoothness * (ys[i + 1] - ys[i - 1]) / (d01 + d12)\n        if (i == 1) {\n            // natural condition (i.e. second derivative must vanish)\n            prevSecantX = (3.0 * x01 / d01 - secantX) / 2.0\n            prevSecantY = (3.0 * y01 / d01 - secantY) / 2.0\n        } else if (i == length - 1) {\n            // natural condition (i.e. second derivative must vanish)\n            secantX = (3.0 * x01 / d01 - prevSecantX) / 2.0\n            secantY = (3.0 * y01 / d01 - prevSecantY) / 2.0\n        }\n        const control1X = xs[i - 1] + prevSecantX * d01 / 3.0\n        const control1Y = ys[i - 1] + prevSecantY * d01 / 3.0\n        const control2X = xs[i] - secantX * d01 / 3.0\n        const control2Y = ys[i] - secantY * d01 / 3.0\n        d += `C ${control1X} ${control1Y} ${control2X} ${control2Y} `\n           + `${xs[i]} ${ys[i]}`\n        prevSecantX = secantX\n        prevSecantY = secantY\n    }\n    return d\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Algebra\n\nfunction vectorAdd(v0, ...vs) {\n    v0 = Array.from(v0)\n    for (const v of vs) {\n        for (const [i, vi] of v.entries()) {\n            v0[i] += vi\n        }\n    }\n    return v0\n}\n\nfunction vectorSubtract(v0, ...vs) {\n    v0 = Array.from(v0)\n    for (const v of vs) {\n        for (const [i, vi] of v.entries()) {\n            v0[i] -= vi\n        }\n    }\n    return v0\n}\n\nfunction vectorDot(v1, v2) {\n    let s = 0\n    for (const i of v1.keys()) {\n        s += v1[i] * v2[i]\n    }\n    return s\n}\n\nfunction vectorSquare(v) {\n    return vectorDot(v, v)\n}\n\nfunction scalarMultiply(c, v) {\n    v = Array.from(v)\n    for (const i of v.keys()) {\n        v[i] *= c\n    }\n    return v\n}\n\n/** Galois field of order 2. */\nconst REAL_FIELD = {\n    ZERO: 0,\n    ONE: 1,\n    add: (x, y) => x + y,\n    subtract: (x, y) => x - y,\n    multiply: (x, y) => x * y,\n    divide: (x, y) => {\n        if (!y) {\n            throw new Error(\"division by zero\")\n        }\n        return x / y\n    },\n    eq: defaultEq,\n}\n\n/** Galois field of order 2. */\nconst GF2_FIELD = Object.assign({}, REAL_FIELD, {\n    add: bitXor,\n    subtract: bitXor,\n})\n\nfunction newSparseVectorType(eq, zero) {\n    eq = eq || defaultEq\n    zero = zero === undefined ? 0 : zero\n    return class SparseVector {\n        constructor(iterable) {\n            this.data = new Map()\n            if (iterable) {\n                for (const [k, v] of iterable) {\n                    this.set(k, v)\n                }\n            }\n        }\n\n        copy() {\n            return new SparseVector(this)\n        }\n\n        [Symbol.iterator]() {\n            return this.data.entries()\n        }\n\n        keys() {\n            return this.data.keys()\n        }\n\n        get(key) {\n            const data = this.data\n            return data.has(key) ? data.get(key) : zero\n        }\n\n        set(key, value) {\n            if (eq(value, zero)) {\n                this.delete(key)\n            } else {\n                this.data.set(key, value)\n            }\n        }\n\n        modify(key, f) {\n            this.set(key, f(this.get(key)))\n        }\n\n        delete(key) {\n            this.data.delete(key)\n        }\n\n        map(f) {\n            return new SparseVector(map(([k, x]) => [k, f(x, k)], this))\n        }\n\n        toTable(keys) {\n            keys = keys || this.keys()\n            let t = {}\n            for (const k of keys) {\n                t[k] = this.get(k)\n            }\n            return t\n        }\n    }\n}\n\nconst RealSparseVector = newSparseVectorType()\n\nfunction newSparseMatrixType(SparseVector) {\n    SparseVector = SparseVector || RealSparseVector\n    return class SparseMatrix {\n        constructor(iterable) {\n            this.data = new Map()\n            if (iterable) {\n                for (const [i, j, x] of iterable) {\n                    this.set(i, j, x)\n                }\n            }\n        }\n\n        copy() {\n            return new SparseMatrix(this)\n        }\n\n        * [Symbol.iterator]() {\n            for (const [i, row] of this.rows()) {\n                yield* map(([j, x]) => [i, j, x], row)\n            }\n        }\n\n        rows() {\n            return map(i => [i, this.row(i)], this.data.keys())\n        }\n\n        row(i) {\n            return cachedGet(this.data, i, () => new SparseVector())\n        }\n\n        rowKeys() {\n            return this.data.keys()\n        }\n\n        colKeys() {\n            let js = new Set()\n            for (const row of this.data.values()) {\n                for (const j of row.keys()) {\n                    js.add(j)\n                }\n            }\n            return js\n        }\n\n        get(i, j) {\n            return this.row(i).get(j)\n        }\n\n        set(i, j, x) {\n            this.row(i).set(j, x)\n        }\n\n        modify(i, j, f) {\n            this.set(i, j, f(this.get(i, j)))\n        }\n\n        deleteRow(i) {\n            this.data.delete(i)\n        }\n\n        map(f) {\n            return new SparseMatrix(map(([i, j, x]) => [i, j, f(x, j, i)], this))\n        }\n\n        toTable(rowKeys, colKeys) {\n            rowKeys = rowKeys || this.rowKeys()\n            colKeys = colKeys || Array.from(this.colKeys())\n            let t = {}\n            for (const i of rowKeys) {\n                t[i] = this.row(i).toTable(colKeys)\n            }\n            return t\n        }\n    }\n}\n\nconst RealSparseMatrix = newSparseMatrixType()\n\nfunction sparseMatrixVectorMultiply(rng, matrix, vector) {\n    let r = new vector.constructor()\n    for (const [i, row] of matrix.rows()) {\n        let s = rng.ZERO\n        for (const [j, x] of row) {\n            s = rng.add(s, rng.multiply(row.get(j), vector.get(j)))\n        }\n        r.set(i, s)\n    }\n    return r\n}\n\n/** Sparse Gaussian elimination over an arbitrary field. */\nfunction sparseGaussElim(field, matrix, vector) {\n    // we are going to seriously mangle these\n    matrix = matrix.copy()\n    vector = vector.copy()\n\n    let is = new Set(matrix.rowKeys())\n    let js = Array.from(matrix.colKeys()).reverse()\n    let unconstrained = []\n    let pivots = []\n\n    // we care about the keys in vector too!\n    for (const i of vector.keys()) {\n        is.add(i)\n    }\n\n    // perform Gaussian elimination to obtain row echelon form;\n    // note that we don't bother changing the pivot column to 1 and 0's\n    // as we won't really need them afterward\n    while (js.length) {\n        const jp = js.pop()\n        let ip = null\n        let xp\n        for (const i of is) {\n            xp = matrix.get(i, jp)\n            if (!field.eq(xp, field.ZERO)) {\n                ip = i\n                break\n            }\n        }\n        if (ip == null) {\n            unconstrained.push(jp)\n            continue\n        }\n        pivots.push([ip, jp])\n        is.delete(ip)\n        const invXp = field.divide(field.ONE, xp)\n        for (const j of js) {\n            matrix.modify(ip, j, x => field.multiply(invXp, x))\n        }\n        vector.modify(ip, x => field.multiply(invXp, x))\n        for (const i of is) {\n            const c = matrix.get(i, jp)\n            if (!field.eq(c, field.ZERO)) {\n                for (const j of js) {\n                    matrix.modify(i, j, x => field.subtract(\n                        x, field.multiply(c, matrix.get(ip, j))))\n                }\n                vector.modify(i, x => field.subtract(\n                    x, field.multiply(c, vector.get(ip))))\n            }\n        }\n    }\n\n    // check for consistency among remaining rows\n    let consistent = true\n    for (const i of is) {\n        if (!field.eq(vector.get(i), field.ZERO)) {\n            consistent = false // no consistent solution\n            break\n        }\n    }\n\n    let solution = new vector.constructor()\n    for (const j of js) {\n        solution.set(j, field.ZERO)\n    }\n    for (const j of unconstrained) {\n        solution.set(j, field.ZERO) // arbitrarily pick zero\n    }\n\n    // back substitution\n    pivots.reverse()\n    for (const [u, [i, k]] of pivots.entries()) {\n        let s = vector.get(i)\n        for (const [v, [_, j]] of pivots.entries()) {\n            if (v >= u) {\n                break\n            }\n            s = field.subtract(s, matrix.get(i, j) * solution.get(j))\n        }\n        solution.set(k, s)\n    }\n\n    return {\n        consistent: consistent,\n        solution: solution,\n        unconstrained: unconstrained,\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// DOM manipulation\n\nconst VNODE_KEY = Symbol(\"VNODE_KEY\")\nconst VNODE_SUSPEND_CHILDREN = Symbol(\"VNODE_SUSPEND_CHILDREN\")\nconst VNODE_SYMBOLS = Symbol(\"VNODE_SYMBOLS\")\nconst VNODE_EVENT_LISTENERS = Symbol(\"VNODE_EVENT_LISTENERS\")\n\nfunction vnodeGetSymbol(elem, key) {\n    return (elem[VNODE_SYMBOLS] || {})[key]\n}\n\nfunction vnodeAmendAttributes(attrs, elem) {\n    let listeners = elem[VNODE_EVENT_LISTENERS]\n    let unusedListeners = Object.assign({}, listeners)\n    const keys = Object.keys(attrs)\n    let i = keys.length\n    while (i--) {\n        const k = keys[i]\n        const v = attrs[k]\n        let m = /^on(.+)/.exec(k)\n        if (m) {\n            const event = m[1]\n            if (!listeners) {\n                listeners = {}\n                elem[VNODE_EVENT_LISTENERS] = listeners\n            }\n            let listener = listeners[event]\n            if (listener) {\n                delete unusedListeners[event]\n            } else {\n                listener = [undefined]\n                listeners[event] = listener\n                elem.addEventListener(event, function(e) {\n                    return listener[0].call(this, e)\n                })\n            }\n            listener[0] = v\n        } else if (v == null) {\n            elem.removeAttribute(k, v)\n        } else {\n            if (elem.getAttribute(k) != v) {\n                elem.setAttribute(k, v)\n            }\n        }\n    }\n    const symKeys = Object.getOwnPropertySymbols(attrs)\n    i = symKeys.length\n    while (i--) {\n        let symbols = elem[VNODE_SYMBOLS]\n        if (!symbols) {\n            symbols = {}\n            elem[VNODE_SYMBOLS] = symbols\n        }\n        const k = symKeys[i]\n        symbols[k] = attrs[k]\n    }\n    const unusedEvents = Object.keys(unusedListeners)\n    let j = unusedEvents.length\n    while (j--) {\n        const event = unusedEvents[j]\n        elem.removeEventListener(event, unusedListeners[event])\n    }\n}\n\nfunction vnodeRenderAttributes(attrs, elem) {\n    if (!attrs) {\n        return\n    }\n    let oldAttrs = elem.attributes\n    if (oldAttrs) {\n        let i = 0\n        while (i < oldAttrs.length) {\n            const oldAttr = oldAttrs[i]\n            const name = oldAttr.name\n            if (!attrs.hasOwnProperty(name) && oldAttr.ns == null) {\n                oldAttrs.removeNamedItem(name)\n            } else {\n                i += 1\n            }\n        }\n    }\n    delete elem[VNODE_SYMBOLS]\n    vnodeAmendAttributes(attrs, elem)\n}\n\nfunction vnodeRenderChildren(children, elem) {\n    if (!children) {\n        return\n    }\n    let oldChildren = elem.childNodes\n    if (!oldChildren) {\n        return\n    }\n    // fragment contains a queue of pending elements; if you're about\n    // to increment j without removing an old node, then you should\n    // flush this queue before moving on!\n    let fragment = document.createDocumentFragment()\n    let j = 0\n    for (let i = 0; i < children.length; ++i) {\n        let child = children[i]\n        let oldChild = oldChildren[j]\n        if (child instanceof Vnode) {\n            const key = child.attributes[VNODE_KEY]\n            if (key) {\n                // find matching node, if any\n                while (oldChild) {\n                    if (oldChild instanceof Element ||\n                        oldChild instanceof Text) {\n                        if ((oldChild[VNODE_SYMBOLS] || {})[VNODE_KEY] == key) {\n                            break\n                        }\n                        elem.removeChild(oldChild)\n                    } else {\n                        elem.insertBefore(fragment, oldChild)\n                        j += 1\n                    }\n                    oldChild = oldChildren[j]\n                }\n            } else if (oldChild && (oldChild[VNODE_SYMBOLS] || {})[VNODE_KEY]) {\n                // not a candidate for replacement; try again later\n                oldChild = null\n            }\n            if (oldChild) {\n                // found a candiate; can we update without replacing?\n                // (note: XML is case-sensitive; HTML is not)\n                if (oldChild instanceof HTMLElement\n                    ? (oldChild.nodeName.toLowerCase()\n                        == child.name.toLowerCase())\n                    : (oldChild.namespaceURI == child.namespace &&\n                       oldChild.nodeName == child.name)) {\n                    elem.insertBefore(fragment, oldChild)\n                    j += 1\n                    child.renderTo(oldChild)\n                    continue\n                } else {\n                    elem.removeChild(oldChild)\n                }\n            }\n            child = child.create()\n        } else if (typeof child == \"string\") {\n            if (oldChild instanceof Text) {\n                elem.insertBefore(fragment, oldChild)\n                j += 1\n                if (oldChild.nodeValue != child) {\n                    oldChild.nodeValue = child\n                }\n                continue\n            } else {\n                child = document.createTextNode(child)\n            }\n        }\n        fragment.appendChild(child)\n    }\n    // remove remaining nodes\n    while (j < oldChildren.length) {\n        let oldChild = oldChildren[j]\n        if (oldChild instanceof Element ||\n            oldChild instanceof Text) {\n            // this function is not re-entrant, so this could throw an exception\n            // if a blur event removes the child before we get a chance to;\n            // we work around this by serializing execution of applyRendering\n            elem.removeChild(oldChild)\n        } else {\n            j += 1\n        }\n    }\n    elem.appendChild(fragment)\n}\n\nclass Vnode {\n    constructor(namespace, name, attributes, children) {\n        this.namespace = namespace\n        this.name = name\n        this.attributes = attributes\n        this.children = children\n    }\n\n    // Copy the attributes and children to the given element.\n    // Note: the behavior is unspecified if the element is of a different name.\n    renderTo(elem) {\n        vnodeRenderAttributes(this.attributes, elem)\n        if (!this.attributes[VNODE_SUSPEND_CHILDREN]) {\n            vnodeRenderChildren(this.children, elem)\n        }\n    }\n\n    create() {\n        const namespace = this.namespace\n        let elem = namespace\n                 ? document.createElementNS(namespace, this.name)\n                 : document.createElement(this.name)\n        this.renderTo(elem)\n        return elem\n    }\n}\n\nconst NAMESPACES = {\n    svg: \"http://www.w3.org/2000/svg\",\n    xlink: \"http://www.w3.org/1999/xlink\",\n}\n\nfunction parseNamespace(name) {\n    let namespace = null\n    const m = /([^:]+):(.+)/.exec(name)\n    if (m && NAMESPACES.hasOwnProperty(m[1])) {\n        namespace = NAMESPACES[m[1]]\n        name = m[2]\n    }\n    return [namespace, name]\n}\n\nfunction vnode(name, attributes, ...children) {\n    let namespace\n    ;[namespace, name] = parseNamespace(name)\n    return new Vnode(namespace, name, attributes, children)\n}\n\nlet renderQueue = []\nfunction applyRendering(rendering) {\n    // work around the lack of re-entrancy\n    renderQueue.push(rendering)\n    if (renderQueue.length != 1) {      // we are not alone\n        return\n    }\n    while (renderQueue.length) {\n        const rendering = renderQueue[0]\n        rendering.forEach(spec => {\n            const elem = spec.element\n            if (!elem) {\n                throw new Error(\"invalid elem\")\n            }\n            if (spec.attributes) {\n                vnodeAmendAttributes(spec.attributes, elem)\n            }\n            vnodeRenderChildren(spec.children, elem)\n        })\n        renderQueue.shift()\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Deltas\n//\n// Without qualification, \"deltas\" refer to Kronecker deltas involving\n// magnitudes (j), not projections (m).\n//\n// Each delta is an array of at least two magnitude variables.\n// Within a given list of deltas, the variables must be all distinct.\n\n/** Merges the given deltas and simplifies the result. */\nexport function mergeDeltas(...deltaLists) {\n    let finalDeltas = []\n    let finder = {} // {[entry]: [deltas]} (singleton list)\n    deltaLists.forEach(deltas => deltas.forEach(delta => {\n        if (delta.length < 2) {\n            return\n        }\n        let found = null\n        for (let i = 0; i < delta.length; ++i) {\n            found = finder[delta[i]]\n            if (found) {\n                break\n            }\n        }\n        if (found == null) {\n            found = [[]]\n            finalDeltas.push(found[0])\n        }\n        delta.forEach(x => {\n            const exists = finder[x]\n            if (!exists) {\n                found[0].push(x)\n                finder[x] = found\n            } else if (exists[0] != found[0]) {\n                // merge deltas\n                found[0].push(...exists[0])\n                exists[0].splice(0, exists[0].length)\n                exists[0] = found[0]\n            }\n        })\n    }))\n    // remove the husks\n    return Object.freeze(finalDeltas.map(Object.freeze)\n                                    .filter(delta => delta.length > 1))\n}\n\n/** Tests whether the 'subdeltas' is a subset of (implied by) 'deltas'. */\nexport function containsDeltas(deltas, subdeltas) {\n    deltas = mergeDeltas(deltas)\n    subdeltas = mergeDeltas(subdeltas)\n    let finder = {}\n    deltas.forEach(delta => delta.forEach(x =>\n        finder[x] = delta\n    ))\n    for (let j = 0; j < subdeltas.length; ++j) {\n        const subdelta = subdeltas[j]\n        let found = null\n        for (let i = 0; i < subdelta.length; ++i) {\n            found = finder[subdelta[i]]\n            if (found) {\n                break\n            }\n        }\n        if (found) {\n            for (let i = 0; i < subdelta.length; ++i) {\n                if (finder[subdelta[i]] != found) {\n                    return false\n                }\n            }\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunction equalDeltas(deltas1, deltas2) {\n    return containsDeltas(deltas1, deltas2) && containsDeltas(deltas2, deltas1)\n}\n\nfunction findDeltaEntry(deltas, entry) {\n    for (let j = 0; j < deltas.length; ++j) {\n        for (let i = 0; i < deltas[j].length; ++i) {\n            if (deltas[j][i] == entry) {\n                return [j, i]\n            }\n        }\n    }\n    return null\n}\n\nexport function relatedDelta(deltas, entry) {\n    const ji = findDeltaEntry(deltas, entry)\n    if (!ji) {\n        return [entry]\n    }\n    const [j, i] = ji\n    return [entry].concat(arrayRemoveMany(deltas[j], [i]))\n}\n\n/** Warning: this may not preserve the diagram! */\nexport function removeDeltaEntry(deltas, entry) {\n    const ji = findDeltaEntry(deltas, entry)\n    if (!ji) {\n        return deltas\n    }\n    const [j, i] = ji\n    return Object.freeze(Object.assign([], deltas, {\n        [j]: Object.freeze(arrayRemoveMany(deltas[j], [i])),\n    })).filter(delta => delta.length > 1)\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Superlines\n//\n// Superlines are just magnitudes (j).\n\nexport const EMPTY_SUPERLINE = Object.freeze({\n    phase: 0,\n    summed: false,\n    weight: 0,\n})\n\n/** Convert a superline-like object into a proper superline. */\nfunction ensureSuperline(superline) {\n    return Object.freeze(Object.assign({}, EMPTY_SUPERLINE, superline))\n}\n\n/** Increment the numeric suffix of a string by one.  If there is no suffix,\n   `1` is appended. */\nfunction newLabel(label) {\n    const match = /^([\\s\\S]*?)(\\d*)$/.exec(label)\n    return match[1] + (Number(match[2]) + 1).toString()\n}\n\n/** Generate `count` fresh labels. */\nfunction availLabels(obj) {\n    // avoid \"0\", which is reserved for the actual zero\n    return filter(i => !obj.hasOwnProperty(i),\n                  map(i => i.toString(),\n                      range(1, Number.POSITIVE_INFINITY)))\n}\n\n/** Generate `count` fresh superline labels. */\nfunction availSuperlineLabels(diagram) {\n    let labels = Object.assign({}, diagram.superlines)\n    for (const delta of diagram.deltas) {\n        for (const x of delta) {\n            labels[x] = true\n        }\n    }\n    return availLabels(labels)\n}\n\nfunction isEmptySuperline(superline) {\n    return !superline.phase && !superline.summed && !superline.weight\n}\n\n/** Avoid using this function because it doesn't handle zero lines. */\nfunction mergeSuperlines(...superlines) {\n    let finalSuperline = Object.assign({}, EMPTY_SUPERLINE)\n    superlines.forEach(superline => {\n        finalSuperline.phase = mod(finalSuperline.phase\n                                 + (superline.phase || 0), 4)\n        finalSuperline.weight += superline.weight || 0\n        if (superline.summed != null) {\n            finalSuperline.summed = superline.summed\n        }\n    })\n    return Object.freeze(finalSuperline)\n}\n\nfunction mergeSuperlineLists(...superlineLists) {\n    let finalSuperlines = {}\n    for (const superlines of superlineLists) {\n        for (const id of Object.keys(superlines)) {\n            if (id == \"0\") {\n                finalSuperlines[id] = EMPTY_SUPERLINE\n                continue\n            }\n            const finalSuperline = finalSuperlines[id]\n            let superline = superlines[id]\n            if (finalSuperline) {\n                superline = mergeSuperlines(finalSuperline, superline)\n            }\n            finalSuperlines[id] = superline\n        }\n    }\n    for (const id of Object.keys(finalSuperlines)) {\n        if (id.phase == 0 && id.weight == 0 && !id.summed) {\n            delete finalSuperlines[id]\n        }\n    }\n    return Object.freeze(finalSuperlines)\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Line manipulation\n\n// type Line = {\n//   superline: String,\n//   direction: -1 (left) | 0 | 1 (right),\n//   arrowPos: 0.0 (left) to 1.0 (right),\n//   arcHeight: -INF to INF, (sagitta, + is downward)\n//   angle: 0 to 2PI, (of the direct line, clockwise)\n//   textPos: 0.0 (left) to 1.0 (right),\n//   textOffset: -INF to INF, (+ is downward)\n// }\n//\n// The angle is usually ignored, but if the ratio of arcHeight to lineLength\n// is too big, then 'angle' is used to break the degeneracy.\n//\n// In general, \"pos\" refers to a relative position on a line, with 0.0 being\n// the leftmost point and 1.0 the rightmost.\n\nconst ZERO_LINE = Object.freeze({\n    superline: \"0\",\n    direction: 0,\n    arrowPos: 0.5,\n    arcHeight: 0.0,\n    angle: 0.0,\n    textPos: 0.5,\n    textOffset: 0.0,\n})\n\nexport function newLine(superlineId) {\n    return ensureLine({superline: superlineId})\n}\n\nfunction ensureLine(line) {\n    return Object.freeze(Object.assign({}, ZERO_LINE, line))\n}\n\nfunction reverseLineDirection(line) {\n    return Object.freeze(Object.assign({}, line, {direction: -line.direction}))\n}\n\nfunction reverseLine(line) {\n    line = Object.assign({}, line)\n    if (line.direction != null) {\n        line.direction = -line.direction\n    }\n    if (line.arrowPos != null) {\n        line.arrowPos = 1.0 - line.arrowPos\n    }\n    if (line.arcHeight != null) {\n        line.arcHeight = -line.arcHeight\n    }\n    if (line.angle != null) {\n        line.angle = mod(line.angle + Math.PI, 2 * Math.PI)\n    }\n    if (line.textPos != null) {\n        line.textPos = 1.0 - line.textPos\n    }\n    if (line.textOffset != null) {\n        line.textOffset = -line.textOffset\n    }\n    return Object.freeze(line)\n}\n\nfunction isLineDirectable(line) {\n    return line.superline == \"0\" || mod(line.direction, 2) == 1\n}\n\nfunction mergeDirections(...directions) {\n    return mod(sum(directions) + 1, 4) - 1\n}\n\n/** Beware: this may result in a noncanonical line!\n *\n * Because of averaging, addition isn't quite associative with respect to the\n * superficial attributes.\n *\n * All lines must agree in superline.\n */\nfunction rawConcatLines(...lines) {\n    const n = lines.length\n    const avgProps = [\"arrowPos\", \"arcHeight\",\n                      \"textPos\", \"textOffset\"]\n    let finalLine = {}\n    let sinAngle = 0.0\n    let cosAngle = 0.0\n    let numAngles = 0\n    let counts = {}\n    for (const prop of avgProps) {\n        counts[prop] = 0\n    }\n    for (const [i, line] of lines.entries()) {\n        if (i == 0) {\n            finalLine.superline = line.superline\n        } else if (finalLine.superline != line.superline) {\n            throw new Error(\"cannot add lines with different superlines\")\n        }\n        if (line.direction != null) {\n            if (finalLine.direction == null) {\n                finalLine.direction = 0\n            }\n            finalLine.direction =\n                mergeDirections(finalLine.direction, line.direction)\n        }\n        for (const prop of avgProps) {\n            if (line[prop] != null) {\n                if (finalLine[prop] == null) {\n                    finalLine[prop] = 0\n                }\n                finalLine[prop] += line[prop]\n                counts[prop] += 1\n            }\n        }\n        if (line.angle != null) {\n            sinAngle += Math.sin(line.angle)\n            cosAngle += Math.cos(line.angle)\n            numAngles += 1\n        }\n    }\n    for (const prop of avgProps) {\n        if (counts[prop]) {\n            finalLine[prop] /= counts[prop]\n        }\n    }\n    if (numAngles) {\n        finalLine.angle = Math.atan2(sinAngle, cosAngle)\n    }\n    return Object.freeze(finalLine)\n}\n\n/** Like `rawConcatLines`, but does canonicalization and converts conflicting\n * superlines into a delta. */\nfunction concatLines(...lines) {\n    const canonicalized = canonicalizeLine(rawConcatLines(\n        ...lines.map(line => Object.assign({}, line, {\n            superline: lines[0].superline,\n        }))))\n    return {\n        line: canonicalized.line,\n        phase: canonicalized.phase,\n        delta: lines.map(line => line.superline), // duplicates are fine\n    }\n}\n\nfunction canonicalizeLine(line) {\n    let direction = line.direction % 2\n    let phase = mod(Math.trunc(line.direction / 2), 2) * 2\n    if (line.superline == \"0\") {\n        direction = 0\n        phase = 0\n    }\n    return {\n        line: Object.freeze(Object.assign({}, line, {direction: direction})),\n        phase: phase,\n    }\n}\n\nfunction joinLines(line1, reverse1, line2, reverse2) {\n    line1 = (reverse1 ? reverseLine : identity)(line1)\n    line2 = (reverse2 ? reverseLine : identity)(line2)\n    const superlines = [line1.superline, line2.superline].sort(defaultCmp)\n    line1 = Object.assign({}, line1, {superline: superlines[0]})\n    line2 = Object.assign({}, line1, {superline: superlines[0]})\n    return Object.assign(canonicalizeLine(rawConcatLines(line1, line2)), {\n        otherSuperline: superlines[1]\n    })\n}\n\nfunction getLineInfoBetween(x0, y0, x1, y1, line) {\n    const xMid = (x0 + x1) / 2\n    const yMid = (y0 + y1) / 2\n    let dx = x1 - x0\n    let dy = y1 - y0\n    let lineLength = Math.sqrt(dx * dx + dy * dy)\n    const singular = lineLength == 0.0\n    const trueAngle = Math.atan2(dy, dx)\n    let angle = trueAngle\n    let arcHeight = line.arcHeight\n    // an semiarbitrary sign used to pick a consistent side on lines even\n    // when the line is reversed\n    const halfDisk = mod(line.angle + Math.PI / 2, 2 * Math.PI) < Math.PI\n                   ? -1 : 1\n    if (singular) {\n        // fudge numbers to avoid singularity\n        // (epsilon can't be too small or the SVG rendering becomes jittery)\n        const epsilon = 1e-2\n        dx = epsilon * Math.cos(line.angle)\n        dy = epsilon * Math.sin(line.angle)\n        x0 = xMid - 0.5 * dx\n        y0 = yMid - 0.5 * dy\n        x1 = xMid + 0.5 * dx\n        y1 = yMid + 0.5 * dy\n        lineLength = epsilon\n        angle = line.angle\n        arcHeight = arcHeight == 0.0\n                  ? 50.0 * halfDisk\n                  : sgn(arcHeight) * clamp(50.0, Infinity, Math.abs(arcHeight))\n    }\n    const arc = arcInfo(lineLength, arcHeight)\n    const c = (arc.radius - arcHeight) / lineLength\n    const xCenter = xMid + c * dy\n    const yCenter = yMid - c * dx\n    const arcEx = {\n        xCenter: xCenter,\n        yCenter: yCenter,\n        startAngle: Math.atan2(y0 - yCenter, x0 - xCenter),\n    }\n    return {\n        x0: x0,\n        y0: y0,\n        x1: x1,\n        y1: y1,\n        xMid: xMid,\n        yMid: yMid,\n        dx: dx,\n        dy: dy,\n        angle: angle,\n        trueAngle: trueAngle,\n        lineLength: lineLength,\n        singular: singular,\n        line: line,\n        halfDisk: halfDisk,\n        arcHeight: arcHeight,\n        arc: Object.assign(arc, arcEx),\n    }\n}\n\n/** Calculate geometric information about a line. */\nfunction getLineInfo(diagram, lineId) {\n    const line = diagram.lines[lineId]\n    const ends = endNodeIndices(diagram.nodes, lineId)\n    const node0 = diagram.nodes[ends[0]]\n    const node1 = diagram.nodes[ends[1]]\n    return Object.assign({\n        external: [node0.type, node1.type].includes(\"terminal\"),\n    }, getLineInfoBetween(node0.x, node0.y, node1.x, node1.y, line))\n}\n\n/** Find the closest \"pos\" on a line. */\nfunction findPosOnLine(lineInfo, x, y) {\n    let pos, offset\n    if (lineInfo.arcHeight == 0.0) {\n        const rx = x - lineInfo.x0\n        const ry = y - lineInfo.y0\n        pos = (lineInfo.dx * rx + lineInfo.dy * ry)\n        / Math.pow(lineInfo.lineLength, 2)\n        // left-handed coordinate system!\n        offset = -(rx * lineInfo.dy - ry * lineInfo.dx) / lineInfo.lineLength\n    } else {\n        const arc = lineInfo.arc\n        const rx = x - arc.xCenter\n        const ry = y - arc.yCenter\n        const cycle = Math.abs(Math.PI / arc.inclination)\n        const rawAngle = arc.startAngle - Math.atan2(ry, rx)\n        const shift = 0.5 * cycle - 0.5 // remove the bias toward pos = 1.0\n        pos = mod(rawAngle / (2 * arc.inclination) + shift, cycle) - shift\n        offset = (Math.sqrt(rx * rx + ry * ry) - Math.abs(arc.radius))\n        * sgn(lineInfo.arcHeight)\n    }\n    return {\n        pos: pos,\n        offset: offset,\n    }\n}\n\n/** Translate from a relative \"pos\" to absolute (x, y) coordinates.  `shift`\n * specifies an extra shift in absolute coordinates along the line. */\nfunction positionOnLine(lineInfo, pos, shift) {\n    const arc = lineInfo.arc\n    if (lineInfo.arcHeight == 0.0) {\n        const lineLength = lineInfo.lineLength\n        const newPos = pos + shift / lineLength\n        return {\n            x: lineInfo.x0 + lineInfo.dx * newPos,\n            y: lineInfo.y0 + lineInfo.dy * newPos,\n            normalX: -lineInfo.dy / lineLength,\n            normalY: lineInfo.dx / lineLength,\n            tangentAngle: lineInfo.angle,\n        }\n    } else {\n        const localAngle = 2 * arc.inclination * pos + shift / arc.radius\n        const tangentAngle = lineInfo.angle + arc.inclination - localAngle\n        const normalAngle = tangentAngle + Math.PI / 2\n        const normalX = Math.cos(normalAngle)\n        const normalY = Math.sin(normalAngle)\n        return {\n            x: arc.xCenter + arc.radius * normalX,\n            y: arc.yCenter + arc.radius * normalY,\n            normalX: normalX,\n            normalY: normalY,\n            tangentAngle: tangentAngle,\n        }\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Node manipulation\n\n/** Create a terminal node. */\nexport function terminalNode(lineId, variable, x, y) {\n    // every terminal has an associated name for the \"m\" variable;\n    // because this variable is *free*, rules must never change this variable!\n    // (you are free to rename the lineId whatever you want, but try to reuse\n    // the user's naming if possible)\n    //\n    // when rendering lines connected to terminal(s), be aware that the name(s)\n    // on the terminal(s) *supersede* the name of the line itself (lineId); if\n    // there are two terminals, then an m-delta is implied (this is how we\n    // represent m-deltas)\n    let node = {\n        type: \"terminal\",\n        lines: Object.freeze([lineId]),\n        variable: variable,\n    }\n    if (x != null) {\n        node.x = x\n    }\n    if (y != null) {\n        node.y = y\n    }\n    return Object.freeze(node)\n}\n\n/** Create a Wigner 3-jm node. */\nexport function w3jNode(a, b, c, x, y) {\n    let node = {\n        type: \"w3j\",\n        lines: Object.freeze([a, b, c]),\n    }\n    if (x !== undefined) {\n        node.x = x\n    }\n    if (y !== undefined) {\n        node.y = y\n    }\n    return Object.freeze(node)\n}\n\nfunction endNodeAndLineIndices(nodes, lineId) {\n    let nodeAndLineIndices = []\n    if (lineId == null) {\n        throw new Error(\"lineId must not be null / undefined\")\n    }\n    const numNodes = nodes.length\n    for (let nodeIndex = 0; nodeIndex < numNodes; ++nodeIndex) {\n        const lines = nodes[nodeIndex].lines\n        const numLines = lines.length\n        for (let lineIndex = 0; lineIndex < numLines; ++lineIndex) {\n            const nodeLineId = lines[lineIndex]\n            if (nodeLineId == lineId) {\n                nodeAndLineIndices.push([nodeIndex, lineIndex])\n            }\n        }\n    }\n    if (nodeAndLineIndices.length != 2) {\n        throw new Error(\"line must be connected at 2 points, \"\n                      + `not ${nodeAndLineIndices.length}`)\n    }\n    return nodeAndLineIndices\n}\n\nfunction endNodeIndices(nodes, lineId) {\n    return endNodeAndLineIndices(nodes, lineId).map(x => x[0])\n}\n\nfunction otherNodeAndLineIndex(nodes, nodeIndex, lineIndex) {\n    const lineId = nodes[nodeIndex].lines[lineIndex]\n    if (lineId === undefined) {\n        throw new Error(`cannot find line with lineIndex = ${lineIndex}`)\n    }\n    let nodeAndLineIndices = endNodeAndLineIndices(nodes, lineId)\n    if (lexicalCmp(nodeAndLineIndices[0],\n                   [nodeIndex, lineIndex],\n                   defaultCmp) == 0) {\n        return nodeAndLineIndices[1]\n    } else {\n        return nodeAndLineIndices[0]\n    }\n}\n\nfunction otherNodeIndex(nodes, nodeIndex, lineIndex) {\n    return otherNodeAndLineIndex(nodes, nodeIndex, lineIndex)[0]\n}\n\nfunction isLeftOfLine(nodes, nodeIndex, lineIndex) {\n    return lexicalCmp(otherNodeAndLineIndex(nodes, nodeIndex, lineIndex),\n                      [nodeIndex, lineIndex], defaultCmp) > 0\n}\n\nfunction nearestNodeIndices(nodes, count, x, y) {\n    return nodes\n        .map((node, nodeIndex) => ({\n            distance: Math.pow(x - node.x, 2) + Math.pow(y - node.y, 2),\n            index: nodeIndex\n        }))\n        .sort((x, y) => x.distance - y.distance)\n        .slice(0, count)\n        .map(node => node.index)\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Diagram manipulation\n//\n// NOTE: must maintain invariant that terminals precede all other nodes.\n// Also, the order of nodes is critical!  If you move the nodes around,\n// make sure the lines are also reversed.\n\nexport const EMPTY_DIAGRAM = Object.freeze({\n    nodes: Object.freeze([]),\n    superlines: Object.freeze({}),\n    lines: Object.freeze({}),\n\n    // each entry is an array of j's that are equal to each other\n    deltas: Object.freeze([]),\n})\n\nexport function ensureDiagram(diagram) {\n    return Object.freeze(Object.assign({}, EMPTY_DIAGRAM, diagram))\n}\n\nfunction w3jDiagram(a, b, c, x, y) {\n    if (a == b || b == c || c == a) {\n        throw new Error(\"cannot create w3jDiagram with conflicting labels\")\n    }\n    return ensureDiagram({\n        nodes: Object.freeze([\n            terminalNode(a, a, x - 50, y + 50),\n            terminalNode(b, b, x + 50, y + 50),\n            terminalNode(c, c, x, y - 70),\n            w3jNode(a, b, c, x, y),\n        ]),\n        lines: Object.freeze({\n            [a]: newLine(a),\n            [b]: newLine(b),\n            [c]: newLine(c),\n        }),\n        superlines: Object.freeze({\n            [a]: EMPTY_SUPERLINE,\n            [b]: EMPTY_SUPERLINE,\n            [c]: EMPTY_SUPERLINE,\n        }),\n    })\n}\n\nfunction cgDiagram(a, b, c, x, y) {\n    const diagram = w3jDiagram(a, b, c, x, y)\n    return Object.freeze(Object.assign({}, diagram, {\n        nodes: Object.freeze(Object.assign([], diagram.nodes, {\n            [3]: Object.freeze(Object.assign({}, diagram.nodes[3], {\n                lines: Object.freeze([a, c, b]),\n            })),\n        })),\n        lines: Object.freeze(Object.assign({}, diagram.lines, {\n            [c]: Object.freeze(Object.assign({}, diagram.lines[c], {\n                direction: 1,\n            })),\n        })),\n        superlines: Object.freeze(Object.assign({}, diagram.superlines, {\n            [b]: Object.freeze(Object.assign({}, diagram.superlines[b], {\n                phase: 2,\n            })),\n            [c]: Object.freeze(Object.assign({}, diagram.superlines[c], {\n                weight: 1,\n            })),\n        })),\n    }))\n}\n\nfunction setDiagramLineProps(diagram, lineId, props) {\n    const lines = diagram.lines\n    return Object.freeze(Object.assign({}, diagram, {\n        lines: Object.freeze(Object.assign({}, lines, {\n            [lineId]: Object.freeze(Object.assign({}, lines[lineId], props)),\n        })),\n    }))\n}\n\nfunction setDiagramNodeProps(diagram, nodeIndex, props) {\n    const nodes = diagram.nodes\n    return Object.freeze(Object.assign({}, diagram, {\n        nodes: Object.freeze(Object.assign([], nodes, {\n            [nodeIndex]: Object.freeze(Object.assign({}, nodes[nodeIndex],\n                                                     props)),\n        }))\n    }))\n}\n\nfunction lineAngle(diagram, nodeIndex, lineIndex) {\n    const node = diagram.nodes[nodeIndex]\n    const lineId = node.lines[lineIndex]\n    const line = diagram.lines[lineId]\n    const lineInfo = getLineInfo(diagram, lineId)\n    const reverse = Number(isLeftOfLine(diagram.nodes, nodeIndex, lineIndex))\n    const baseAngle = (lineInfo.singular ? line.angle : lineInfo.angle)\n                    + reverse * Math.PI\n    const sign = reverse ? 1 : -1\n    return baseAngle + sign * lineInfo.arc.inclination\n}\n\nfunction w3jOrientation(diagram, nodeIndex) {\n    const node = diagram.nodes[nodeIndex]\n    if (node.type != \"w3j\") {\n        throw new Error(\"cannot get orientation of generic node\")\n    }\n    const lines = node\n        .lines\n        .map((_, lineIndex) => {\n            const angle = lineAngle(diagram, nodeIndex, lineIndex)\n            return [lineIndex, mod(angle, 2 * Math.PI)]\n        })\n        .sort((line1, line2) => line1[1] - line2[1])\n        .map(([x, _]) => x)\n    return permutSign([0, 1, 2], lines)\n}\n\nfunction mergeDiagrams(diagram1, diagram2) {\n    let diagram = deepClone(diagram1)\n    diagram.superlines = mergeSuperlineLists(diagram1.superlines,\n                                             diagram2.superlines)\n    let renames = {}\n    Object.keys(diagram2.lines).forEach(function(lineId) {\n        let newLineId = lineId\n        while (diagram.lines.hasOwnProperty(newLineId)) {\n            // name collision\n            newLineId = newLabel(newLineId)\n        }\n        renames[lineId] = newLineId\n        diagram.lines[newLineId] = diagram2.lines[lineId]\n    })\n    let terminals = []\n    diagram2.nodes.forEach(function(node) {\n        node = Object.assign({}, node, {\n            lines: node.lines.map(lineId => renames[lineId]),\n        })\n        if (node.type == \"terminal\") {\n            terminals.push(node)\n        } else {\n            diagram.nodes.push(node)\n        }\n    })\n    diagram.nodes = terminals.concat(diagram.nodes)\n    return diagram\n}\n\nfunction isSuperlineExposed(diagram, superlineId) {\n    for (const node of diagram.nodes) {\n        if (node.type == \"terminal\" &&\n            diagram.lines[node.lines[0]].superline == superlineId) {\n            return true\n        }\n    }\n    return false\n}\n\nfunction joinTerminals(diagram, terminalIndex1, terminalIndex2) {\n    diagram = new Diagram(diagram)\n    const terminal1 = diagram.node(terminalIndex1)\n    const terminal2 = diagram.node(terminalIndex2)\n    if (terminal1.type != \"terminal\" || terminal2.type != \"terminal\") {\n        throw \"cannot join non-terminals\"\n    }\n    const line1 = terminal1.line(0)\n    const line2 = terminal2.line(0)\n    let newDiagram = deepClone(diagram.rawDiagram)\n    if (line1.id == line2.id) {\n        if (line1.direction != 0) {\n            return \"cannot form a directed loop\"\n        }\n        newDiagram.superlines[line1.superlineId].weight += 2\n    } else {\n        // TODO can we abstract out this pattern? we do this a lot\n        const combined = concatLines(line1.reverse().line, line2.line)\n        const f = lexicalCmp([line1.node(1).index, line1.lineIndex(1)],\n                             [line2.node(1).index, line2.lineIndex(1)],\n                             defaultCmp) > 0\n                ? reverseLine : identity\n        newDiagram.lines[line1.id] = f(combined.line)\n        line2.rawAssign(newDiagram, 1, line1.id)\n        if (line1.superlineId != line2.superlineId) {\n            newDiagram.superlines[line1.superlineId] = mergeSuperlines(\n                line2.superline,\n                line1.superline,\n                {phase: combined.phase})\n            newDiagram.superlines[line2.superlineId] = EMPTY_SUPERLINE\n        }\n        newDiagram.deltas = mergeDeltas(newDiagram.deltas, [combined.delta])\n    }\n    delete newDiagram.lines[line2.id]\n    newDiagram.nodes = arrayRemoveMany(newDiagram.nodes,\n                                       [terminal1.index, terminal2.index])\n    return new Diagram(newDiagram).removeUnusedSuperlines().rawDiagram\n}\n\nfunction addW1j(diagram, lineId) {\n    diagram = deepClone(diagram)\n    let line = diagram.lines[lineId]\n    // cycle through all possible directions\n    if (line.direction > 0) {\n        line.direction = -1\n    } else if (line.direction < 0) {\n        line.direction = 0\n    } else {\n        line.direction = 1\n    }\n    return diagram\n}\n\nfunction add2j(diagram, lineId) {\n    diagram = new Diagram(diagram)\n    return diagram.substitute({}, {\n        [diagram.line(lineId).superlineId]: {phase: 2}\n    }).rawDiagram\n}\n\nfunction flipW3j(diagram, nodeIndex) {\n    if (diagram.nodes[nodeIndex].type != \"w3j\") {\n        return diagram\n    }\n    diagram = deepClone(diagram)\n    let lines = diagram.nodes[nodeIndex].lines\n    lines.reverse()\n    for (let i = 0; i < 3; ++i) {\n        if (lines[i] == lines[(i + 1) % 3]) {\n            diagram.lines[lines[i]] = reverseLine(diagram.lines[lines[i]])\n            break\n        }\n    }\n    return diagram\n}\n\nfunction isDanglingSuperline(diagram, superlineId) {\n    const lineIds = Object.keys(diagram.lines)\n    let i = lineIds.length\n    while (i--) {\n        if (diagram.lines[lineIds[i]].superline == superlineId) {\n            return false\n        }\n    }\n    return true\n}\n\nfunction deleteNode(diagram, nodeIndex) {\n    diagram = deepClone(diagram)\n    const node = diagram.nodes[nodeIndex]\n    if (node.type == \"terminal\") {\n        const otherIndex = otherNodeIndex(diagram.nodes, nodeIndex, 0)\n        if (diagram.nodes[otherIndex].type != \"terminal\") {\n            throw new Error(\"cannot delete terminal of node\")\n        }\n        const superlineId = diagram.lines[node.lines[0]].superline\n        delete diagram.lines[node.lines[0]]\n        if (isDanglingSuperline(diagram, superlineId)) {\n            delete diagram.superlines[superlineId]\n        }\n        diagram.nodes = arrayRemoveMany(diagram.nodes, [nodeIndex, otherIndex])\n    } else {\n        let terminals = []\n        node.lines.forEach(function(lineId, lineIndex) {\n            const otherIndex = otherNodeIndex(diagram.nodes, nodeIndex, lineIndex)\n            if (otherIndex == nodeIndex) {\n                const line = diagram.lines[lineId]\n                if (!line) {\n                    return\n                }\n                delete diagram.lines[lineId]\n                const superlineId = line.superline\n                if (isDanglingSuperline(diagram, superlineId)) {\n                    delete diagram.superlines[superlineId]\n                }\n                return\n            }\n            if (otherIndex < nodeIndex) {\n                diagram.lines[lineId] = reverseLine(diagram.lines[lineId])\n            }\n            terminals.push(terminalNode(lineId, lineId, node.x, node.y))\n        })\n        diagram.nodes.splice(nodeIndex, 1)\n        diagram.nodes = terminals.concat(diagram.nodes)\n    }\n    return diagram\n}\n\n/** Examine the diagram to see if there are any deltas that are immediately\n * obvious from its topology. */\nfunction inferDeltas(diagram) {\n    let deltas = []\n    let knownZeros = new Set([\"0\"])\n    diagram = new Diagram(diagram)\n    for (const node of diagram.nodes()) {\n        const loop = findW3jLoop(node)\n        if (typeof loop == \"object\") {\n            if (loop.loopLine.direction % 2) {\n                knownZeros.add(loop.cutLine.superlineId)\n            }\n        }\n        if (node.type == \"w3j\") {\n            for (const line of node.lines()) {\n                if (knownZeros.has(line.superlineId)) {\n                    deltas.push([line.cycNodeLine(0, 1).superlineId,\n                                 line.cycNodeLine(0, 2).superlineId])\n                    break\n                }\n            }\n        }\n    }\n    deltas.push(Array.from(knownZeros))\n    return deltas\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Diagrammatic rules\n//\n// We distinguish between transformations used for editing (which generally\n// do not preserve the semantics) and transformations used for derivations\n// that always preserve equivalence.  The latter are called \"rules\".\n\nfunction flipW3jRule(diagram, nodeIndex) {\n    if (diagram.nodes[nodeIndex].type != \"w3j\") {\n        return diagram\n    }\n    diagram = deepClone(flipW3j(diagram, nodeIndex))\n    diagram.nodes[nodeIndex].lines.forEach(lineId =>\n        diagram.superlines = mergeSuperlineLists(diagram.superlines, {\n            [diagram.lines[lineId].superline]: {phase: 1},\n        }))\n    return diagram\n}\n\nfunction flipW1jRule(diagram, lineId) {\n    if (diagram.lines[lineId].superline == \"0\") {\n        diagram = deepClone(diagram)\n        diagram.lines[lineId].direction =\n            (diagram.lines[lineId].direction + 2) % 3 - 1\n    } else if (diagram.lines[lineId].direction) {\n        diagram = deepClone(diagram)\n        diagram.lines[lineId].direction *= -1\n        diagram.superlines = mergeSuperlineLists(diagram.superlines, {\n            [diagram.lines[lineId].superline]: {phase: 2}})\n    }\n    return diagram\n}\n\nfunction threeArrowRule(diagram, nodeIndex) {\n    const oldDiagram = new Diagram(diagram)\n    diagram = deepClone(diagram)\n    let node = diagram.nodes[nodeIndex]\n    if (node.type != \"w3j\") {\n        return diagram\n    }\n    const loop = findW3jLoop(oldDiagram.node(nodeIndex))\n    let loopId = null\n    if (typeof loop == \"object\") {\n        loopId = loop.loopLine.id\n    }\n\n    let direction = 0\n    // figure out the direction that would minimize the phase change\n    node.lines.forEach(function(lineId, lineIndex) {\n        const line = diagram.lines[lineId]\n        if (isLeftOfLine(diagram.nodes, nodeIndex, lineIndex)) {\n            direction -= line.direction\n        } else {\n            direction += line.direction\n        }\n    })\n    if (direction == 0) {\n        // we still don't have a direction, so let's just pick \"outgoing\"\n        direction = 1\n    } else if (direction == -3) {\n        // if all outgoing, completely reverse the direction\n        direction = -2\n    } else {\n        // normalize to one\n        direction = direction / Math.abs(direction)\n    }\n    node.lines.forEach(function(lineId, lineIndex) {\n        let line = Object.assign({}, diagram.lines[lineId])\n        if (isLeftOfLine(diagram.nodes, nodeIndex, lineIndex)) {\n            line.direction += direction\n        } else {\n            line.direction -= direction\n        }\n        diagram.lines[lineId] = line\n    })\n    node.lines.forEach(function(lineId, lineIndex) {\n        const line = diagram.lines[lineId]\n        const canonicalized = canonicalizeLine(line)\n        diagram.lines[lineId] = canonicalized.line\n        diagram.superlines = mergeSuperlineLists(diagram.superlines, {\n            [line.superline]: {phase: canonicalized.phase},\n        })\n    })\n    return diagram\n}\n\n/** @returns {Object<lineId, [nodeIndex1, lineIndex1,\n *                            nodeIndex2, lineIndex2]>} */\nfunction getLineEnds(diagram) {\n    let lineEnds = {}\n    diagram.nodes.forEach((node, nodeIndex) => {\n        node.lines.forEach((lineId, lineIndex) => {\n            let ends = lineEnds[lineId]\n            if (!ends) {\n                lineEnds[lineId] = [nodeIndex, lineIndex]\n            } else if (ends.length == 2) {\n                if (lexicalCmp([ends[0], ends[1]],\n                               [nodeIndex, lineIndex],\n                               defaultCmp) < 0) {\n                    lineEnds[lineId].push(nodeIndex, lineIndex)\n                } else {\n                    lineEnds[lineId].splice(0, 0, nodeIndex, lineIndex)\n                }\n            } else {\n                throw new Error(\"line must be connected to exactly 2 nodes\")\n            }\n        })\n    })\n    return lineEnds\n}\n\nclass DiagramLine {\n    constructor(diagram, id, reversed) {\n        console.assert(diagram)\n        this.diagram = diagram\n        this.id = id\n        this.reversed = Boolean(reversed)\n        Object.freeze(this)\n    }\n\n    get rawLine() {\n        return this.diagram.rawDiagram.lines[this.id]\n    }\n\n    get line() {\n        const f = this.reversed ? reverseLine : identity\n        return f(this.diagram.rawDiagram.lines[this.id])\n    }\n\n    get superline() {\n        return this.diagram.superline(this.superlineId)\n    }\n\n    get superlineId() {\n        return this.line.superline\n    }\n\n    get direction() {\n        if (this.rawLine.direction == null) {\n            return null\n        }\n        return this.rawLine.direction * (1 - this.reversed * 2)\n    }\n\n    node(end) {\n        const lineEnds = this.diagram._lineEnds[this.id]\n        return new DiagramNode(this.diagram,\n                               lineEnds[(this.reversed + end) % 2 * 2])\n    }\n\n    lineIndex(end) {\n        const lineEnds = this.diagram._lineEnds[this.id]\n        return lineEnds[(this.reversed + end) % 2 * 2 + 1]\n    }\n\n    cycNodeLine(end, offset) {\n        return this.node(end).line((this.lineIndex(end) + offset) % 3)\n    }\n\n    /** Called automatically when used as the name of a property. */\n    toString() {\n        return (this.reversed ? \"-\" : \"+\") + this.id\n    }\n\n    signedRebase(diagram) {\n        return diagram.signedLine(this.id, this.reversed)\n    }\n\n    reverse() {\n        return new DiagramLine(this.diagram, this.id, !this.reversed)\n    }\n\n    concat(...lines) {\n        return rawConcatLines(lines.map(line => line.line))\n    }\n\n    static removeSign(signedId) {\n        const id = signedId.substr(1)\n        let reversed = false\n        if (signedId[0] == \"-\") {\n            reversed = !reversed\n        } else if (signedId[0] != \"+\") {\n            throw new Error(`not a valid signed line ID: ${signedId}`)\n        }\n        return [id, reversed]\n    }\n\n    rawAssign(rawDiagram, end, lineId) {\n        rawDiagram.nodes[this.node(end).index].lines[this.lineIndex(end)] = lineId\n    }\n\n    testCuttability() {\n        let errors = [subdiagramOrientability(this),\n                      subdiagramOrientability(this.reverse())].filter(identity)\n        if (errors.length == 2) {\n            errors.sort((x, y) => x.priority - y.priority)\n            return errors[0].error\n        }\n        return null\n    }\n}\n\nclass DiagramNode {\n    constructor(diagram, index) {\n        this.diagram = diagram\n        this.index = index\n        Object.freeze(this)\n    }\n\n    get rawNode() {\n        return this.diagram.rawDiagram.nodes[this.index]\n    }\n\n    get type() {\n        return this.rawNode.type\n    }\n\n    get variable() {\n        if (this.type != \"terminal\") {\n            throw new Error(\"node is not a terminal\")\n        }\n        return this.rawNode.variable\n    }\n\n    get numLines() {\n        return this.rawNode.lines.length\n    }\n\n    line(index) {\n        const lineId = this.rawNode.lines[index]\n        const lineEnd = this.diagram._lineEnds[lineId]\n        const reversed = lineEnd[2] == this.index && lineEnd[3] == index\n        return new DiagramLine(this.diagram, lineId, reversed)\n    }\n\n    lines() {\n        return map(index => this.line(index), range(0, this.numLines))\n    }\n\n    get xy() {\n        return [this.rawNode.x, this.rawNode.y]\n    }\n}\n\nexport class Diagram {\n    constructor(rawDiagram) {\n        this.rawDiagram = Object.freeze(rawDiagram) || EMPTY_DIAGRAM\n        this._cache = {}\n        Object.freeze(this)\n    }\n\n    static deserialize(s) {\n        return new Diagram(JSON.parse(s))\n    }\n\n    get serialize() {\n        return JSON.stringify(this.rawDiagram)\n    }\n\n    get _lineEnds() {\n        let lineEnds = this._cache.lineEnds\n        if (!lineEnds) {\n            lineEnds = getLineEnds(this.rawDiagram)\n            this._cache.lineEnds = lineEnds\n        }\n        return lineEnds\n    }\n\n    get terminals() {\n        let terminals = this._cache.terminals\n        if (!terminals) {\n            terminals = {}\n            for (const node of this.nodes()) {\n                if (node.type == \"terminal\") {\n                    if (terminals[node.variable]) {\n                        throw new Error(\"duplicate terminal variables\")\n                    }\n                    terminals[node.variable] = node\n                }\n            }\n            this._cache.terminals = terminals\n        }\n        return terminals\n    }\n\n    terminal(variable) {\n        return this.terminals[variable]\n    }\n\n    get numNodes() {\n        return this.rawDiagram.nodes.length\n    }\n\n    node(index) {\n        return new DiagramNode(this, index)\n    }\n\n    * nodes() {\n        const numNodes = this.numNodes\n        for (let index = 0; index < numNodes; ++index) {\n            yield this.node(index)\n        }\n    }\n\n    get lineIds() {\n        return Object.keys(this.rawDiagram.lines)\n    }\n\n    signedLine(signedId, reversed) {\n        const [id, sign] = DiagramLine.removeSign(signedId)\n        return this.line(id, sign != Boolean(reversed))\n    }\n\n    line(id, reversed) {\n        return new DiagramLine(this, id, reversed)\n    }\n\n    lines() {\n        return map(id => this.line(id), this.lineIds)\n    }\n\n    get superlines() {\n        return this.rawDiagram.superlines\n    }\n\n    superline(superlineId) {\n        return this.superlines[superlineId]\n    }\n\n    hasSuperline(superlineId) {\n        return !!this.superline(superlineId)\n    }\n\n    isEquallyConstrained(superlineId, deltas) {\n        const related = relatedDelta(this.rawDiagram.deltas, superlineId)\n        const otherRelated = relatedDelta(deltas, superlineId)\n        return equalDeltas([related], [otherRelated])\n    }\n\n    renameLines(renames) {\n        let lines = {}\n        for (const lineId of Object.keys(this.rawDiagram.lines)) {\n            const newLineId = renames.hasOwnProperty(lineId)\n                            ? renames[lineId]\n                            : lineId\n            lines[newLineId] = this.rawDiagram.lines[lineId]\n        }\n        const nodes = this.rawDiagram.nodes.map(node =>\n            Object.freeze(Object.assign({}, node, {\n                lines: Object.freeze(node.lines.map(lineId =>\n                    propOr(renames, lineId, lineId)\n                ))\n            }))\n        )\n        return new Diagram(Object.assign({}, this.rawDiagram, {\n            nodes: Object.freeze(nodes),\n            lines: Object.freeze(lines),\n        }))\n    }\n\n    desumExposedSuperlines() {\n        return new Diagram(Object.assign({}, this.rawDiagram, {\n            superlines: mergeSuperlineLists(\n                this.rawDiagram.superlines,\n                ...Object.entries(this.rawDiagram.superlines)\n                .map(([superlineId, superline]) => (\n                    isSuperlineExposed(this.rawDiagram, superlineId)\n                    ? {[superlineId]: {summed: false}}\n                    : {}\n                ))),\n        }))\n    }\n\n    renameSuperlines(renames) {\n        return new Diagram(Object.assign({}, this.rawDiagram, {\n            lines: Object.freeze(Object.assign(\n                {},\n                ...Object.entries(this.rawDiagram.lines)\n                .map(([lineId, line]) => ({\n                    [lineId]: Object.freeze(Object.assign({}, line, {\n                        superline: propOr(renames, line.superline,\n                                          line.superline),\n                    })),\n                })))),\n            superlines: mergeSuperlineLists(\n                ...Object.entries(this.rawDiagram.superlines)\n                .map(([superlineId, superline]) => ({\n                    [propOr(renames, superlineId, superlineId)]: superline,\n                }))),\n            deltas: mergeDeltas(\n                this.rawDiagram.deltas.map(delta =>\n                    delta.map(superlineId =>\n                        propOr(renames, superlineId, superlineId)))),\n        })).removeUnusedSuperlines().desumExposedSuperlines()\n    }\n\n    removeUnusedSuperlines() {\n        let marked = Object.assign({}, this.rawDiagram.superlines)\n        for (const superlineId of Object.keys(marked)) {\n            if (!isEmptySuperline(marked[superlineId])) {\n                delete marked[superlineId]\n            }\n        }\n        for (const line of this.lines()) {\n            delete marked[line.superlineId]\n        }\n        for (const delta of this.rawDiagram.deltas) {\n            for (const superlineId of delta) {\n                delete marked[superlineId]\n            }\n        }\n        let superlines = Object.assign({}, this.rawDiagram.superlines)\n        for (const superlineId of Object.keys(marked)) {\n            delete superlines[superlineId]\n        }\n        if (superlines[\"0\"]) {\n            superlines[\"0\"] = EMPTY_SUPERLINE\n        }\n        return new Diagram(Object.assign({}, this.rawDiagram, {\n            superlines: superlines,\n        }))\n    }\n\n    /** Substitute a portion of this diagram for another subdiagram.\n     *\n     * Patterns are similar to diagrams, but also slightly different:\n     *\n     * - lineIds must refer to existing lines and must be prefixed by `+` or `-`\n     *   to indicate whether it should be treated as reversed\n     * - `line.direction: MATCH_ANY` will absorb any direction\n     */\n    substitute(pattern, replacement, flags) {\n        // schematic idea:\n        //\n        // orig: --- X1 --- N1 --- N2 --- X2 ---\n        // patt:     T1 --- N1 --- N2 --- T2\n        // repl:     T1 ------- N3 ------ T2\n        // new:  --- X1 ------- N3 ------ X2 ---\n        //\n        // anchor = a node that where gluing occurs;\n        //   for 'pattern', all terminals are anchors\n        //   for 'replacement', only terminals that match the pattern are\n        //\n        // the interesting/tricky parts occur on the terminals of the pattern;\n        // this is where we have to glue the original diagram to the\n        // replacement subdiagram.\n        //\n        // we have to make sure that the phases on X1-N1 are appropriately\n        // merged into X1-N3 and similarly for N2-X2, and also account for\n        // degenerate cases\n\n        flags = flags || {}\n        pattern = ensureDiagram(pattern)\n        replacement = ensureDiagram(replacement)\n        const rawDiagram = this.rawDiagram\n        const pattDiagram = new Diagram(pattern)\n        let replDiagram = new Diagram(replacement)\n\n        // DELTAS\n        // ------\n\n        // (shared with other parts)\n        let deltaMerge = [rawDiagram.deltas, replacement.deltas]\n\n        // match deltas\n        if (!containsDeltas(rawDiagram.deltas, pattern.deltas)) {\n            throw new Error(\"mismatch in deltas\")\n        }\n\n        // SHARED LINES\n        // ------------\n\n        // we allow a limited form of sharing: two pattern lines can map onto\n        // the same original line as long as the orientation is different;\n        // this in turn has the potential to create loops\n        let sharedLines = {}\n        let seenLines = {}\n        for (const pattLine of pattDiagram.lines()) {\n            const id = DiagramLine.removeSign(pattLine.id)[0]\n            const seen = seenLines[id]\n            if (seen) {\n                if (!(seen.node(0).type == \"terminal\" ||\n                      seen.node(1).type == \"terminal\")\n                    || !(pattLine.node(0).type == \"terminal\" ||\n                         pattLine.node(1).type == \"terminal\")) {\n                    throw new Error(\"a single internal line cannot \"\n                                  + \"match multiple lines\")\n                }\n                if (pattLine.node(0).type == \"terminal\"\n                    && pattLine.node(1).type == \"terminal\") {\n                    // this causes ambiguity and breakage\n                    throw new Error(\"a lone pattern line cannot be shared\")\n                }\n                if (sharedLines[pattLine.id] || sharedLines[seen.id]) {\n                    throw new Error(\"looped lines can only appear twice\")\n                }\n                sharedLines[pattLine.id] = seen.id\n                sharedLines[seen.id] = pattLine.id\n                continue\n            }\n            seenLines[id] = pattLine\n        }\n\n        // LINE RENAMING\n        // -------------\n\n        // (shared with other parts)\n        let newLines = Object.assign({}, rawDiagram.lines)\n\n        // must remove the pattern lines first, because we want to know which\n        // line IDs are available to us\n        for (const pattLine of pattDiagram.lines()) {\n            const lineId = DiagramLine.removeSign(pattLine.id)[0]\n            console.assert(newLines[lineId] || sharedLines[pattLine.id])\n            delete newLines[lineId]\n        }\n        // rename the replacement diagram to avoid conflicting line IDs\n        // and also replace the dummy line IDs\n        let freshLineIds = availLabels(newLines)\n        let lineRenames = {}\n        for (const line of replDiagram.lines()) {\n            if (line.id.startsWith(\"$\") || newLines.hasOwnProperty(line.id)) {\n                lineRenames[line.id] = freshLineIds.next().value\n            }\n        }\n        replDiagram = replDiagram.renameLines(lineRenames)\n        replacement = replDiagram.rawDiagram\n\n        // SUPERLINES\n        // ----------\n\n        // (shared with other parts)\n        let superlineMerge = [rawDiagram.superlines]\n\n        // match superlines and adjust phases\n        let summedSuperlines = new Set()\n        for (const superlineId of Object.keys(pattern.superlines)) {\n            const pattSuperline = pattern.superlines[superlineId]\n            const superline = rawDiagram.superlines[superlineId]\n            if (pattSuperline.summed) {\n                if (superlineId != \"0\") {\n                    if (!superline.summed) {\n                        throw new Error(\"expected summed superline\")\n                    }\n                    if (pattSuperline.weight != superline.weight) {\n                        throw new Error(\"weight of summed superline must match\")\n                    }\n                    if (pattSuperline.phase != superline.phase) {\n                        throw new Error(\"phase of summed superline must match\")\n                    }\n                    if (!this.isEquallyConstrained(superlineId,\n                                                   replacement.deltas)) {\n                        throw new Error(\"deltas of summed superline must match\")\n                    }\n                    summedSuperlines.add(superlineId)\n                }\n                superlineMerge.push({[superlineId]: {summed: false}})\n            }\n            superlineMerge.push({\n                [superlineId]: {\n                    weight: -pattSuperline.weight,\n                    phase: -pattSuperline.phase,\n                },\n            })\n        }\n        // forbid variable capture\n        for (const superlineId of Object.keys(replacement.superlines)) {\n            const replSuperline = replacement.superlines[superlineId]\n            if (replSuperline.summed) {\n                const pattSuperline = pattern.superlines[superlineId]\n                if (pattSuperline) {\n                    if (!pattSuperline.summed) {\n                        throw new Error(\"summed variable conflicts \"\n                                      + \"with pattern\")\n                    }\n                } else if (rawDiagram.superlines[superlineId]) {\n                    throw new Error(\"summed variable conflicts with original\")\n                }\n            }\n        }\n        superlineMerge.push(replacement.superlines)\n\n        // NODES\n        // -----\n\n        // match nodes and adjust phases\n        for (const pattNode of pattDiagram.nodes()) {\n            if (pattNode.type == \"terminal\") {\n                continue\n            }\n            if (pattNode.numLines == 0) {\n                throw new Error(\"singleton nodes are not supported\")\n            }\n            const node = pattNode.line(0).signedRebase(this).node(0)\n            if (node.type != pattNode.type) {\n                throw new Error(\"node type mismatch\")\n            }\n            const nodeLines = Array.from(node.rawNode.lines)\n            const pattNodeLines = Array.from(pattNode.rawNode.lines)\n            if (node.type == \"w3j\") {\n                const uniqueLines = permutSign(nodeLines, nodeLines)\n                const sign = permutSign(\n                    nodeLines,\n                    pattNodeLines.map(signedId =>\n                        DiagramLine.removeSign(signedId)[0]))\n                if (uniqueLines && sign == 0) {\n                    throw new Error(\"node lines mismatch\")\n                }\n                if (sign < 0) {\n                    superlineMerge.push(\n                        {[nodeLines[0]]: {phase: 1}},\n                        {[nodeLines[1]]: {phase: 1}},\n                        {[nodeLines[2]]: {phase: 1}},\n                    )\n                }\n            } else if (lexicalCmp(nodeLines, pattNodeLines, defaultCmp) != 0) {\n                throw new Error(\"node lines mismatch\")\n            }\n        }\n\n        // LINES\n        // -----\n\n        // match lines and adjust phases\n        let matchedLineIds = new Set()\n        for (const pattLine of pattDiagram.lines()) {\n            const pattNode0 = pattLine.node(0)\n            const pattNode1 = pattLine.node(1)\n            const line = pattLine.signedRebase(this)\n            if (line.superlineId != pattLine.superlineId) {\n                throw new Error(\"superline ID mismatch in lines\")\n            }\n            if (pattNode0.type != \"terminal\"\n                && pattNode1.type != \"terminal\"\n                && pattLine.direction != null) {\n                const diffDirection = mergeDirections(line.direction,\n                                                     -pattLine.direction)\n                if (line.superlineId != \"0\" && diffDirection % 2 != 0) {\n                    throw new Error(\"directedness mismatch in lines\")\n                }\n                superlineMerge.push({\n                    [line.superlineId]: {phase: diffDirection},\n                })\n            }\n            matchedLineIds.add(line.id)\n        }\n        // prevent summed superlines from appearing outside the pattern\n        const patternSuperlineSet = new Set(Object.keys(pattern.superlines))\n        for (const line of this.lines()) {\n            if (!matchedLineIds.has(line.id) &&\n                summedSuperlines.has(line.superlineId)) {\n                throw new Error(\"summed line must not appear outside match\")\n            }\n        }\n\n        let nodes = rawDiagram.nodes.map(node => Object.assign({}, node, {\n            lines: node.lines.slice(),\n        }))\n        let replNodes = replacement.nodes.map(node => Object.assign({}, node, {\n            lines: node.lines.slice(),\n        }))\n        let seenReplLines = {}\n        // find the node that we should join to\n        //\n        // context: this, pattDiagram, nodes, replNodes, seenReplLines\n        const findJoiningNode = replLine => {\n            // There's several cases to consider here.\n            //\n            // In the simplest case, with no shared lines, we have:\n            //\n            // orig  N1 --->---\n            // patt     ---<--- TP\n            // repl     --->--- TR\n            //\n            // A shared line case might look like this:\n            //\n            //          -------------------------\n            //         /                         \\\n            //         \\                         /\n            // orig     -->---             ------\n            // patt    ---<--- TP1     TP2 --->---\n            // repl    --->--- TR1     TR2 --->---\n            //\n            // This could go on for several jumps, if the node opposite to\n            // TR2 is an anchor too.  It could even loop back to itself.\n            let lines = [replLine.line]\n            while (true) {\n                const replNode = replLine.node(1)\n                const result = {\n                    type: \"replacement\",\n                    lines: lines,\n                    line: replLine,\n                    lineId: replLine.id,\n                    nodes: replNodes,\n                }\n                if (replNode.type != \"terminal\") {\n                    return result\n                }\n                const pattNode = pattDiagram.terminal(replNode.variable)\n                if (!pattNode) {\n                    return result\n                }\n                seenReplLines[replLine.id] = true\n                const pattLine = pattNode.line(0)\n                const line = pattLine.signedRebase(this).reverse()\n                // avoid consuming phases twice if the pattern line is\n                // terminal-to-terminal\n                if (pattLine.node(1).type != \"terminal\" || !pattLine.reversed) {\n                    lines.push(pattLine.line, line.line)\n                }\n                const otherPattLineId = sharedLines[pattLine.id]\n                if (!otherPattLineId) {\n                    // no shared line, so joining node is from original diagram\n                    return {\n                        type: \"original\",\n                        lines: lines,\n                        line: line,\n                        lineId: replLine.id,\n                        nodes: nodes,\n                    }\n                }\n                // we have shared line, so joining node comes from elsewhere\n                const otherPattLine = pattDiagram.line(otherPattLineId,\n                                                       pattLine.reversed)\n                const otherPattNode = otherPattLine.node(0)\n                if (otherPattNode.type != \"terminal\") {\n                    throw new Error(\"expected terminal node\")\n                }\n                lines.push(otherPattLine.reverse().line)\n                replLine = replDiagram.terminal(otherPattNode.variable).line(0)\n                if (seenReplLines[replLine.id]) {\n                    // we found a loop\n                    return {\n                        type: \"cycle\",\n                        lines: lines,\n                    }\n                }\n                lines.push(replLine.line)\n            }\n        }\n        function getPart(joining) {\n            switch (joining.type) {\n                case \"replacement\":\n                    return joining.line.node(1).type == \"terminal\" ? -1 : 1\n                case \"original\":\n                    return 0\n                default:\n                    throw new Error(\"joining type not valid here\")\n            }\n        }\n        for (const replLine of replDiagram.lines()) {\n            if (seenReplLines[replLine.id]) {\n                continue // avoid double-counting\n            }\n            const joining0 = findJoiningNode(replLine.reverse())\n            if (joining0.type == \"cycle\") {\n                // special case: cycle\n                const combined = concatLines(...joining0.lines)\n                deltaMerge.push([combined.delta])\n                if (combined.line.direction % 2) {\n                    throw new Error(\"directed loops are forbidden\")\n                }\n                superlineMerge.push({\n                    [combined.line.superline]: {\n                        phase: combined.phase,\n                        weight: 2,\n                    },\n                })\n                continue\n            }\n            const joining1 = findJoiningNode(replLine)\n            const lineId = joining0.lineId\n            const nodeIndex0 = joining0.line.node(1).index\n            const nodeIndex1 = joining1.line.node(1).index\n            const lineIndex0 = joining0.line.lineIndex(1)\n            const lineIndex1 = joining1.line.lineIndex(1)\n            const lines = joining0.lines\n                                  .map(reverseLine)\n                                  .reverse()\n                                  .concat(joining1.lines.slice(1))\n            const f = lexicalCmp([getPart(joining0), nodeIndex0, lineIndex0],\n                                 [getPart(joining1), nodeIndex1, lineIndex1],\n                                 defaultCmp) > 0\n                    ? reverseLine : identity\n            joining0.nodes[nodeIndex0].lines[lineIndex0] = lineId\n            joining1.nodes[nodeIndex1].lines[lineIndex1] = lineId\n            const combined = concatLines(...lines)\n            // prefer superlines that aren't summed to avoid\n            // exposing them as external lines\n            deltaMerge.push([combined.delta])\n            console.assert(!newLines[lineId])\n            let superline = combined.line.superline\n            for (const superlineId of combined.delta) {\n                if (!this.superline(superlineId) ||\n                    !this.superline(superlineId).summed) {\n                    superline = superlineId\n                    break\n                }\n            }\n            newLines[lineId] = ensureLine(f(Object.assign({}, combined.line, {\n                superline: superline,\n            })))\n            superlineMerge.push({\n                [combined.line.superline]: {phase: combined.phase},\n            })\n        }\n\n        const newNodes = Array.prototype.concat(\n            replacement.nodes.filter((node, nodeIndex) =>\n                node.type == \"terminal\" && !pattDiagram.terminal(node.variable)\n            ),\n            arrayRemoveMany(\n                nodes,\n                Array.from(\n                    map(node => node.line(0)\n                                    .signedRebase(this)\n                                    .node(0)\n                                    .index,\n                        filter(node => node.type != \"terminal\",\n                               pattDiagram.nodes())))),\n            replacement.nodes.filter(node => node.type != \"terminal\"))\n\n        const newDiagram = new Diagram(Object.assign({}, rawDiagram, {\n            nodes: newNodes,\n            lines: newLines,\n            superlines: mergeSuperlineLists(...superlineMerge),\n            deltas: mergeDeltas(...deltaMerge),\n        })).removeUnusedSuperlines()\n\n        if (flags.withLineRenames) {\n            return {diagram: newDiagram, lineRenames: lineRenames}\n        } else {\n            return newDiagram\n        }\n    }\n}\n\nfunction findW3jLoop(node) {\n    if (node.type != \"w3j\") {\n        return \"not a Wigner 3-jm symbol\"\n    }\n    for (let i = 0; i < 3; ++i) {\n        if (node.line(i).id == node.line((i + 1) % 3).id) {\n            return {\n                cutLine: node.line((i + 2) % 3),\n                loopLine: node.line(i),\n            }\n        }\n    }\n    return \"no loops found\"\n}\n\nfunction loopElimRule(diagram, lineId, nodeIndex) {\n    diagram = new Diagram(diagram)\n    const loopNode = diagram.line(lineId).node(0)\n    if (loopNode.index != diagram.line(lineId).node(1).index) {\n        return \"no loops found\"\n    }\n    const loop = findW3jLoop(loopNode)\n    if (typeof loop != \"object\") {\n        return loop\n    }\n    if (!isLineDirectable(loop.loopLine.line)) {\n        return \"loop must be directed\"\n    }\n    const otherNode = loop.cutLine.node(1)\n    if (otherNode.type != \"w3j\") {\n        diagram = deepClone(diagram.rawDiagram)\n        diagram.deltas = mergeDeltas(\n            diagram.deltas,\n            [[diagram.lines[loop.cutLine.id].superline, \"0\"]])\n        diagram.lines[loop.cutLine.id].superline = \"0\"\n        diagram.superlines[\"0\"] = EMPTY_SUPERLINE\n        return diagram\n    }\n    if (otherNode.index != nodeIndex && loopNode.index != nodeIndex) {\n        return \"not sure what you're trying to do\"\n    }\n    const ld = loop.loopLine\n    const lc = loop.cutLine\n    const lb = loop.cutLine.cycNodeLine(1, 1).reverse()\n    const la = loop.cutLine.cycNodeLine(1, 2).reverse()\n    if (la.id == lb.id && !isLineDirectable(la.line)) {\n        // other loop must be directed too if we want to eliminate it\n        diagram = deepClone(diagram.rawDiagram)\n        diagram.deltas = mergeDeltas(\n            diagram.deltas,\n            [[diagram.lines[loop.cutLine.id].superline, \"0\"]])\n        diagram.lines[loop.cutLine.id].superline = \"0\"\n        diagram.superlines[\"0\"] = EMPTY_SUPERLINE\n        return diagram\n    }\n    const md = ld.toString()\n    const mc = lc.toString()\n    const mb = lb.toString()\n    const ma = la.toString()\n    const jd = ld.superlineId\n    const jc = lc.superlineId\n    const jb = lb.superlineId\n    const ja = la.superlineId\n    return diagram.substitute({\n        nodes: [\n            terminalNode(ma, \"a\"),\n            terminalNode(mb, \"b\"),\n            w3jNode(md, md, mc),\n            w3jNode(mc, mb, ma),\n        ],\n        lines: {\n            [md]: {superline: jd, direction: +1},\n            [mc]: {superline: jc, direction: null},\n            [mb]: {superline: jb, direction: 0},\n            [ma]: {superline: ja, direction: +1},\n        },\n        superlines: {\n            [ja]: {weight: 1},\n        },\n    }, {\n        nodes: [\n            terminalNode(\"$1\", \"a\"),\n            terminalNode(\"$1\", \"b\"),\n        ],\n        lines: {\n            $1: {superline: jb, direction: 0,\n                 arcHeight: -8 * lb.line.arcHeight}, // empirically works...\n        },\n        superlines: {\n            [jd]: {weight: 1},\n            \"0\": {},\n        },\n        deltas: [\n            [\"0\", jc],\n        ],\n    }).rawDiagram\n}\n\nfunction loopIntroRule(diagram, lineId, xy1, xy2) {\n    diagram = new Diagram(diagram)\n    const line = diagram.line(lineId)\n    const dxy = vectorSubtract(xy2, xy1)\n    const angle = Math.atan2(dxy[1], dxy[0])\n    return diagram.substitute({\n        nodes: [\n            terminalNode(line.toString(), \"a\"),\n            terminalNode(line.toString(), \"b\"),\n        ],\n        lines: {\n            [line]: {superline: line.superlineId, direction: 0},\n        },\n    }, {\n        nodes: [\n            terminalNode(\"$1\", \"a\"),\n            terminalNode(\"$2\", \"b\"),\n            w3jNode(\"$4\", \"$4\", \"$3\", ...xy2),\n            w3jNode(\"$3\", \"$2\", \"$1\", ...xy1),\n        ],\n        lines: {\n            $4: {superline: \"0\", direction: +1,\n                 angle: angle - 0.5 * Math.PI, arcHeight: 50.0},\n            $3: {superline: \"0\", direction: 0},\n            $2: {superline: line.superlineId, direction: 0,\n                 arcHeight: -line.line.arcHeight / 4},\n            $1: {superline: line.superlineId, direction: +1,\n                 arcHeight: -line.line.arcHeight / 2},\n        },\n        superlines: {\n            [line.superlineId]: {weight: 1},\n        },\n    }).rawDiagram\n}\n\nfunction w3jIntroRule(diagram, lineId1, lineId2, reversed, diagonal) {\n    diagram = new Diagram(diagram)\n    let line1 = diagram.line(lineId1)\n    let line2 = diagram.line(lineId2)\n    if ((vectorDot(\n        vectorSubtract(line1.node(1).xy, line1.node(0).xy),\n        vectorSubtract(line2.node(1).xy, line2.node(0).xy),\n    ) < 0) != Boolean(reversed)) {\n        line2 = line2.reverse()\n    }\n    const xy1 = vectorAdd(\n        scalarMultiply(0.375, vectorAdd(line1.node(0).xy, line2.node(0).xy)),\n        scalarMultiply(0.125, vectorAdd(line1.node(1).xy, line2.node(1).xy)),\n    )\n    const xy2 = vectorAdd(\n        scalarMultiply(0.125, vectorAdd(line1.node(0).xy, line2.node(0).xy)),\n        scalarMultiply(0.375, vectorAdd(line1.node(1).xy, line2.node(1).xy)),\n    )\n    const j = availSuperlineLabels(diagram.rawDiagram).next().value\n    const arcHeight1 = line1.node(0).index == line2.node(0).index ? 50.0 : 0.0\n    const arcHeight2 = line1.node(1).index == line2.node(1).index ? 50.0 : 0.0\n    return diagram.substitute({\n        nodes: [\n            terminalNode(line1.toString(), \"a\"),\n            terminalNode(line1.toString(), \"b\"),\n            terminalNode(line2.toString(), \"c\"),\n            terminalNode(line2.toString(), \"d\"),\n        ],\n        lines: {\n            [line1]: {superline: line1.superlineId, direction: 0},\n            [line2]: {superline: line2.superlineId, direction: 0},\n        },\n    }, {\n        nodes: [\n            terminalNode(\"$1\", \"a\"),\n            terminalNode(\"$2\", \"b\"),\n            terminalNode(\"$3\", \"c\"),\n            terminalNode(\"$4\", \"d\"),\n            w3jNode(\"$1\", \"$3\", \"$5\", ...xy1),\n            w3jNode(\"$2\", \"$4\", \"$5\", ...xy2),\n        ],\n        lines: {\n            $1: {superline: line1.superlineId, direction: Number(diagonal),\n                 arcHeight: -arcHeight1},\n            $2: {superline: line1.superlineId, direction: Number(diagonal),\n                 arcHeight: -arcHeight2},\n            $3: {superline: line2.superlineId, direction: 0,\n                 arcHeight: arcHeight1},\n            $4: {superline: line2.superlineId, direction: 0,\n                 arcHeight: arcHeight2},\n            $5: {superline: j, direction: 0},\n        },\n        superlines: {\n            [j]: {phase: 0, weight: 2, summed: true},\n        },\n    }).rawDiagram\n}\n\nfunction w3jElimRule(diagram, lineId) {\n    diagram = new Diagram(diagram)\n    const line = diagram.line(lineId)\n    const superline = line.superline\n    if (!superline.summed) {\n        return `j[${line.superlineId}] must be summed over`\n    }\n    if (superline.phase != 0) {\n        return `j[${line.superlineId}] must not have any phases`\n    }\n    if (superline.weight != 2) {\n        return `weight of j[${line.superlineId}] must be exactly 2`\n    }\n    if (!diagram.isEquallyConstrained(line.superlineId, [])) {\n        return `j[${line.superlineId}] must not be constrained by deltas`\n    }\n    for (const otherLine of diagram.lines()) {\n        if (otherLine.id != line.id && otherLine.superlineId == line.superlineId) {\n            return `j[${line.superlineId}] must not appear anywhere else`\n        }\n    }\n    if (line.node(0).type != \"w3j\" || line.node(1).type != \"w3j\") {\n        return \"expected Wigner 3-j symbols\"\n    }\n    const line1 = line.cycNodeLine(0, 1).reverse()\n    const line2 = line.cycNodeLine(1, 1).reverse()\n    const line3 = line.cycNodeLine(0, 2).reverse()\n    const line4 = line.cycNodeLine(1, 2).reverse()\n    if (line1.superlineId != line2.superlineId\n        || line3.superlineId != line4.superlineId) {\n        return \"opposing j's don't match\"\n    }\n    const lineIdOther = line1.id == line3.id ? line4.id : line3.id\n    console.assert(line1.id, lineIdOther)\n    return diagram.substitute({\n        nodes: [\n            terminalNode(line1.toString(), \"a\"),\n            terminalNode(line2.toString(), \"b\"),\n            terminalNode(line3.toString(), \"c\"),\n            terminalNode(line4.toString(), \"d\"),\n            w3jNode(line1.toString(), line3.toString(), line.toString()),\n            w3jNode(line2.toString(), line4.toString(), line.toString()),\n        ],\n        lines: {\n            [line1]: {superline: line1.superlineId, direction: 0},\n            [line2]: {superline: line2.superlineId, direction: 0},\n            [line3]: {superline: line3.superlineId, direction: 0},\n            [line4]: {superline: line4.superlineId, direction: 0},\n            [line]: {superline: line.superlineId, direction: 0},\n        },\n        superlines: {\n            [line.superlineId]: {phase: 0, weight: 2, summed: true},\n        },\n    }, {\n        nodes: [\n            terminalNode(line1.id, \"a\"),\n            terminalNode(line1.id, \"b\"),\n            terminalNode(lineIdOther, \"c\"),\n            terminalNode(lineIdOther, \"d\"),\n        ],\n        lines: {\n            [line1.id]: {superline: line1.superlineId, direction: 0},\n            [lineIdOther]: {superline: line3.superlineId, direction: 0},\n        },\n    }).rawDiagram\n}\n\nfunction getAmbientDirections(diagram, ignoreExternal) {\n    // lines we don't care about:\n    // - external lines with no pre-existing direction\n    // - zero lines\n    // however, unlike zero lines, we do still need to *show* the correct\n    // arrows, so we can't toss out those external lines entirely!\n    let excludedLineIds = []\n    let directions = new RealSparseVector()\n    for (const line of diagram.lines()) {\n        if (line.superlineId != \"0\") {\n            if ([line.node(0).type, line.node(1).type].includes(\"terminal\")\n                && (ignoreExternal || line.direction % 2 == 0)) {\n                excludedLineIds.push(line.id)\n            }\n            directions.set(line.id, 1 - mod(line.direction, 2))\n        }\n    }\n    let matrix = new RealSparseMatrix()\n    for (const node of diagram.nodes()) {\n        if (node.type == \"w3j\") {\n            for (const line of node.lines()) {\n                if (line.superlineId != \"0\") {\n                    matrix.modify(line.id, node.index,\n                                  x => x + (line.reversed ? -1 : 1))\n                }\n            }\n        }\n    }\n    let subdirections = directions.copy()\n    let submatrix = matrix.map(x => mod(x, 2))\n    for (const lineId of excludedLineIds) {\n        subdirections.delete(lineId)\n        submatrix.deleteRow(lineId)\n    }\n    const result = sparseGaussElim(GF2_FIELD, submatrix, subdirections)\n    const ambient = sparseMatrixVectorMultiply(REAL_FIELD, matrix,\n                                               result.solution.map(x => -x))\n    return {\n        orientable: result.consistent,\n        directions: ambient,\n        target: subdirections,\n    }\n}\n\nfunction getConnectedSubdiagram(line0) {\n    let closed = true\n    let isolated = true\n    let nodeIndices = new Set()\n    let lines = {}\n    let candidates = [line0]\n    while (candidates.length > 0) {\n        const line = candidates.pop()\n        if (lines.hasOwnProperty(line.id)) {\n            if (line.id == line0.id && line.reversed == line0.reversed) {\n                isolated = false\n            }\n            continue\n        }\n        const node = line.node(1)\n        if (node.type == \"terminal\") {\n            closed = false\n        }\n        nodeIndices.add(node.index)\n        lines[line.id] = line.rawLine\n        for (const line of node.lines()) {\n            candidates.push(line)\n        }\n    }\n    const rawDiagram = line0.diagram.rawDiagram\n    return {\n        closed: closed,\n        isolated: isolated,\n        diagram: Object.assign({}, rawDiagram, {\n            nodes: rawDiagram.nodes.filter((_, nodeIndex) =>\n                nodeIndices.has(nodeIndex)),\n            lines: lines,\n        }),\n    }\n}\n\nfunction subdiagramOrientability(line0) {\n    const subdiagram = getConnectedSubdiagram(line0)\n    if (!subdiagram.isolated) {\n        return {\n            error: \"only bridges can be cut\",\n            priority: 1,\n        }\n    }\n    if (!subdiagram.closed) {\n        return {\n            error: \"subdiagram must be closed\",\n            priority: 2,\n        }\n    }\n    const diagram = Object.assign({}, subdiagram.diagram)\n    diagram.lines = Object.assign({}, diagram.lines)\n    diagram.lines[line0.id] = Object.assign({}, diagram.lines[line0.id], {\n        superline: \"0\",\n    })\n    const ambient = getAmbientDirections(new Diagram(diagram), true)\n    if (!ambient.orientable) {\n        return {\n            error: \"diagram is non-orientable\",\n            priority: 0,\n        }\n    }\n    return null\n}\n\nfunction cutRule(diagram, lineId, xy1, xy2) {\n    diagram = new Diagram(diagram)\n    const line = diagram.line(lineId)\n    if (vectorDot(vectorSubtract(xy1, xy2),\n                  vectorSubtract(line.node(0).xy, line.node(1).xy)) < 0) {\n        [xy1, xy2] = [xy2, xy1]\n    }\n    if (line.superlineId != \"0\") {\n        let error = line.testCuttability()\n        if (error) {\n            return error\n        }\n    }\n    const dxy = vectorSubtract(xy1, xy2)\n    const angle = Math.atan2(dxy[1], dxy[0])\n    const result = diagram.substitute({\n        nodes: [\n            terminalNode(line.toString(), \"a\"),\n            terminalNode(line.toString(), \"b\"),\n        ],\n        lines: {\n            [line]: {superline: line.superlineId, direction: 0},\n        },\n    }, {\n        nodes: [\n            terminalNode(\"$1\", \"a\"),\n            terminalNode(\"$2\", \"b\"),\n            w3jNode(\"$1\", \"$3\", \"$3\", xy1[0], xy1[1]),\n            w3jNode(\"$2\", \"$4\", \"$4\", xy2[0], xy2[1]),\n        ],\n        lines: {\n            $1: {superline: line.superlineId, direction: 0,\n                 arcHeight: -0.5 * line.line.arcHeight},\n            $2: {superline: line.superlineId, direction: 0,\n                 arcHeight: -0.25 * line.line.arcHeight},\n            $3: {superline: \"0\", direction: 0,\n                 angle: angle + 0.5 * Math.PI, arcHeight: 50},\n            $4: {superline: \"0\", direction: 0,\n                 angle: angle + 1.5 * Math.PI, arcHeight: 50},\n        },\n        deltas: [\n            [\"0\", line.superlineId],\n        ],\n    }, {withLineRenames: true})\n    diagram = result.diagram.rawDiagram\n    // try to eliminate the loops if possible\n    const renames = result.lineRenames\n    const loop1Id = result.diagram.line(renames.$3).id\n    const loop2Id = result.diagram.line(renames.$4).id\n    const loopNode1Index = result.diagram.line(loop1Id).node(0).index\n    // kind of fragile: relying on the fact that pruning doesn't relabel lines\n    let newDiagram = loopElimRule(diagram, loop1Id, loopNode1Index)\n    if (typeof newDiagram == \"string\") {\n        return diagram\n    }\n    diagram = newDiagram\n    const loopNode2Index = new Diagram(diagram).line(loop2Id).node(0).index\n    newDiagram = loopElimRule(diagram, loop2Id, loopNode2Index)\n    if (typeof newDiagram == \"string\") {\n        return diagram\n    }\n    return newDiagram\n}\n\nfunction glueRule(diagram, lineId1, lineId2, xy1, xy2) {\n    diagram = new Diagram(diagram)\n    const line1 = diagram.line(lineId1)\n    const line2 = diagram.line(lineId2)\n    if (line1.id == line2.id) {\n        return diagram // not supported (tricky to implement / easy workaround)\n    }\n    return diagram.substitute({\n        nodes: [\n            terminalNode(line1.toString(), \"a\"),\n            terminalNode(line1.toString(), \"b\"),\n            terminalNode(line2.toString(), \"c\"),\n            terminalNode(line2.toString(), \"d\"),\n        ],\n        lines: {\n            [line1]: {superline: line1.superlineId, direction: +1},\n            [line2]: {superline: line2.superlineId, direction: +1},\n        },\n    }, {\n        nodes: [\n            terminalNode(\"$1\", \"a\"),\n            terminalNode(\"$2\", \"b\"),\n            terminalNode(\"$3\", \"c\"),\n            terminalNode(\"$4\", \"d\"),\n            w3jNode(\"$1\", \"$2\", \"$5\", xy1[0], xy1[1]),\n            w3jNode(\"$3\", \"$4\", \"$5\", xy2[0], xy2[1]),\n        ],\n        lines: {\n            $1: {superline: line1.superlineId, direction: 0},\n            $2: {superline: line1.superlineId, direction: 0},\n            $3: {superline: line2.superlineId, direction: 0},\n            $4: {superline: line2.superlineId, direction: 0},\n            $5: {superline: \"0\", direction: 0},\n        },\n        superlines: mergeSuperlineLists( // these superlineIds might collide!\n            {[line1.superlineId]: {weight: +1}},\n            {[line2.superlineId]: {weight: +1}},\n        ),\n    }).rawDiagram\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Drawing\n\nfunction renderArrow(update, diagram, lineId, ambient) {\n    const arrowHeadSize = 15\n    const line = diagram.lines[lineId]\n    let bad = false\n    let expectedDirection = false\n    let direction = line.direction\n    if (ambient) {\n        expectedDirection = ambient.target.get(lineId)\n        const ambientDirection = ambient.directions.get(lineId)\n        bad = !direction == !ambientDirection\n        direction = direction || ambientDirection\n    }\n    if (direction == 0 && !expectedDirection) {\n        return []\n    }\n    if (line.arrowPos < 0.0) {\n        line.arrowPos = 0.0\n    } else if (line.arrowPos > 1.0) {\n        line.arrowPos = 1.0\n    }\n    const info = getLineInfo(diagram, lineId)\n    // the coordinate we need is the tip of the arrow (which follows the\n    // contour of the line), but we want to try to keep the body of\n    // the arrow centered\n    const correction = direction * arrowHeadSize / 2\n    const position = positionOnLine(info, line.arrowPos, correction)\n    const rawPosition = positionOnLine(info, line.arrowPos, 0)\n    const angle = position.tangentAngle\n                + Number(direction < 0) * Math.PI\n    return [vnode(\n        \"svg:g\",\n        {\n            \"class\": \"arrow \"\n                   + (!line.direction ? \"ambient \" : \"\")\n                   + (info.external ? \"external \" : \"\")\n                   + (bad ? \"bad \" : \"\"),\n            onmousedown: function(e) {\n                if (e.buttons == 1) {\n                    update(startDrag(rawPosition.x, rawPosition.y, {\n                        superficial: true,\n                    }, (diagram, x, y, snap) => {\n                        const pos = findPosOnLine(info, x, y).pos\n                        let lines = Object.assign({}, diagram.lines)\n                        // prevent arrows from getting stuck under nodes\n                        lines[lineId] = Object.assign({}, lines[lineId], {\n                            arrowPos: clamp(0.1, 0.9, round(snap && 0.1, pos)),\n                        })\n                        return Object.assign({}, diagram, {lines: lines})\n                    }))\n                    e.stopPropagation()\n                } else if (e.buttons == 2 && e.ctrlKey) {\n                    update(modifyDiagram({superficial: true}, diagram => {\n                        let lines = Object.assign({}, diagram.lines)\n                        lines[lineId] = Object.assign({}, lines[lineId], {\n                            arrowPos: 0.5,\n                        })\n                        return Object.assign({}, diagram, {lines: lines})\n                    }))\n                    e.stopPropagation()\n                }\n            },\n        },\n        vnode(\"svg:circle\", {\n            \"class\": \"hit\",\n            r: 15,\n            cx: rawPosition.x,\n            cy: rawPosition.y,\n        }),\n        direction ? vnode(\"svg:use\", {\n            \"class\": \"arrowhead\",\n            href: \"#arrowhead\",\n            x: -arrowHeadSize,\n            y: -arrowHeadSize / 2,\n            width: arrowHeadSize,\n            height: arrowHeadSize,\n            transform: `translate(${position.x}, ${position.y}) `\n                     + `rotate(${angle * 180 / Math.PI})`,\n        }) : vnode(\"svg:circle\", {\n            \"class\": \"arrowhead\",\n            cx: position.x,\n            cy: position.y,\n            r: arrowHeadSize / 2,\n        }),\n    )]\n}\n\nfunction renderLine(update, editor, lineId, ambient) {\n    const diagram = editor.snapshot.diagram\n    const line = diagram.lines[lineId]\n    const superline = diagram.superlines[line.superline]\n    const minTextOffset = 20\n    const info = getLineInfo(diagram, lineId)\n    const position = positionOnLine(info, line.textPos, 0)\n    let textOffset = line.textOffset\n    if (textOffset == 0) {\n        textOffset = minTextOffset * info.halfDisk\n    } else if (textOffset > 0 && textOffset < minTextOffset) {\n        textOffset = minTextOffset\n    } else if (textOffset < 0 && textOffset > -minTextOffset) {\n        textOffset = -minTextOffset\n    }\n    let d = `M ${info.x0} ${info.y0} `\n    if (info.arc.radius == Infinity) {\n        // don't make Inkscape sad\n        d += `L `\n    } else {\n        const radius = Math.abs(info.arc.radius)\n        d += `A ${radius} ${radius} 0 `\n           + `${Number(info.arc.large)} ${Number(info.arc.sweep)} `\n    }\n    d += `${info.x1} ${info.y1}`\n    const textX = position.x + textOffset * position.normalX\n    const textY = position.y + textOffset * position.normalY\n    function onmousedown(e) {\n        const [x, y] = toSvgCoords([e.clientX, e.clientY])\n        if (e.buttons == 1) {\n            update(startDrag(x, y, {\n                superficial: true,\n            }, (diagram, x, y, snap) => {\n                let change\n                if (info.singular) {\n                    const dx = x - info.xMid\n                    const dy = y - info.yMid\n                    const angle = Math.atan2(dy, dx) - Math.PI / 2\n                    const height = Math.sqrt(dx * dx + dy * dy)\n                    change = {\n                        angle: round(snap && Math.PI / 6, angle),\n                        arcHeight: clamp(20.0, Infinity,\n                                         round(snap && 20.0, height)),\n                    }\n                } else {\n                    change = {\n                        angle: info.trueAngle,\n                        arcHeight: round(snap && 20.0,\n                                         threePointArc(x, y,\n                                                       info.x0, info.y0,\n                                                       info.x1, info.y1)),\n                    }\n                }\n                return setDiagramLineProps(diagram, lineId, change)\n            }))\n            e.stopPropagation()\n        } else if (e.buttons == 2 && e.ctrlKey == true) {\n            update(modifyDiagram({superficial: true}, diagram =>\n                info.singular ? diagram : setDiagramLineProps(diagram, lineId, {\n                    angle: info.angle,\n                    arcHeight: 0.0,\n                })\n            ))\n            e.stopPropagation()\n        }\n    }\n    return vnode(\n        \"svg:g\",\n        {\n            // prevent hover effects from sticking when nodes change\n            [VNODE_KEY]: lineId,\n            \"class\": \"line \"\n                   + (line.superline == \"0\" ? \"zero \" : \"\")\n                   + (superline.summed ? \"summed \" : \"\")\n                   + (superline.phase % 2 ? \"one-j \" : \"\")\n                   + (mod(superline.phase, 4) >= 2 ? \"two-j \" : \"\")\n                   + ((editor.trackStart.type == \"line\" &&\n                       editor.trackStart.lineId == lineId)\n                   || (editor.trackStop.type == \"line\" &&\n                       editor.trackStop.lineId == lineId)\n                    ? (editor.trackType + \" \") : \"\"),\n            onmouseenter: function(e) {\n                update(setHover({\n                    type: \"line\",\n                    lineId: lineId,\n                }))\n            },\n            onmouseleave: function(e) {\n                update(setHover({type: null}))\n            },\n        },\n        vnode(\"svg:title\", {}, `j[${line.superline}] m[${lineId}]`),\n        // this path (1) increases hit area (2) helps delineate crossing lines\n        vnode(\"svg:path\", {\n            \"class\": \"bg\",\n            d: d,\n            onmousedown: onmousedown,\n        }),\n        vnode(\"svg:path\", {\n            \"class\": \"fg\",\n            d: d,\n            onmousedown: onmousedown,\n        }),\n        vnode(\"svg:path\", {\n            \"class\": \"pith\",\n            d: d,\n            onmousedown: onmousedown,\n        }),\n        vnode(\"svg:path\", {\n            \"class\": \"hit\",\n            d: d,\n            onmousedown: onmousedown,\n        }),\n        vnode(\"svg:text\", {\n            \"class\": \"label\",\n            x: textX,\n            y: textY,\n            onmousedown: function(e) {\n                if (e.buttons == 1) {\n                    update(startDrag(textX, textY, {\n                        superficial: true,\n                    }, (diagram, x, y, snap) => {\n                        const where = findPosOnLine(info, x, y)\n                        // prevent text from getting stuck under nodes\n                        return setDiagramLineProps(diagram, lineId, {\n                            textPos: clamp(0.1, 0.9,\n                                           round(snap && 0.1, where.pos)),\n                            textOffset: round(snap && 10.0, where.offset),\n                        })\n                    }))\n                    e.stopPropagation()\n                } else if (e.buttons == 2 && e.ctrlKey == true) {\n                    update(modifyDiagram({superficial: true}, diagram =>\n                        setDiagramLineProps(diagram, lineId, {\n                            textPos: 0.5,\n                            textOffset: 0.0,\n                        })\n                    ))\n                    e.stopPropagation()\n                }\n            },\n        }, line.superline),\n        ...renderArrow(update, diagram, lineId, ambient),\n    )\n}\n\nfunction renderNode(update, editor, nodeIndex, frozen) {\n    const diagram = editor.snapshot.diagram\n    const node = diagram.nodes[nodeIndex]\n    let gChildren = [vnode(\"svg:title\", {},\n                           node.type == \"w3j\"\n                         ? `{${node.lines.join(\" \")}} #${nodeIndex}`\n                         : node.type == \"terminal\"\n                         ? `m[${node.variable}] #${nodeIndex}`\n                         : node.type)]\n\n    if (node.type == \"w3j\") {\n        const circularArrowSize = 30\n        const orientation = w3jOrientation(diagram, nodeIndex) > 0\n                          ? \"flipped \" : \"\"\n        gChildren.push(vnode(\"svg:circle\", {\n            \"class\": \"bg \" + orientation,\n            r: 20,\n        }))\n        gChildren.push(vnode(\"svg:circle\", {\n            \"class\": \"fg \" + orientation,\n            r: 18,\n        }))\n        gChildren.push(vnode(\"svg:circle\", {\n            \"class\": \"hit \" + orientation,\n            r: 25,\n        }))\n        gChildren.push(vnode(\"svg:use\", {\n            \"class\": \"arrow \" + orientation,\n            href: \"#clockwise\",\n            x: -circularArrowSize / 2,\n            y: -circularArrowSize / 2,\n            width: circularArrowSize,\n            height: circularArrowSize,\n        }))\n\n    } else if (node.type == \"terminal\") {\n        const frozenClass = frozen ? \"frozen \" : \"\"\n        gChildren.push(vnode(\"svg:circle\", {\n            \"class\": \"fg \" + frozenClass,\n            r: 8,\n        }))\n        gChildren.push(vnode(\"svg:circle\", {\n            \"class\": \"hit\",\n            r: 15,\n        }))\n\n    } else {\n        gChildren.push(vnode(\"svg:circle\", {\n            \"class\": \"fg\",\n            r: 20,\n        }))\n        gChildren.push(vnode(\"svg:circle\", {\n            \"class\": \"hit\",\n            r: 25,\n        }))\n        gChildren.push(vnode(\"svg:text\", {\n            \"class\": \"label\",\n        }))\n    }\n\n    return vnode(\"svg:g\", {\n        // prevent hover effects from sticking when nodes change\n        [VNODE_KEY]: objectId(node),\n        \"class\": \"node \"\n               + node.type + \" \"\n               + ((editor.trackStart.type == \"node\" &&\n                   editor.trackStart.nodeIndex == nodeIndex)\n               || (editor.trackStop.type == \"node\" &&\n                   editor.trackStop.nodeIndex == nodeIndex)\n                ? (editor.trackType + \" \") : \"\"),\n        transform: `translate(${node.x}, ${node.y})`,\n        onmouseenter: function(e) {\n            update(setHover({\n                type: \"node\",\n                nodeIndex: nodeIndex,\n            }))\n        },\n        onmouseleave: function(e) {\n            update(setHover({type: null}))\n        },\n        onmousedown: function(e) {\n            if (e.buttons == 1) {\n                update(startDrag(node.x, node.y, {\n                    // moving terminals and/or custom nodes\n                    // changes the semantics of the diagram\n                    superficial: node.type == \"w3j\",\n                }, (diagram, x, y, snap) =>\n                    setDiagramNodeProps(diagram, nodeIndex, {\n                        x: round(snap && 20.0, x),\n                        y: round(snap && 20.0, y),\n                    })\n                ))\n                e.stopPropagation()\n            } else if (e.buttons == 4) {\n                if (node.type == \"terminal\") {\n                    return\n                }\n                if (e.shiftKey) { // do it twice!\n                    update(modifyDiagram({equivalent: true}, diagram =>\n                        flipW3jRule(\n                            flipW3jRule(diagram, nodeIndex),\n                            nodeIndex)))\n                } else {\n                    update(modifyDiagram({equivalent: true}, diagram =>\n                        flipW3jRule(diagram, nodeIndex)))\n                }\n                e.stopPropagation()\n            } else if (e.buttons == 2) {\n                if (node.type == \"terminal\") {\n                    return\n                }\n                update(modifyDiagram({equivalent: true}, diagram =>\n                    threeArrowRule(diagram, nodeIndex)))\n                e.stopPropagation()\n            }\n        },\n    }, ...gChildren)\n}\n\nfunction cmpSuperlineId(x, y) {\n    if (x == \"0\") {\n        if (y == \"0\") {\n            return 0\n        }\n        return -1\n    }\n    if (y == \"0\") {\n        return +1\n    }\n    let d = x.length - y.length\n    if (d == 0) {\n        d = Number(x > y) - Number(x < y)\n    }\n    return d\n}\n\nconst GREEK_LATEX = {\n    \"\": \"A\",\n    \"\": \"\\\\alpha\",\n    \"\": \"B\",\n    \"\": \"\\\\beta\",\n    \"\": \"\\\\Gamma\",\n    \"\": \"\\\\gamma\",\n    \"\": \"\\\\Delta\",\n    \"\": \"\\\\delta\",\n    \"\": \"E\",\n    \"\": \"\\\\varepsilon\",\n    \"\": \"\\\\epsilon\",\n    \"\": \"Z\",\n    \"\": \"\\\\zeta\",\n    \"\": \"H\",\n    \"\": \"\\\\eta\",\n    \"\": \"\\\\Theta\",\n    \"\": \"\\\\theta\",\n    \"\": \"\\\\vartheta\",\n    \"\": \"I\",\n    \"\": \"\\\\iota\",\n    \"\": \"K\",\n    \"\": \"\\\\kappa\",\n    \"\": \"\\\\varkappa\",\n    \"\": \"\\\\Lambda\",\n    \"\": \"\\\\lambda\",\n    \"\": \"M\",\n    \"\": \"\\\\mu\",\n    \"\": \"N\",\n    \"\": \"\\\\nu\",\n    \"\": \"\\\\Xi\",\n    \"\": \"\\\\xi\",\n    \"\": \"O\",\n    \"\": \"o\",\n    \"\": \"\\\\Pi\",\n    \"\": \"\\\\pi\",\n    \"\": \"\\\\varpi\",\n    \"\": \"P\",\n    \"\": \"\\\\rho\",\n    \"\": \"\\\\varrho\",\n    \"\": \"\\\\Sigma\",\n    \"\": \"\\\\sigma\",\n    \"\": \"\\\\varsigma\",\n    \"\": \"T\",\n    \"\": \"\\\\tau\",\n    \"\": \"Y\",\n    \"\": \"\\\\Upsilon\",\n    \"\": \"\\\\upsilon\",\n    \"\": \"\\\\Phi\",\n    \"\": \"\\\\varphi\",\n    \"\": \"\\\\phi\",\n    \"\": \"X\",\n    \"\": \"\\\\chi\",\n    \"\": \"\\\\Psi\",\n    \"\": \"\\\\psi\",\n    \"\": \"\\\\Omega\",\n    \"\": \"\\\\omega\",\n}\nconst GREEK_LETTERS = \"\"\nconst IDENT_CHAR_REGEX = `['_.,\\\\w${GREEK_LETTERS}]`\n\nfunction isValidSuperlineId(superlineId) {\n    // prevent exotic characters from messing up the delta input syntax\n    return !!new RegExp(`^${IDENT_CHAR_REGEX}+$`).exec(superlineId)\n}\n\nfunction isLoopLine(line) {\n    return line.node(0).type == \"w3j\"\n        && line.node(0).index == line.node(1).index\n        && (line.superlineId == \"0\" || line.direction % 2)\n}\n\nfunction editSummed(diagram, superlineId) {\n    if (superlineId == \"0\") {\n        return \"\"\n    }\n    if (isSuperlineExposed(diagram, superlineId)) {\n        return \"\"\n    }\n    const superline = diagram.superlines[superlineId]\n    // special case: eliminate summations through deltas\n    if (superline.summed) {\n        const deltas = diagram.deltas\n        const found = findDeltaEntry(deltas, superlineId)\n        if (found) {\n            const deltas = diagram.deltas\n            const newSuperlineId = deltas[found[0]][(found[1] + 1) %\n                deltas[found[0]].length]\n            const summed = diagram.superlines[superlineId].summed\n                        && diagram.superlines[newSuperlineId].summed\n            diagram = new Diagram(diagram).renameSuperlines({\n                    [superlineId]: newSuperlineId,\n                }).rawDiagram\n            diagram = Object.assign({}, diagram)\n            diagram.superlines = Object.assign({}, diagram.superlines)\n            diagram.superlines[newSuperlineId] = Object.assign(\n                {}, diagram.superlines[newSuperlineId], {summed: summed})\n            return {\n                equivalent: true,\n                diagram: diagram,\n            }\n        }\n    }\n    diagram = deepClone(diagram)\n    diagram.superlines[superlineId].summed =\n        !superline.summed\n    return {\n        equivalent: false,\n        diagram: diagram\n    }\n}\n\nfunction introSum(diagram, superlineId) {\n    // introduce sum[j_fresh] delta[j_fresh j]\n    const freshSuperlineId = availSuperlineLabels(diagram).next().value\n    diagram = deepClone(diagram)\n    diagram.superlines[freshSuperlineId] = Object.assign({}, EMPTY_SUPERLINE, {\n        summed: true,\n    })\n    diagram.deltas = mergeDeltas(diagram.deltas, [\n        [superlineId, freshSuperlineId],\n    ])\n    return {\n        equivalent: true,\n        diagram: diagram,\n    }\n}\n\nfunction renderJTableau(update, superlines, editor) {\n    const frozen = editor.snapshot.frozen\n    const focus = editor.focus\n    return Array.from(new Set(\n        Object.keys(superlines).concat(\"0\")\n    )).sort(cmpSuperlineId).map(superlineId => {\n        const focusedName = focus.type == \"tableauJName\"\n                         && focus.superlineId == superlineId\n        const superline = superlineId == \"0\"\n                        ? EMPTY_SUPERLINE\n                        : superlines[superlineId]\n        const twoJ = vnode(\"span\", {\"class\": \"two-j\"}, \"\\u2022\\u2022\")\n        let phase\n        switch (mod(superline.phase, 4)) {\n            case 0:\n                phase = [\"\\xa0\\xa0\\xa0\"]\n                break\n            case 1:\n                phase = [\"\\u2022\\xa0\\xa0\"]\n                break\n            case 2:\n                phase = [twoJ, \"\\xa0\"]\n                break\n            case 3:\n                phase = [twoJ, \"\\u2022\"]\n                break\n        }\n        let weight = superline.weight\n                   ? (superline.weight > 0\n                    ? \"+\"\n                    : superline.weight < 0\n                    ? \"\\u2212\"\n                    : \"\")\n                   + Math.abs(superline.weight)\n                   : \"\"\n        return vnode(\n            \"tr\", {},\n            vnode(\"td\", {\n                \"class\": \"summed\",\n                onmousedown: function(e) {\n                    if (e.buttons == 1) {\n                        update(modifyDiagramWith(diagram =>\n                            editSummed(diagram, superlineId)))\n                        e.stopPropagation()\n                    } else if (e.buttons == 4) {\n                        update(modifyDiagramWith(diagram =>\n                            introSum(diagram, superlineId)))\n                        e.stopPropagation()\n                    }\n                },\n            }, superline.summed ? \"\\u2211\" : \"\"),\n            vnode(\"td\", {\n                \"class\": \"name\",\n                contenteditable: superlineId != \"0\",\n                spellcheck: \"false\",\n                [VNODE_SUSPEND_CHILDREN]: focusedName,\n                onfocus: function(e) {\n                    update(setFocus({\n                        type: \"tableauJName\",\n                        superlineId: superlineId,\n                    }))\n                },\n                onblur: function(e) {\n                    let newSuperlineId = this.textContent\n                    newSuperlineId = newSuperlineId.trim()\n                    if (!newSuperlineId) {\n                        newSuperlineId = \"0\"\n                    }\n                    update(editor => {\n                        modifyDiagramWith(diagram => {\n                            diagram = new Diagram(diagram)\n                            if (superlineId == newSuperlineId\n                                || !isValidSuperlineId(newSuperlineId)) {\n                                return \"\"\n                            }\n                            const superline = diagram.superline(superlineId)\n                            const deltas = diagram.rawDiagram.deltas\n                            // special case for loop lines, which can\n                            // change into anything\n                            if (frozen\n                                && superline.phase == 0\n                                && !superline.summed\n                                && !findDeltaEntry(deltas, superlineId)) {\n                                let numLoops = 0\n                                for (const line of diagram.lines()) {\n                                    if (line.superlineId == superlineId) {\n                                        if (isLoopLine(line)) {\n                                            numLoops += 1\n                                        } else {\n                                            numLoops = null\n                                            break\n                                        }\n                                    }\n                                }\n                                if (numLoops != null\n                                    && superline.weight == -numLoops) {\n                                    return {\n                                        equivalent: true,\n                                        diagram: diagram.renameSuperlines({\n                                            [superlineId]: newSuperlineId,\n                                        }).rawDiagram,\n                                    }\n                                }\n                            }\n                            return {\n                                equivalent: superline.summed\n                                         && !diagram.superline(newSuperlineId),\n                                diagram: diagram.renameSuperlines({\n                                    [superlineId]: newSuperlineId,\n                                }).rawDiagram,\n                            }\n                        })(editor)\n                        clearFocus(editor)\n                    })\n                },\n            }, superlineId == \"0\"\n                ? vnode(\"span\", {\"class\": \"zero\"}, \"0\")\n                : superlineId),\n            vnode(\"td\", Object.assign({\n                \"class\": \"phase \"\n                       + (editor.drag.type == \"phase\"\n                       && editor.drag.superlineId == superlineId ? \"drag \" : \"\")\n                       + (editor.drop.type == \"phase\"\n                       && editor.drop.superlineId == superlineId ? \"drop \" : \"\"),\n                oncontextmenu: function(e) { e.preventDefault() },\n                onmousedown: function(e) {\n                    if (e.buttons == 2) {\n                        update(modifyDiagram({}, diagram => {\n                            return Object.assign({}, diagram, {\n                                superlines: mergeSuperlineLists(\n                                    diagram.superlines,\n                                    {[superlineId]: {phase: +1}}),\n                            })\n                        }))\n                        e.stopPropagation()\n                        e.preventDefault()\n                    } else if (e.buttons == 4) {\n                        update(modifyDiagram({}, diagram => {\n                            return Object.assign({}, diagram, {\n                                superlines: mergeSuperlineLists(\n                                    diagram.superlines,\n                                    {[superlineId]: {phase: -1}}),\n                            })\n                        }))\n                        e.stopPropagation()\n                        e.preventDefault()\n                    }\n                },\n            }, handleDrag(update, (editor, e) => ({\n                type: \"phase\",\n                superlineId: superlineId,\n            })), handleDrop(update, (editor, e) => {\n                if (editor.drag.type != \"phase\"\n                    || editor.drag.superlineId == superlineId\n                    || (editor.snapshot.frozen &&\n                        !containsDeltas(editor.snapshot.diagram.deltas,\n                                        [[editor.drag.superlineId,\n                                          superlineId]]))) {\n                    return null\n                }\n                return {\n                    type: \"phase\",\n                    superlineId: superlineId,\n                }\n            }, (editor, e) => {\n                modifyDiagramWith(diagram => {\n                    const equivalent = containsDeltas(diagram.deltas,\n                                                      [[editor.drag.superlineId,\n                                                        superlineId]])\n                    diagram = Object.assign({}, diagram, {\n                        superlines: mergeSuperlineLists(\n                            diagram.superlines,\n                            {\n                                [editor.drag.superlineId]: {phase: -1},\n                                [superlineId]: {phase: +1},\n                            }\n                        )\n                    })\n                    return {equivalent: equivalent, diagram: diagram}\n                })(editor)\n            })), ...phase),\n            vnode(\"td\", Object.assign({\n                \"class\": \"weight \"\n                       + (editor.drag.type == \"weight\"\n                       && editor.drag.superlineId == superlineId ? \"drag \" : \"\")\n                       + (editor.drop.type == \"weight\"\n                       && editor.drop.superlineId == superlineId ? \"drop \" : \"\"),\n                oncontextmenu: function(e) { e.preventDefault() },\n                onmousedown: function(e) {\n                    if (e.buttons == 2) {\n                        update(modifyDiagram({}, diagram => {\n                            return Object.assign({}, diagram, {\n                                superlines: mergeSuperlineLists(\n                                    diagram.superlines,\n                                    {[superlineId]: {weight: +1}}),\n                            })\n                        }))\n                        e.stopPropagation()\n                        e.preventDefault()\n                    } else if (e.buttons == 4) {\n                        update(modifyDiagram({}, diagram => {\n                            return Object.assign({}, diagram, {\n                                superlines: mergeSuperlineLists(\n                                    diagram.superlines,\n                                    {[superlineId]: {weight: -1}}),\n                            })\n                        }))\n                        e.stopPropagation()\n                        e.preventDefault()\n                    }\n                },\n            }, handleDrag(update, (editor, e) => ({\n                type: \"weight\",\n                superlineId: superlineId,\n            })), handleDrop(update, (editor, e) => {\n                if (editor.drag.type != \"weight\"\n                    || editor.drag.superlineId == superlineId\n                    || (editor.snapshot.frozen &&\n                        !containsDeltas(editor.snapshot.diagram.deltas,\n                                        [[editor.drag.superlineId,\n                                          superlineId]]))) {\n                    return null\n                }\n                return {\n                    type: \"weight\",\n                    superlineId: superlineId,\n                }\n            }, (editor, e) => {\n                modifyDiagramWith(diagram => {\n                    const equivalent = containsDeltas(diagram.deltas,\n                                                      [[editor.drag.superlineId,\n                                                        superlineId]])\n                    diagram = Object.assign({}, diagram, {\n                        superlines: mergeSuperlineLists(\n                            diagram.superlines,\n                            {\n                                [editor.drag.superlineId]: {weight: -1},\n                                [superlineId]: {weight: +1},\n                            }\n                        )\n                    })\n                    return {equivalent: equivalent, diagram: diagram}\n                })(editor)\n            })), weight),\n        )\n    })\n}\n\nfunction editDelta(deltaIndex, input) {\n    return diagram => {\n        const oldDeltas = diagram.deltas\n        let invalid = null\n        diagram = Object.assign({}, diagram)\n        diagram.deltas = oldDeltas.slice()\n        diagram.deltas.splice(\n            deltaIndex, 1,\n            ...input.split(/[;\\n]/).map(delta =>\n                delta.split(\"=\").map(s => {\n                    s = s.trim()\n                    if (s && !isValidSuperlineId(s)) {\n                        invalid = s\n                    }\n                    return s\n                }).filter(identity)))\n        if (invalid != null) {\n            return \"invalid label: \" + invalid\n        }\n        diagram.deltas = mergeDeltas(diagram.deltas)\n        diagram.superlines = Object.assign({}, diagram.superlines)\n        for (const delta of diagram.deltas) {\n            for (const j of delta) {\n                if (!diagram.superlines[j]) {\n                    diagram.superlines[j] = EMPTY_SUPERLINE\n                }\n            }\n        }\n        const inferredDeltas = inferDeltas(diagram)\n        const oldInferredDeltas = mergeDeltas(inferredDeltas, oldDeltas)\n        const newInferredDeltas = mergeDeltas(inferredDeltas, diagram.deltas)\n        let equivalent = equalDeltas(oldInferredDeltas, newInferredDeltas)\n        diagram = new Diagram(diagram)\n        if (!equivalent) {\n            // inferDeltas doesn't infer zero lines due to bridges between\n            // orientable subdiagrams for efficiency reasons; instead we look\n            // for the remaining j's in the zero delta and try to infer those\n            const oldZeroDelta = new Set(relatedDelta(oldInferredDeltas, \"0\"))\n            const newZeroDelta = new Set(relatedDelta(newInferredDeltas, \"0\"))\n            let diff = new Set([...oldZeroDelta, ...newZeroDelta]\n                .filter(x => !oldZeroDelta.has(x) || !newZeroDelta.has(x)))\n            const diffDelta = [\"0\", ...diff]\n            if (equalDeltas(mergeDeltas([diffDelta], oldInferredDeltas),\n                            mergeDeltas([diffDelta], newInferredDeltas))) {\n                for (const line of diagram.lines()) {\n                    if (diff.has(line.superlineId) && !line.testCuttability()) {\n                        diff.delete(line.superlineId)\n                    }\n                }\n                equivalent = diff.size == 0\n            }\n        }\n        return {\n            equivalent,\n            diagram: diagram.removeUnusedSuperlines().rawDiagram,\n        }\n    }\n}\n\nfunction renderDeltaJ(j) {\n    return j == \"0\"\n         ? vnode(\"span\", {\"class\": \"zero\"}, \"0\")\n         : String(j)\n}\n\nfunction renderDeltaTableau(update, deltas, focus, frozen) {\n    return vnode(\"ul\", {}, ...deltas.concat([null]).map((delta, deltaIndex) => {\n        const focused = focus.type == \"delta\"\n                     && focus.deltaIndex == deltaIndex\n        const children = delta == null\n                       ? [vnode(\"i\", {}, \"(create \\u03b4)\")]\n                       : arrayIntercalate(\" = \", Array.from(delta)\n                                                      .map(renderDeltaJ))\n        return vnode(\"li\", {\n            \"class\": delta == null ? \"tip \" : \"\",\n            contenteditable: \"true\",\n            spellcheck: \"false\",\n            [VNODE_SUSPEND_CHILDREN]: focused,\n            onmousedown: function(e) {\n                if (e.buttons == 4) {\n                    update(modifyDiagramWith(editDelta(deltaIndex, \"\")))\n                    e.preventDefault()\n                }\n            },\n            onfocus: function(e) {\n                if (delta == null) {\n                    this.textContent = \"\"\n                    // clearing the text somehow deselects the text\n                    // so this is a workaround\n                    let range = document.createRange()\n                    range.selectNodeContents(this)\n                    let sel = window.getSelection()\n                    sel.removeAllRanges()\n                    sel.addRange(range)\n                }\n                update(setFocus({type: \"delta\", deltaIndex: deltaIndex}))\n            },\n            onblur: function(e) {\n                const input = this.textContent\n                update(editor => {\n                    modifyDiagramWith(editDelta(deltaIndex, input))(editor)\n                    clearFocus(editor)\n                })\n            },\n        }, ...children)\n    }))\n}\n\nfunction renderVariable(type, name) {\n    if (type == \"j\" && name == \"0\") {\n        return \"0\"\n    }\n    name = name.replace(\"\", \"'\")\n               .replace(\"_\", \"\\\\_\")\n               .replace(new RegExp(`[${GREEK_LETTERS}]`),\n                        x => GREEK_LATEX[x] + \" \")\n    return `${type}_{${name}}`\n}\n\nfunction renderEquationLine(diagram, nodeIndex, lineIndex, summedVars) {\n    const lineId = diagram.nodes[nodeIndex].lines[lineIndex]\n    const line = diagram.lines[lineId]\n    const otherIndex = otherNodeIndex(diagram.nodes, nodeIndex, lineIndex)\n    const otherNode = diagram.nodes[otherIndex]\n    // avoid redundant summation over an m-delta\n    const mName = otherNode.type == \"terminal\"\n                ? otherNode.variable\n                : lineId\n    const mNaked = renderVariable(\"m\", mName)\n    const jm = {\n        j: renderVariable(\"j\", diagram.lines[lineId].superline),\n        m: otherIndex < nodeIndex && line.direction != 0\n         ? `-${mNaked}`\n         : mNaked,\n    }\n    if (line.superline.summed) {\n        summedVars.js[jm.j] = true\n    }\n    if (otherNode.type != \"terminal\") {\n        summedVars.ms[mNaked] = true\n    }\n    return jm\n}\n\nfunction renderEquation(diagram, container) {\n    const nodes = diagram.nodes\n    let s = \"\"\n    let summedVars = {js: {}, ms: {}}\n    let phases = []\n    let mDeltas = []\n    nodes.forEach(function(node, nodeIndex) {\n        if (node.type == \"terminal\") {\n            const otherIndex = otherNodeIndex(nodes, nodeIndex, 0)\n            if (otherIndex > nodeIndex) {\n                return\n            }\n            const var1 = nodes[otherIndex].variable\n            const var2 = node.variable\n            if (var1 == var2) {\n                return\n            }\n            const m1 = renderVariable(\"m\", var1)\n            const m2 = renderVariable(\"m\", var2)\n            switch (diagram.lines[node.lines[0]].direction) {\n                case 0:\n                    mDeltas.push(`\\\\delta_{${m1}, ${m2}}`)\n                    break\n                case -1:\n                    mDeltas.push(`\\\\delta_{${m1}, -${m2}}`)\n                    break\n                case 1:\n                    mDeltas.push(`\\\\delta_{-${m1}, ${m2}}`)\n                    break\n                default:\n                    throw new Error(`unnormalized direction: ${direction}`)\n            }\n        } else if (node.type == \"w3j\") {\n            s += \"\\\\begin{pmatrix}\"\n            let jRow = \"\"\n            let mRow = \"\"\n            node.lines.forEach(function(lineId, lineIndex) {\n                if (lineIndex > 0) {\n                    jRow += \" & \"\n                    mRow += \" & \"\n                }\n                const jm = renderEquationLine(diagram, nodeIndex,\n                                              lineIndex, summedVars)\n                jRow += jm.j\n                mRow += jm.m\n            })\n            s += jRow + \" \\\\\\\\\"\n            s += mRow + \" \\\\\\\\\"\n            s += \"\\\\end{pmatrix}\"\n        } else {\n            s += \"\\\\mathtt{${node.type}}_{\"\n            node.lines.forEach(function(lineId, lineIndex) {\n                if (lineIndex > 0) {\n                    s += \" \"\n                }\n                const jm = renderEquationLine(diagram, nodeIndex,\n                                              lineId, summedVars)\n                s += jm[0] + \" \" + jm[1]\n            })\n            s += \"}\"\n        }\n    })\n    let weights = \"\"\n    Object.keys(diagram.superlines).forEach(function(superlineId) {\n        const superline = diagram.superlines[superlineId]\n        const jVar = renderVariable(\"j\", superlineId)\n        switch (mod(superline.phase, 4)) {\n            case 0:\n                break\n            case 1:\n                phases.push(`+ ${jVar}`)\n                break\n            case 2:\n                phases.push(`+ 2 ${jVar}`)\n                break\n            case 3:\n                phases.push(`- ${jVar}`)\n                break\n        }\n        if (superline.weight == 0) {\n        } else if (superline.weight == 2) {\n            weights += ` (2 ${jVar} + 1)`\n        } else if (superline.weight % 2 == 0) {\n            weights += ` (2 ${jVar} + 1)^{${superline.weight / 2}}`\n        } else {\n            weights += ` (2 ${jVar} + 1)^{${superline.weight} / 2}`\n        }\n    })\n    Object.keys(diagram.lines).forEach(function(lineId) {\n        const line = diagram.lines[lineId]\n        let name\n        switch (line.direction) {\n            case 0:\n                return\n            case -1:\n                const node2 = nodes[endNodeIndices(nodes, lineId)[1]]\n                if (node2.type == \"terminal\") {\n                    name = node2.variable\n                } else {\n                    name = lineId\n                }\n                break\n            case 1:\n                const node1 = nodes[endNodeIndices(nodes, lineId)[0]]\n                if (node1.type == \"terminal\") {\n                    name = node1.variable\n                } else {\n                    name = lineId\n                }\n                break\n            default:\n                throw new Error(`unnormalized direction: ${direction}`)\n        }\n        const j = renderVariable(\"j\", diagram.lines[lineId].superline)\n        const m = renderVariable(\"m\", name)\n        phases.push(`+ ${j} ${line.direction < 0 ? \"+\" : \"-\"} ${m}`)\n    })\n    let summedVarsStr =\n        Object.keys(summedVars.js)\n              .concat(Object.keys(summedVars.ms)).join(\", \")\n    if (summedVarsStr) {\n        summedVarsStr = `\\\\sum_{${summedVarsStr}}`\n    }\n    let phasesStr = phases.join(\" \")\n    if (phasesStr) {\n        if (phasesStr.startsWith(\"+ \")) {\n            phasesStr = phasesStr.substr(2)\n        }\n        phasesStr = `(-1)^{${phasesStr}}`\n    }\n    const mDeltasStr = mDeltas.join(\" \")\n    const jDeltas = diagram.deltas.map(js => {\n        if (js.length < 2) {\n            return \"\"\n        }\n        const j0 = renderVariable(\"j\", js[0])\n        return js.slice(1)\n                 .map(j => `\\\\delta_{${j0} ${renderVariable(\"j\", j)}}`)\n                 .join(\" \")\n    }).join(\" \")\n    container.textContent = `\\\\[${summedVarsStr} ${jDeltas} ${mDeltasStr} `\n                          + `${weights} ${phasesStr} ${s}\\\\]`\n    MathJax.Hub.Queue([\"Typeset\", MathJax.Hub])\n}\n\nfunction renderTrack(trackType, start, stop) {\n    return [\n        vnode(\"svg:circle\", {\n            \"class\": trackType,\n            cx: start[0],\n            cy: start[1],\n            r: 8,\n        }),\n        vnode(\"svg:path\", {\n            \"class\": trackType,\n            d: `M ${start[0]} ${start[1]} `\n             + `L ${stop[0]} ${stop[1]} `,\n        }),\n        vnode(\"svg:circle\", {\n            \"class\": trackType,\n            cx: stop[0],\n            cy: stop[1],\n            r: 8,\n        }),\n    ]\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// State management\n//\n// The \"update\" function is responsible for making changes to the model (and\n// updating the DOM as needed).  It has type (&mut Editor -> ()) -> ().\n// In the future, \"update\" may ask for a Promise instead.\n\nconst ALT = 0x1\nconst CTRL = 0x2\nconst SHIFT = 0x4\n\nconst EMPTY_SNAPSHOT = {\n    diagram: EMPTY_DIAGRAM,\n    frozen: false,\n    showAmbient: true,\n}\n\nfunction newEditor() {\n    return {\n        snapshot: EMPTY_SNAPSHOT,\n        savedSnapshot: EMPTY_SNAPSHOT,\n        savedHash: \"\",\n        staleEquation: true,\n\n        // controls\n        error: \"\",\n        notice: \"An editor for angular momentum diagrams\",\n        hover: {type: null},\n        focus: {type: null},\n        drag: {type: null},\n        drop: {type: null},\n        mouseX: null,\n        mouseY: null,\n        trackType: null,\n        trackStart: {type: null, xy: null},\n        trackStop: {type: null, xy: null},\n    }\n}\n\nfunction saveEditor(editor) {\n    editor.savedSnapshot = editor.snapshot\n    editor.savedHash = \"#\" + encodeURIComponent(JSON.stringify(editor.snapshot))\n    window.location.hash = editor.savedHash\n}\n\nfunction loadEditor(editor) {\n    const hash = window.location.hash\n    // prevent hashchange listener from observing our own changes\n    if (hash.length < 3) {\n        Object.assign(editor, newEditor())\n    } else if (editor.savedHash != hash) {\n        editor.snapshot = JSON.parse(decodeURIComponent(hash.substr(1)))\n        editor.staleEquation = true\n        editor.savedSnapshot = editor.snapshot\n        editor.savedHash = hash\n    }\n}\n\nfunction toSvgCoords(p) {\n    if (!p) {\n        return p\n    }\n    const rect = document.getElementById(\"diagram\").getBoundingClientRect()\n    return [p[0] - rect.left, p[1] - rect.top]\n}\n\nfunction renderEditor(update, editor) {\n    const diagram = editor.snapshot.diagram\n    let ambient = null\n    if (editor.snapshot.showAmbient) {\n        // first try to match external lines (not needed, but looks nicer)\n        ambient = getAmbientDirections(new Diagram(diagram), false)\n        if (!ambient.orientable) {\n            // if it's not orientable, it might be because the external-line\n            // constraints aren't satisfiable\n            ambient = getAmbientDirections(new Diagram(diagram), true)\n        }\n    }\n    return [\n        {\n            element: window,\n            attributes: {\n                onhashchange: _ => update(loadEditor),\n                onkeydown: e => update(keyDown.bind(null, e)),\n                onmousemove: e => update(mouseMove(e)),\n                onmouseup: e => update(mouseUp(e)),\n            },\n        },\n        {\n            element: document.getElementsByTagName(\"body\")[0],\n            attributes: {\n                \"class\": editor.snapshot.frozen ? \"frozen\" : \"\",\n            },\n        },\n        {\n            element: document.getElementById(\"notice\"),\n            attributes: {\n                \"class\": editor.error ? \"warning\" : \"\",\n            },\n            children: [editor.error || editor.notice],\n        },\n        {\n            element: document.getElementById(\"freeze\"),\n            attributes: {\n                \"class\": editor.snapshot.frozen ? \"active\" : \"\",\n            },\n        },\n        {\n            element: document.getElementById(\"ambient\"),\n            attributes: {\n                \"class\": editor.snapshot.showAmbient ? \"active\" : \"\",\n            },\n        },\n        {\n            element: document.getElementById(\"diagram\"),\n            attributes: {\n                oncontextmenu: function(e) { e.preventDefault() },\n                onmousedown: e => {\n                    if (e.buttons == 4) {\n                        update(startTrack(e, \"track1\"))\n                        e.stopPropagation()\n                    } else if (e.buttons == 2) {\n                        update(startTrack(e, \"track2\"))\n                        e.stopPropagation()\n                    }\n                },\n            },\n        },\n        {\n            element: document.getElementById(\"diagram-lines\"),\n            children: Object.keys(diagram.lines).map(lineId =>\n                renderLine(update, editor, lineId, ambient)),\n        },\n        {\n            element: document.getElementById(\"diagram-nodes\"),\n            children: diagram.nodes.map((_, nodeIndex) =>\n                renderNode(update, editor, nodeIndex, editor.snapshot.frozen)),\n        },\n        {\n            element: document.getElementById(\"diagram-track\"),\n            children: editor.trackStop.xy != null\n                    ? renderTrack(editor.trackType,\n                                  toSvgCoords(editor.trackStart.xy),\n                                  toSvgCoords(editor.trackStop.xy))\n                    : [],\n        },\n        {\n            element: document.getElementById(\"tableau-body\"),\n            children: renderJTableau(update, diagram.superlines, editor),\n        },\n        {\n            // Kronecker delta relations\n            element: document.getElementById(\"delta-tableau\"),\n            children: [renderDeltaTableau(update, diagram.deltas,\n                                          editor.focus, editor.snapshot.frozen)],\n        },\n        {\n            element: document.getElementById(\"equation-container\"),\n            attributes: {\n                \"class\": editor.staleEquation ? \"stale\" : \"\",\n            },\n        },\n        {\n            element: document.getElementById(\"equation\"),\n            attributes: {\n                onclick: e => update(freshenEquation(e.currentTarget)),\n            },\n        },\n    ]\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Actions\n\n/** Supported boolean flags:\n *   transient,\n *   equivalent,\n *   superficial (implies equivalent),\n *   toggleFreeze (implies superficial),\n *   toggleAmbient (implies superficial),\n *   clearHover.\n */\nfunction modifyDiagram(flags, diagramTransform) {\n    return modifyDiagramWith(diagram => Object.assign(flags, {\n        diagram: diagramTransform(diagram),\n    }))\n}\n\n/** Similar to modifyDiagram, but gets the flags from the result of the\n   transformation. */\nfunction modifyDiagramWith(transformer) {\n    return editor => {\n        const result = transformer(editor.snapshot.diagram, editor.snapshot.frozen)\n        if (result == null || (typeof result == \"object\"\n                            && result.diagram == null)) {\n            setError(editor, \"not yet implemented\")\n            return\n        }\n        if (typeof result == \"string\") { // error?\n            setError(editor, result)\n            return\n        }\n        const superficial = result.superficial\n                         || result.toggleFreeze\n                         || result.toggleAmbient\n        const equivalent = result.equivalent\n                        || superficial\n        const diagram = result.diagram\n        if (editor.snapshot.frozen && !equivalent) {\n            // nonequivalent changes are forbidden while frozen\n            return\n        }\n        if (typeof diagram == \"string\") { // error?\n            setError(editor, diagram)\n            return\n        }\n        editor.snapshot = Object.assign({}, editor.snapshot, {\n            diagram: diagram,\n            frozen: Boolean(result.toggleFreeze) != editor.snapshot.frozen,\n            showAmbient: Boolean(result.toggleAmbient) !=\n                editor.snapshot.showAmbient,\n        })\n        if (!result.transient) {\n            saveEditor(editor)\n        }\n        if (result.clearHover) {\n            setHover({type: null})(editor)\n        }\n        editor.staleEquation = !superficial || editor.staleEquation\n    }\n}\n\nfunction getModifiers(event) {\n    return event.altKey | (event.ctrlKey << 1) | (event.shiftKey << 2)\n}\n\nfunction freshenEquation(container) {\n    return editor => {\n        if (editor.staleEquation) {\n            editor.staleEquation = false\n            renderEquation(editor.snapshot.diagram, container)\n        }\n    }\n}\n\nlet errorTimeout = 0\nfunction setError(editor, msg) {\n    editor.error = msg\n    if (errorTimeout) {\n        window.clearTimeout(errorTimeout)\n    }\n    errorTimeout = window.setTimeout(function() {\n        const update = getUpdate(editor)\n        update(editor => editor.error = \"\")\n    }, 10000)\n}\n\nfunction setHover(entity) {\n    return editor => {\n        editor.hover = entity\n    }\n}\n\nfunction setFocus(entity) {\n    return editor => {\n        editor.focus = entity\n    }\n}\n\nconst clearFocus = setFocus({type: null})\n\nfunction handleDrag(update, canDrag) {\n    return {\n        [ENABLE_DRAG]: \"true\",\n        draggable: \"true\",\n        ondragstart: function(e) {\n            // Firefox needs this to work\n            e.dataTransfer.setData(\"text/plain\", null)\n            update(editor => {\n                const dragState = canDrag.call(this, editor, e)\n                if (dragState) {\n                    editor.drag = dragState\n                }\n            })\n        },\n        ondragend: function(e) {\n            update(editor => editor.drag = {type: null})\n        },\n    }\n}\n\nfunction handleDrop(update, canDrop, drop) {\n    function dragleave(e) {\n        update(editor => editor.drop = {type: null})\n    }\n    return {\n        ondragenter: function(e) {\n            update(editor => {\n                const dropState = canDrop.call(this, editor, e)\n                if (dropState) {\n                    editor.drop = dropState\n                }\n            })\n        },\n        ondragleave: dragleave,\n        ondragexit: dragleave,\n        ondragover: function(e) {\n            update(editor => {\n                const dropState = canDrop.call(this, editor, e)\n                if (dropState) {\n                    editor.drop = dropState\n                    e.preventDefault()\n                }\n            })\n        },\n        ondrop: function(e) {\n            update(editor => {\n                e.preventDefault()\n                drop.call(this, editor, e)\n                editor.drag = {type: null}\n                editor.drop = {type: null}\n            })\n        },\n    }\n}\n\nfunction startTrack(event, trackType) {\n    return editor => {\n        editor.trackType = trackType\n        editor.trackStart.xy = [event.clientX, event.clientY]\n        if (editor.hover.type == \"line\") {\n            editor.trackStart.type = \"line\"\n            editor.trackStart.lineId = editor.hover.lineId\n        }\n    }\n}\n\nfunction updateTrack(event) {\n    return editor => {\n        if (editor.trackStart.xy == null) {\n            return\n        }\n        editor.trackStop.xy = [event.clientX, event.clientY]\n        if (editor.trackStart.type != null) {\n            if (editor.hover.type == \"line\") {\n                editor.trackStop.type = \"line\"\n                editor.trackStop.lineId = editor.hover.lineId\n            } else if (editor.hover.type == \"node\") {\n                editor.trackStop.type = \"node\"\n                editor.trackStop.nodeIndex = editor.hover.nodeIndex\n            } else {\n                editor.trackStop.type = null\n            }\n        }\n    }\n}\n\nfunction isSuperlineOfLineUnique(diagram, lineId) {\n    const line0 = diagram.lines[lineId]\n    if (line0.superline == \"0\") {\n        return false\n    }\n    for (const [id, line] of Object.entries(diagram.lines)) {\n        if (id != lineId &&\n            line.superline == line0.superline) {\n            return false\n        }\n    }\n    return !findDeltaEntry(diagram.deltas, line0.superline)\n}\n\nfunction generateLoopSuperline(diagram, lineId) {\n    let line = new Diagram(diagram).line(lineId)\n    if (!isLoopLine(line)) {\n        return null\n    }\n    if (isSuperlineOfLineUnique(diagram, lineId)) {\n        return diagram\n    }\n    // a loop line can become whatever it wants\n    diagram = Object.assign({}, diagram)\n    const newLabel = availSuperlineLabels(diagram).next().value\n    const oldLabel = diagram.lines[lineId].superline\n    if (line.lineIndex(0) == 0\n        && line.lineIndex(1) == 2) {\n        line = line.reverse()\n    }\n    diagram.lines = Object.assign({}, diagram.lines, {\n        [lineId]: Object.assign({}, diagram.lines[lineId], {\n            direction: line.reversed ? -1 : 1,\n            superline: newLabel,\n        })\n    })\n    const phase = line.direction == -1 ? 2 : 0\n    diagram.superlines = mergeSuperlineLists(diagram.superlines, {\n        [oldLabel]: ensureSuperline({weight: +1, phase: phase}),\n        [newLabel]: ensureSuperline({weight: -1}),\n    })\n    return new Diagram(diagram).removeUnusedSuperlines().rawDiagram\n}\n\nfunction finishTrack(editor, event) {\n    if (editor.trackStop.xy == null\n        || (editor.trackStart.type == editor.trackStop.type\n         && editor.trackStart.nodeIndex == editor.trackStop.nodeIndex\n         && editor.trackStart.lineId == editor.trackStop.lineId\n         && vectorSquare(vectorSubtract(editor.trackStart.xy,\n                                        editor.trackStop.xy)) < 10)) {\n        if (editor.trackStart.type == \"line\") {\n            if (editor.trackType == \"track2\") {\n                if (editor.snapshot.frozen) {\n                    modifyDiagram({equivalent: true}, diagram =>\n                        flipW1jRule(diagram, editor.trackStart.lineId))(editor)\n                } else {\n                    modifyDiagram({}, diagram =>\n                        addW1j(diagram, editor.trackStart.lineId))(editor)\n                }\n                return\n            } else if (editor.trackType == \"track1\") {\n                const lineId = editor.trackStart.lineId\n                if (editor.snapshot.frozen) {\n                    modifyDiagram({equivalent: true}, diagram => {\n                        const result = generateLoopSuperline(diagram, lineId)\n                        if (result) {\n                            return result\n                        }\n                        const line = Object.assign({}, diagram.lines[lineId])\n                        const found = findDeltaEntry(diagram.deltas, line.superline)\n                        if (!found) {\n                            return diagram\n                        }\n                        const [j, i] = found\n                        line.superline = diagram.deltas[j][(i + 1) %\n                            diagram.deltas[j].length]\n                        return Object.assign({}, diagram, {\n                            lines: Object.assign({}, diagram.lines, {\n                                [lineId]: line,\n                            }),\n                        })\n                    })(editor)\n                } else {\n                    modifyDiagram({}, diagram => {\n                        // don't bother if it's already unique\n                        if (isSuperlineOfLineUnique(diagram, lineId)) {\n                            return diagram\n                        }\n                        diagram = Object.assign({}, diagram)\n                        const newLabel = availSuperlineLabels(diagram).next().value\n                        diagram.lines = Object.assign({}, diagram.lines, {\n                            [lineId]: Object.assign({}, diagram.lines[lineId], {\n                                superline: newLabel,\n                            })\n                        })\n                        diagram.superlines = mergeSuperlineLists(diagram.superlines, {\n                            [newLabel]: EMPTY_SUPERLINE\n                        })\n                        return diagram\n                    })(editor)\n                }\n                return\n            }\n        }\n    } else {\n        const stopXy = toSvgCoords(editor.trackStop.xy)\n        const startXy = toSvgCoords(editor.trackStart.xy)\n        if (editor.trackType == \"track1\") { // red - middle\n            if (editor.trackStop.type == \"line\") {\n                if (editor.trackStart.lineId == editor.trackStop.lineId) {\n                    modifyDiagram({equivalent: true, clearHover: true}, diagram =>\n                        w3jElimRule(diagram, editor.trackStart.lineId))(editor)\n                } else {\n                    modifyDiagram({equivalent: true, clearHover: true}, diagram =>\n                        glueRule(diagram, editor.trackStart.lineId,\n                                 editor.trackStop.lineId,\n                                 startXy, stopXy))(editor)\n                }\n            } else if (editor.trackStart.type == \"line\") {\n                modifyDiagram({equivalent: true, clearHover: true}, diagram =>\n                    loopIntroRule(diagram,\n                                  editor.trackStart.lineId,\n                                  startXy,\n                                  stopXy))(editor)\n            }\n        } else if (editor.trackType == \"track2\") { // green - right\n            if (editor.trackStop.type == \"line\") {\n                if (editor.trackStart.lineId == editor.trackStop.lineId) {\n                    modifyDiagram({equivalent: true, clearHover: true}, diagram =>\n                        cutRule(diagram, editor.trackStart.lineId,\n                                startXy, stopXy))(editor)\n                } else {\n                    modifyDiagram({\n                        equivalent: true,\n                        clearHover: true,\n                    }, diagram => {\n                        // prefer orientable diagrams\n                        let candidateDiagram\n                        for (const diagonal of [false, true]) {\n                            candidateDiagram =\n                                w3jIntroRule(diagram,\n                                             editor.trackStart.lineId,\n                                             editor.trackStop.lineId,\n                                             event.shiftKey,\n                                             diagonal)\n                            const ambient = getAmbientDirections(\n                                new Diagram(candidateDiagram), true)\n                            if (ambient.orientable) {\n                                return candidateDiagram\n                            }\n                        }\n                        return candidateDiagram\n                    })(editor)\n                }\n            } else if (editor.trackStop.type == \"node\") {\n                modifyDiagram({equivalent: true, clearHover: true}, diagram =>\n                    loopElimRule(diagram,\n                                 editor.trackStart.lineId,\n                                 editor.trackStop.nodeIndex))(editor)\n            }\n        }\n    }\n}\n\nfunction clearTrack(editor, event) {\n    finishTrack(editor, event)\n    editor.trackType = null\n    editor.trackStart = {type: null, xy: null}\n    editor.trackStop = {type: null, xy: null}\n}\n\nfunction mouseUp(event) {\n    return editor => {\n        if (editor.dragger) {\n            modifyDiagram(editor.draggerFlags, identity)(editor)\n            editor.dragger = null\n        } else {\n            clearTrack(editor, event)\n        }\n        event.stopPropagation()\n        event.preventDefault()\n    }\n}\n\nconst ENABLE_DRAG = Symbol(\"ENABLE_DRAG\")\n\nfunction mouseMove(event) {\n    return editor => {\n        let svg = document.getElementById(\"diagram\")\n        const rect = svg.getBoundingClientRect()\n        editor.rawMouseX = event.clientX\n        editor.rawMouseY = event.clientY\n        editor.mouseX = event.clientX - rect.left\n        editor.mouseY = event.clientY - rect.top\n        if (editor.dragger) {\n            modifyDiagram(\n                Object.assign({}, editor.draggerFlags, {transient: true}),\n                diagram => editor.dragger(\n                    diagram,\n                    event.clientX + editor.dragOffsetX,\n                    event.clientY + editor.dragOffsetY,\n                    event.ctrlKey))(editor)\n            event.stopPropagation()\n        } else {\n            updateTrack(event)(editor)\n        }\n        // prevent user from selecting things by accident;\n        // we can't do this in mousedown, because that breaks deselection;\n        // we also can't use user-select, because that also breaks deselection\n        // (a textbox might *look* like it's deselected, but middle-click paste\n        // and backspace still works!);\n        // it also breaks dragging too ... be careful!\n        if (!vnodeGetSymbol(event.target, ENABLE_DRAG)\n            && editor.focus.type == null) {\n            event.preventDefault()\n        }\n    }\n}\n\nfunction startDrag(x, y, flags, dragger) {\n    return editor => {\n        editor.dragger = dragger\n        editor.draggerFlags = flags\n        editor.dragOffsetX = x - editor.rawMouseX\n        editor.dragOffsetY = y - editor.rawMouseY\n    }\n}\n\nfunction traverseElem(elem, f) {\n    if (!elem instanceof Element) {\n        return\n    }\n    f(elem)\n    let children = elem.children\n    for (const i of range(0, children.length)) {\n        traverseElem(children[i], f)\n    }\n}\n\nfunction applyStylesheet(stylesheet, elem) {\n    traverseElem(elem, elem => {\n        let style = []\n        for (const selector of Object.keys(stylesheet)) {\n            if (elem.matches(selector)) {\n                const rule = stylesheet[selector]\n                for (const prop of Object.keys(rule)) {\n                    const propName = prop.replace(/[A-Z]/g, c =>\n                        \"-\" + c.toLowerCase())\n                    if (propName == \"transform\") {\n                        // Inkscape doesn't handle transforms in style\n                        elem.setAttribute(propName, rule[prop])\n                    } else if (filter(propName)) {\n                        style.push(propName + \": \" + rule[prop])\n                    }\n                }\n            }\n        }\n        const inlineStyle = elem.getAttribute(\"style\")\n        if (inlineStyle) {\n            style.push(inlineStyle)\n        }\n        if (style.length) {\n            elem.setAttribute(\"style\", style.join(\"; \"))\n        }\n    })\n}\n\nlet prevKey\nfunction keyDown(e, editor) {\n    const snapshot = editor.snapshot\n    const update = f => f(editor)\n\n    if (prevKey == \"\\x3a\" && e.key == \"\\x33\") {\n        editor.notice = prevKey + e.key\n    }\n\n    // don't steal focus when editing text\n    if (editor.focus.type != null) {\n        return\n    }\n\n    // reload\n    if (getModifiers(e) == 0 && e.key == \"r\") {\n        window.location.href = \"\"\n        e.preventDefault()\n        return\n    }\n\n    // help\n    if (getModifiers(e) == SHIFT && e.key == \"?\") {\n        window.location.href = document.getElementById(\"help-link\").href;\n        e.preventDefault()\n        return\n    }\n\n    // help\n    if (getModifiers(e) == 0 && e.key == \"v\") {\n        update(modifyDiagram({toggleAmbient: true}, identity))\n        e.preventDefault()\n        return\n    }\n\n    // mouse events require the position\n    if (editor.mouseX === null) {\n        return\n    }\n\n    // create Clebsch-Gordan coefficient\n    if (getModifiers(e) == 0 && e.key == \"f\") {\n        update(modifyDiagram({toggleFreeze: true}, identity))\n        e.preventDefault()\n        return\n    }\n\n    // create Clebsch-Gordan coefficient\n    if (getModifiers(e) == 0 && e.key == \"c\") {\n        update(modifyDiagram({}, diagram => {\n            const labels = Array.from(take(3, availSuperlineLabels(diagram)))\n            return mergeDiagrams(diagram,\n                                 cgDiagram(labels[0],\n                                           labels[1],\n                                           labels[2],\n                                           editor.mouseX,\n                                           editor.mouseY))\n        }))\n        e.preventDefault()\n        return\n    }\n\n    // create Wigner 3-jm\n    if (getModifiers(e) == 0 && e.key == \"w\") {\n        update(modifyDiagram({}, diagram => {\n            const labels = Array.from(take(3, availSuperlineLabels(diagram)))\n            return mergeDiagrams(diagram, w3jDiagram(labels[0],\n                                                     labels[1],\n                                                     labels[2],\n                                                     editor.mouseX,\n                                                     editor.mouseY))\n        }))\n        e.preventDefault()\n        return\n    }\n\n    // attach\n    if (getModifiers(e) == 0 && e.key == \"a\") {\n        update(modifyDiagram({}, diagram => {\n            const nearest = nearestNodeIndices(diagram.nodes, 2,\n                                               editor.mouseX,\n                                               editor.mouseY)\n            if (!(nearest.length == 2 &&\n                  diagram.nodes[nearest[0]].type == \"terminal\" &&\n                  diagram.nodes[nearest[1]].type == \"terminal\")) {\n                return \"no nearby terminals found\"\n            } else {\n                return joinTerminals(diagram, nearest[0], nearest[1])\n            }\n        }))\n        e.preventDefault()\n        return\n    }\n\n    // create Wigner 1-jm\n    if (getModifiers(e) == 0 && e.key == \"m\" && editor.hover.type == \"line\") {\n        update(modifyDiagram({}, diagram =>\n            addW1j(diagram, editor.hover.lineId)))\n        e.preventDefault()\n        return\n    }\n\n    // add 2j phase / flip Wigner 3j node\n    if (getModifiers(e) == 0 && e.key == \"j\") {\n        if (editor.hover.type == \"line\") {\n            update(modifyDiagram({}, diagram =>\n                add2j(diagram, editor.hover.lineId)))\n            e.preventDefault()\n            return\n        } else if (editor.hover.type == \"node\") {\n            update(modifyDiagram({}, diagram =>\n                flipW3j(diagram, editor.hover.nodeIndex)))\n            e.preventDefault()\n            return\n        }\n    }\n\n    // delete node\n    if (getModifiers(e) == 0 && e.key == \"x\") {\n        update(modifyDiagram({}, diagram => {\n            const nodes = diagram.nodes\n            const nearest = nearestNodeIndices(nodes, 1,\n                                               editor.mouseX,\n                                               editor.mouseY)\n            if (nearest.length != 1 ||\n                (nodes[nearest[0]].type == \"terminal\" &&\n                 nodes[otherNodeIndex(nodes, nearest[0], 0)].type\n                    != \"terminal\")) {\n                return \"no nearby nodes found\"\n            } else {\n                return deleteNode(diagram, nearest[0])\n            }\n        }))\n        e.preventDefault()\n        return\n    }\n\n    // save as SVG\n    if (getModifiers(e) == 0 && e.key == \"s\") {\n        const diagram = document.getElementById(\"diagram\")\n        let svg = diagram.cloneNode(true)\n        const rect = diagram.getBoundingClientRect()\n        svg.setAttribute(\"viewBox\", `0 0 ${rect.width} ${rect.height}`)\n        applyStylesheet(diagramStylesheet, svg)\n        // downgrade href attribute to the deprecated xlink:href\n        traverseElem(svg, elem => {\n            const href = elem.getAttribute(\"href\")\n            if (href) {\n                elem.removeAttribute(\"href\")\n                elem.setAttributeNS(NAMESPACES.xlink, \"href\", href)\n            }\n        })\n        const url = URL.createObjectURL(\n            new Blob([new XMLSerializer().serializeToString(svg)],\n                     {type: \"image/svg+xml;charset=utf-8\"}))\n        let a = document.createElement(\"a\")\n        a.href = url\n        a.download = \"diagram.svg\"\n        document.getElementsByTagName(\"body\")[0].appendChild(a)\n        a.click()\n        a.remove()\n        URL.revokeObjectURL(url)\n    }\n\n    prevKey = e.key\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Global stuff\n\nfunction getUpdate(editor) {\n    return (...changes) => {\n        const update = getUpdate(editor)\n        const n = changes.length\n        for (let i = 0; i < n; ++i) {\n            changes[i](editor)\n        }\n        applyRendering(renderEditor(update, editor))\n    }\n}\n\nexport function main() {\n    let editor = {}\n    Object.assign(editor, newEditor())\n    const update = getUpdate(editor)\n    update(loadEditor)\n}\n","import * as script from './script.js'\n\nlet failed = false\n\nfunction assert(condition) {\n    failed = failed || !condition\n    console.assert(condition)\n}\n\nassert(script.permutSign([2, 1, 3], [2, 1, 3]) == 1)\n\nassert(JSON.stringify(script.mergeDeltas([\n    [1, 2],\n    [3, 4],\n])) == JSON.stringify([\n    [1, 2],\n    [3, 4],\n]))\n\nassert(JSON.stringify(script.mergeDeltas([\n    [1, 2],\n    [3, 4],\n    [2, 3],\n    [5, 6],\n])) == JSON.stringify([\n    [1, 2, 3, 4],\n    [5, 6],\n]))\n\nassert(script.containsDeltas([\n    [1, 2, 3, 4],\n    [5, 6],\n], [[5, 6]]))\n\nassert(script.containsDeltas([\n    [1, 2, 3, 4],\n    [5, 6],\n], [[5, 6]]))\n\nassert(JSON.stringify(script.removeDeltaEntry([\n    [1, 2, 3, 4],\n    [5, 6],\n], 6)) == JSON.stringify([\n    [1, 2, 3, 4],\n]))\n\nassert(JSON.stringify(script.relatedDelta([\n    [1, 2, 3, 4],\n    [5, 6],\n], 2)) == JSON.stringify([2, 1, 3, 4]))\n\n//////////////////////////////////////////////////////////////////////////////\n// Diagram.substitute\n\nconst d1 = script.ensureDiagram({\n    nodes: [\n        script.terminalNode(\"a\", \"a\", 0, 0),\n        script.terminalNode(\"a\", \"b\", 0, 0),\n    ],\n    lines: {\n        a: script.newLine(\"a\"),\n    },\n    superlines: {\n        a: script.EMPTY_SUPERLINE,\n    },\n})\n\nscript.assertEq(\n    new script.Diagram(d1).renameLines({a: \"b\"}).rawDiagram,\n    new script.Diagram(script.ensureDiagram({\n        nodes: [\n            script.terminalNode(\"b\", \"a\", 0, 0),\n            script.terminalNode(\"b\", \"b\", 0, 0),\n        ],\n        lines: {\n            b: script.newLine(\"a\"),\n        },\n        superlines: {\n            a: script.EMPTY_SUPERLINE,\n        },\n    })).rawDiagram)\n\nscript.assertEq(\n    new script.Diagram().substitute(\n        script.EMPTY_DIAGRAM,\n        script.EMPTY_DIAGRAM,\n    ).rawDiagram,\n    script.EMPTY_DIAGRAM,\n)\n\nscript.assertEq(\n    new script.Diagram(d1).substitute(\n        script.EMPTY_DIAGRAM,\n        script.EMPTY_DIAGRAM,\n    ).rawDiagram,\n    d1,\n)\n\nscript.assertEq(new script.Diagram(d1).substitute({\n    nodes: [\n        script.terminalNode(\"+a\", \"x\"),\n        script.terminalNode(\"+a\", \"y\"),\n    ],\n    lines: {\n        [\"+a\"]: {superline: \"a\", direction: 0},\n    },\n    superlines: {\n        a: script.EMPTY_SUPERLINE,\n    },\n}, {\n    nodes: [\n        script.terminalNode(\"a\", \"x\"),\n        script.terminalNode(\"a\", \"y\"),\n    ],\n    lines: {\n        a: {superline: \"a\", direction: 0},\n    },\n    superlines: {\n        a: script.EMPTY_SUPERLINE,\n    },\n}).rawDiagram, d1)\n\nscript.assertEq(new script.Diagram(d1).substitute({\n    nodes: [\n        script.terminalNode(\"+a\", \"x\"),\n        script.terminalNode(\"+a\", \"y\"),\n    ],\n    lines: {\n        \"+a\": {superline: \"a\", direction: 0},\n    },\n}, {\n    nodes: [\n        script.terminalNode(\"$1\", \"x\"),\n        script.terminalNode(\"$2\", \"y\"),\n        script.w3jNode(\"$4\", \"$4\", \"$3\"),\n        script.w3jNode(\"$3\", \"$2\", \"$1\"),\n    ],\n    lines: {\n        $4: {superline: \"0\", direction: +1},\n        $3: {superline: \"0\", direction: 0},\n        $2: {superline: \"a\", direction: 0},\n        $1: {superline: \"a\", direction: +1},\n    },\n    superlines: {\n        a: {weight: 1},\n    },\n}).rawDiagram, {\"nodes\":[{\"type\":\"terminal\",\"lines\":[\"4\"],\"variable\":\"a\",\"x\":0,\"y\":0},{\"type\":\"terminal\",\"lines\":[\"3\"],\"variable\":\"b\",\"x\":0,\"y\":0},{\"type\":\"w3j\",\"lines\":[\"1\",\"1\",\"2\"]},{\"type\":\"w3j\",\"lines\":[\"2\",\"3\",\"4\"]}],\"superlines\":{\"0\":{\"phase\":0,\"summed\":false,\"weight\":0},\"a\":{\"phase\":0,\"summed\":false,\"weight\":1}},\"lines\":{\"1\":{\"superline\":\"0\",\"direction\":0,\"arrowPos\":0.5,\"arcHeight\":0,\"angle\":0,\"textPos\":0.5,\"textOffset\":0},\"2\":{\"superline\":\"0\",\"direction\":0,\"arrowPos\":0.5,\"arcHeight\":0,\"angle\":0,\"textPos\":0.5,\"textOffset\":0},\"3\":{\"superline\":\"a\",\"direction\":0,\"arrowPos\":0.5,\"arcHeight\":0,\"angle\":0,\"textPos\":0.5,\"textOffset\":0},\"4\":{\"superline\":\"a\",\"direction\":1,\"arrowPos\":0.5,\"arcHeight\":0,\"angle\":0,\"textPos\":0.5,\"textOffset\":0}},\"deltas\":[]})\n\nif (!failed) {\n    document.getElementsByTagName(\"body\")[0].style.background = \"black\"\n}\n"],"names":["module","exports","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","identity","x","defaultEq","y","defaultCmp","lexicalCmp","xs","ys","cmp","nx","length","ny","n","i","r","permutSign","permut","Map","entries","has","set","visited","Set","sign","size","x0","values","next","value","delete","get","mod","bitXor","range","start","stop","map","f","filter","arrayRemoveMany","indices","slice","Array","from","sort","Error","splice","propOr","obj","prop","def","hasOwnProperty","deepDiff","type","left","right","xIsArray","isArray","yIsArray","xi","diff","xProto","Object","getPrototypeOf","yProto","k","keys","assertEq","console","warn","assert","WeakMap","REAL_FIELD","ZERO","ONE","add","subtract","multiply","divide","eq","GF2_FIELD","assign","RealSparseVector","zero","SparseVector","constructor","iterable","this","data","v","copy","Symbol","iterator","key","modify","toTable","t","RealSparseMatrix","SparseMatrix","j","row","rows","cachedGet","rowKeys","colKeys","js","deleteRow","mergeDeltas","deltaLists","finalDeltas","finder","forEach","deltas","delta","found","push","exists","freeze","containsDeltas","subdeltas","subdelta","findDeltaEntry","entry","relatedDelta","ji","concat","EMPTY_SUPERLINE","phase","summed","weight","isEmptySuperline","superline","mergeSuperlines","superlines","finalSuperline","mergeSuperlineLists","superlineLists","finalSuperlines","id","ZERO_LINE","direction","arrowPos","arcHeight","angle","textPos","textOffset","newLine","superlineId","ensureLine","line","reverseLine","Math","PI","mergeDirections","directions","s","sum","rawConcatLines","lines","avgProps","finalLine","sinAngle","cosAngle","numAngles","counts","sin","cos","atan2","concatLines","canonicalized","trunc","canonicalizeLine","terminalNode","lineId","variable","node","w3jNode","a","b","c","EMPTY_DIAGRAM","nodes","ensureDiagram","diagram","DiagramLine","reversed","Boolean","rawLine","rawDiagram","end","lineEnds","_lineEnds","DiagramNode","lineIndex","cycNodeLine","offset","toString","signedRebase","signedLine","reverse","removeSign","signedId","substr","rawAssign","index","testCuttability","errors","subdiagramOrientability","priority","error","rawNode","numLines","lineEnd","xy","Diagram","_cache","deserialize","JSON","parse","serialize","stringify","nodeIndex","ends","getLineEnds","terminals","terminal","numNodes","lineIds","hasSuperline","isEquallyConstrained","deltas1","deltas2","renameLines","renames","desumExposedSuperlines","isSuperlineExposed","renameSuperlines","removeUnusedSuperlines","marked","substitute","pattern","replacement","flags","pattDiagram","replDiagram","deltaMerge","sharedLines","seenLines","pattLine","seen","newLines","freshLineIds","Number","POSITIVE_INFINITY","lineRenames","startsWith","superlineMerge","summedSuperlines","pattSuperline","pattNode","nodeLines","pattNodeLines","uniqueLines","matchedLineIds","pattNode0","pattNode1","diffDirection","replNodes","seenReplLines","findJoiningNode","replLine","replNode","result","otherPattLineId","otherPattLine","otherPattNode","getPart","joining","joining0","combined","joining1","nodeIndex0","nodeIndex1","lineIndex0","lineIndex1","newNodes","prototype","newDiagram","withLineRenames","line0","subdiagram","closed","isolated","nodeIndices","candidates","pop","_","getConnectedSubdiagram","ignoreExternal","excludedLineIds","includes","matrix","subdirections","submatrix","field","vector","is","unconstrained","pivots","jp","xp","ip","invXp","consistent","solution","u","sparseGaussElim","ambient","rng","sparseMatrixVectorMultiply","orientable","target","getAmbientDirections","failed","condition","d1","$4","$3","$2","$1","document","getElementsByTagName","style","background"],"ignoreList":[],"sourceRoot":""}