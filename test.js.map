{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./script.js","webpack:///./test.js","webpack:///./diagram.css?435f"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","identity","x","defaultEq","y","defaultCmp","lexicalCmp","xs","ys","cmp","nx","length","ny","permutSign","permut","Map","entries","has","set","visited","Set","sign","size","x0","values","next","delete","sgn","mod","clamp","min","max","round","dx","bitXor","range","start","stop","map","f","filter","take","arrayRemoveMany","indices","slice","Array","from","sort","Error","splice","currentId","idMap","WeakMap","propOr","obj","prop","def","deepClone","JSON","parse","stringify","assertEq","diff","deepDiff","type","left","right","xIsArray","isArray","yIsArray","xi","xProto","getPrototypeOf","yProto","k","keys","console","warn","assert","threePointArc","y0","x1","y1","x2","y2","ax","ay","bx","by","cx","cy","det","radius","Math","sqrt","pow","vectorAdd","v0","vs","v","vi","vectorSubtract","vectorDot","v1","v2","scalarMultiply","REAL_FIELD","ZERO","ONE","add","subtract","multiply","divide","eq","GF2_FIELD","assign","RealSparseVector","zero","undefined","SparseVector","iterable","this","data","iterator","RealSparseMatrix","SparseMatrix","j","row","rows","getDefault","cachedGet","js","rowKeys","colKeys","toTable","VNODE_KEY","VNODE_SUSPEND_CHILDREN","VNODE_SYMBOLS","VNODE_EVENT_LISTENERS","vnodeAmendAttributes","attrs","elem","listeners","unusedListeners","exec","event","listener","addEventListener","e","removeAttribute","getAttribute","setAttribute","symKeys","getOwnPropertySymbols","symbols","unusedEvents","removeEventListener","vnodeRenderChildren","children","oldChildren","childNodes","fragment","document","createDocumentFragment","child","oldChild","Vnode","attributes","Element","Text","removeChild","insertBefore","HTMLElement","nodeName","toLowerCase","namespaceURI","namespace","renderTo","nodeValue","createTextNode","appendChild","oldAttrs","oldAttr","removeNamedItem","vnodeRenderAttributes","createElementNS","createElement","NAMESPACES","svg","xlink","vnode","parseNamespace","renderQueue","mergeDeltas","deltaLists","finalDeltas","finder","forEach","deltas","delta","found","push","exists","freeze","containsDeltas","subdeltas","subdelta","equalDeltas","deltas1","deltas2","findDeltaEntry","entry","relatedDelta","ji","concat","removeDeltaEntry","EMPTY_SUPERLINE","phase","summed","weight","ensureSuperline","superline","newLabel","label","match","Number","toString","availLabels","POSITIVE_INFINITY","availSuperlineLabels","diagram","labels","superlines","mergeSuperlines","finalSuperline","mergeSuperlineLists","superlineLists","finalSuperlines","id","ZERO_LINE","direction","arrowPos","arcHeight","angle","textPos","textOffset","newLine","superlineId","ensureLine","line","reverseLine","PI","isLineDirectable","mergeDirections","directions","sum","rawConcatLines","lines","avgProps","finalLine","sinAngle","cosAngle","numAngles","counts","sin","cos","atan2","concatLines","canonicalized","canonicalizeLine","trunc","getLineInfoBetween","xMid","yMid","dy","lineLength","singular","trueAngle","halfDisk","epsilon","Infinity","abs","arc","inclination","large","sweep","halfLength","theta","asin","arcInfo","xCenter","yCenter","arcEx","startAngle","getLineInfo","lineId","ends","endNodeIndices","nodes","node0","node1","external","includes","findPosOnLine","lineInfo","pos","offset","rx","ry","cycle","shift","positionOnLine","newPos","normalX","normalY","tangentAngle","localAngle","normalAngle","terminalNode","variable","node","w3jNode","a","b","endNodeAndLineIndices","nodeAndLineIndices","numNodes","nodeIndex","numLines","lineIndex","otherNodeAndLineIndex","otherNodeIndex","isLeftOfLine","nearestNodeIndices","count","distance","index","EMPTY_DIAGRAM","ensureDiagram","w3jDiagram","setDiagramLineProps","props","w3jOrientation","_","reverse","lineAngle","line1","line2","mergeDiagrams","diagram1","diagram2","renames","newLineId","terminals","isSuperlineExposed","addW1j","flipW3j","isDanglingSuperline","lineIds","flipW3jRule","DiagramLine","reversed","Boolean","rawDiagram","rawLine","end","lineEnds","_lineEnds","DiagramNode","signedLine","signedId","substr","errors","subdiagramOrientability","priority","error","rawNode","lineEnd","Diagram","_cache","getLineEnds","removeSign","removeUnusedSuperlines","desumExposedSuperlines","marked","pattern","replacement","flags","pattDiagram","replDiagram","deltaMerge","sharedLines","seenLines","pattLine","seen","newLines","freshLineIds","lineRenames","startsWith","renameLines","superlineMerge","summedSuperlines","pattSuperline","isEquallyConstrained","pattNode","signedRebase","nodeLines","pattNodeLines","uniqueLines","matchedLineIds","pattNode0","pattNode1","diffDirection","replNodes","seenReplLines","findJoiningNode","replLine","replNode","result","terminal","otherPattLineId","otherPattLine","otherPattNode","getPart","joining","joining0","combined","joining1","nodeIndex0","nodeIndex1","lineIndex0","lineIndex1","newNodes","newDiagram","withLineRenames","findW3jLoop","cutLine","loopLine","loopElimRule","loopNode","loop","otherNode","ld","lc","lb","cycNodeLine","la","md","mc","mb","ma","jd","jc","jb","ja","substitute","$1","w3jIntroRule","lineId1","lineId2","diagonal","xy","xy1","xy2","arcHeight1","arcHeight2","$2","$3","$4","$5","getAmbientDirections","ignoreExternal","excludedLineIds","matrix","modify","subdirections","copy","submatrix","deleteRow","field","vector","is","unconstrained","pivots","jp","pop","xp","ip","invXp","consistent","solution","constructor","u","sparseGaussElim","ambient","rng","sparseMatrixVectorMultiply","orientable","target","line0","subdiagram","closed","isolated","nodeIndices","candidates","getConnectedSubdiagram","renderLine","update","editor","snapshot","info","position","textX","textY","onmousedown","toSvgCoords","clientX","clientY","buttons","startDrag","superficial","snap","change","height","stopPropagation","ctrlKey","modifyDiagram","trackStart","trackStop","trackType","onmouseenter","setHover","onmouseleave","where","bad","expectedDirection","ambientDirection","correction","rawPosition","href","width","transform","arrowHeadSize","renderArrow","renderNode","frozen","gChildren","join","circularArrowSize","orientation","frozenClass","setDiagramNodeProps","shiftKey","equivalent","oldDiagram","loopId","threeArrowRule","cmpSuperlineId","GREEK_LATEX","GREEK_LETTERS","IDENT_CHAR_REGEX","isValidSuperlineId","RegExp","isLoopLine","renderJTableau","focus","focusedName","twoJ","modifyDiagramWith","newSuperlineId","renameSuperlines","editSummed","freshSuperlineId","introSum","contenteditable","spellcheck","onfocus","setFocus","onblur","textContent","trim","numLoops","clearFocus","drag","drop","oncontextmenu","preventDefault","handleDrag","handleDrop","editDelta","deltaIndex","input","oldDeltas","invalid","split","inferredDeltas","knownZeros","inferDeltas","oldInferredDeltas","newInferredDeltas","oldZeroDelta","newZeroDelta","diffDelta","testCuttability","renderDeltaJ","String","renderDeltaTableau","focused","sep","arrayIntercalate","createRange","selectNodeContents","sel","window","getSelection","removeAllRanges","addRange","renderVariable","replace","renderEquationLine","summedVars","otherIndex","mNaked","jm","ms","EMPTY_SNAPSHOT","showAmbient","newEditor","savedSnapshot","savedHash","staleEquation","notice","hover","mouseX","mouseY","loadEditor","hash","location","decodeURIComponent","rect","getElementById","getBoundingClientRect","top","renderEditor","element","onhashchange","onkeydown","keyDown","onmousemove","rawMouseX","rawMouseY","dragger","draggerFlags","transient","dragOffsetX","dragOffsetY","updateTrack","ENABLE_DRAG","onmouseup","flipW1jRule","isSuperlineOfLineUnique","oldLabel","generateLoopSuperline","stopXy","startXy","clearHover","otherLine","line3","line4","lineIdOther","w3jElimRule","glueRule","dxy","loopIntroRule","loop1Id","loop2Id","cutRule","candidateDiagram","finishTrack","clearTrack","getElementsByTagName","startTrack","onclick","container","currentTarget","phases","mDeltas","var1","var2","m1","m2","jRow","mRow","weights","jVar","node2","summedVarsStr","phasesStr","mDeltasStr","jDeltas","j0","MathJax","Hub","Queue","renderEquation","diagramTransform","transformer","setError","toggleFreeze","toggleAmbient","encodeURIComponent","saveEditor","getModifiers","altKey","errorTimeout","msg","clearTimeout","setTimeout","getUpdate","entity","canDrag","draggable","ondragstart","dataTransfer","setData","dragState","ondragend","canDrop","dragleave","ondragenter","dropState","ondragleave","ondragexit","ondragover","ondrop","traverseElem","prevKey","cgDiagram","nearest","terminalIndex1","terminalIndex2","terminal1","terminal2","rawAssign","joinTerminals","add2j","deleteNode","cloneNode","stylesheet","style","selector","matches","rule","propName","inlineStyle","setAttributeNS","url","URL","createObjectURL","Blob","XMLSerializer","serializeToString","download","click","remove","revokeObjectURL","changes","rendering","spec","applyRendering","main","failed","condition","d1","background"],"mappings":"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","file":"test.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 190);\n","\"use strict\"\n\nimport \"./style.css\"\nimport \"./diagram.css\"\nimport diagramStylesheet from \"./diagram.css?postcss\"\n\n//////////////////////////////////////////////////////////////////////////////\n// Utility: Generic\n\nfunction identity(x) {\n    return x\n}\n\nfunction defaultEq(x, y) {\n    return x == y\n}\n\nfunction defaultCmp(x, y) {\n    if (x < y) {\n        return -1\n    } else if (y < x) {\n        return 1\n    } else {\n        return 0\n    }\n}\n\nfunction lexicalCmp(xs, ys, cmp) {\n    const nx = xs.length\n    const ny = ys.length\n    const n = nx < ny ? nx : ny\n    for (let i = 0; i < n; ++i) {\n        const r = cmp(xs[i], ys[i])\n        if (r) {\n            return r\n        }\n    }\n    return defaultCmp(nx, ny)\n}\n\nexport function permutSign(xs, ys) {\n    let permut = new Map()\n    for (const [i, y] of ys.entries()) {\n        if (permut.has(y)) {\n            return 0 // not a permutation\n        }\n        permut.set(y, xs[i])\n    }\n    let visited = new Set(xs)\n    let sign = 1\n    while (visited.size) {\n        const x0 = visited.values().next().value\n        visited.delete(x0)\n        let x = x0\n        do {\n            if (!permut.has(x)) {\n                return 0 // not a permutation\n            }\n            x = permut.get(x)\n            visited.delete(x)\n            sign *= -1\n        } while (x != x0)\n        sign *= -1\n    }\n    return sign\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Utility: Basic math\n\nfunction sgn(x) {\n    return x > 0 ? 1 : x < 0 ? -1 : 0\n}\n\n/** Floored modulo */\nfunction mod(x, y) {\n    return (x % y + y) % y\n}\n\nfunction clamp(min, max, x) {\n    if (x < min) {\n        return min\n    } else if (x > max) {\n        return max\n    } else {\n        return x\n    }\n}\n\nfunction round(dx, x) {\n    if (!dx) {\n        return x\n    }\n    return x + dx / 2 - mod(x + dx / 2, dx)\n}\n\nfunction bitXor(x, y) {\n    return x ^ y\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Utility: Iterators\n\nfunction* range(start, stop) {\n    for (let i = start; i < stop; ++i) {\n        yield i\n    }\n}\n\nfunction* map(f, xs, start) {\n    start = start || 0\n    for (const x of xs) {\n        yield f(x, start)\n        start += 1\n    }\n}\n\nfunction* filter(f, xs) {\n    for (const x of xs) {\n        if (f(x)) {\n            yield x\n        }\n    }\n}\n\nfunction* take(n, xs) {\n    let i = 0\n    for (const x of xs) {\n        if (i >= n) {\n            break\n        }\n        yield x\n        i += 1\n    }\n}\n\nfunction sum(xs) {\n    let s = 0\n    for (const x of xs) {\n        s += x\n    }\n    return s\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Utility: Arrays\n\nfunction arrayEqual(xs, ys, cmp) {\n    if (!cmp) {\n        cmp = defaultCmp\n    }\n    const length = xs.length\n    if (length != ys.length) {\n        return false\n    }\n    for (let i = 0; i < length; ++i) {\n        if (xs[i] != ys[i]) {\n            return false\n        }\n    }\n    return true\n}\n\nfunction arrayRemoveMany(xs, indices) {\n    xs = xs.slice()\n    indices = Array.from(indices)\n    // sort in reverse order\n    indices.sort((x, y) => y - x)\n    const n = indices.length\n    for (let i = 0; i < n; ++i) {\n        if (indices[i] >= xs.length) {\n            throw new Error(\"index out of range\")\n        }\n        xs.splice(indices[i], 1)\n    }\n    return xs\n}\n\nfunction arrayIntercalate(sep, xs) {\n    const n = xs.length\n    let ys = []\n    for (let i = 0; i < n; ++i) {\n        if (i != 0) {\n            ys.push(sep)\n        }\n        ys.push(xs[i])\n    }\n    return ys\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Utility: Objects\n\n// Kind of a hack -- hopefully we won't need this in the future.\nlet currentId = 0\nconst idMap = new WeakMap()\nfunction objectId(obj) {\n    if (!idMap.has(obj)) {\n        idMap.set(obj, ++currentId)\n    }\n    return idMap.get(obj)\n}\n\nfunction propOr(obj, prop, def) {\n    return obj.hasOwnProperty(prop)\n         ? obj[prop]\n         : def\n}\n\nfunction cachedGet(map, key, getDefault) {\n    if (!map.has(key)) {\n        const x = getDefault()\n        map.set(key, x)\n        return x\n    }\n    return map.get(key)\n}\n\nfunction deduplicateObject(obj, image) {\n    const ks = Object.keys(obj)\n    if (ks.length != Object.keys(image).length) {\n        return obj\n    }\n    ks.forEach(k => {\n        if (!(image.hasOwnProperty(k) && obj[k] === image[k])) {\n            return obj\n        }\n    })\n    return image\n}\n\nfunction deepClone(x) {\n    return JSON.parse(JSON.stringify(x))\n}\n\nfunction deepFreeze(obj) {\n    if (Object.isFrozen(obj)) {\n        return obj\n    }\n    Object.freeze(obj)\n    const keys = Object.keys(obj)\n    let i = keys.length\n    while (i--) {\n        deepFreeze(obj[keys[i]])\n    }\n    return obj\n}\n\nfunction deepDiff(x, y) {\n    if (x === y) {\n        return null\n    }\n    if (typeof x != typeof y) {\n        return {type: \"typeMismatch\", left: x, right: y}\n    }\n\n    const xIsArray = Array.isArray(x)\n    const yIsArray = Array.isArray(y)\n    if (xIsArray || yIsArray) {\n        if (xIsArray != yIsArray) {\n            return {type: \"typeMismatch\", left: x, right: y}\n        }\n        const nx = x.length\n        const ny = y.length\n        if (nx != ny) {\n            return {type: \"lengthMismatch\", left: nx, right: ny}\n        }\n        for (const [i, xi] of x.entries()) {\n            const diff = deepDiff(xi, y[i])\n            if (diff) {\n                return {type: \"propertyValueMismatch\", prop: i, diff: diff}\n            }\n        }\n        return null\n    }\n\n    if (typeof x == \"object\") {\n        const xProto = Object.getPrototypeOf(x)\n        const yProto = Object.getPrototypeOf(y)\n        if (xProto != yProto) {\n            return {type: \"prototypeMismatch\", left: xProto, right: yProto}\n        }\n        for (const k of Object.keys(x)) {\n            if (!y.hasOwnProperty(k)) {\n                return {type: \"missingProperty\", left: k}\n            }\n            const diff = deepDiff(x[k], y[k])\n            if (diff) {\n                return {type: \"propertyValueMismatch\", prop: k, diff: diff}\n            }\n        }\n        for (const k of Object.keys(y)) {\n            if (!x.hasOwnProperty(k)) {\n                return {type: \"missingProperty\", right: k}\n            }\n        }\n        return null\n    }\n    return {type: \"notEqual\", left: x, right: y}\n}\n\nexport function assertEq(x, y) {\n    const diff = deepDiff(x, y)\n    if (diff != null) {\n        console.warn(x, y, diff)\n    }\n    console.assert(diff == null)\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Geometry\n\nfunction linePointDistance(x1, y1, x2, y2, x0, y0) {\n    const rx = x0 - x1\n    const ry = y0 - y1\n    const lx = x2 - x1\n    const ly = y2 - y1\n    const l = Math.sqrt(lx * lx + ly * ly)\n    const proj = (rx * lx + ry * ly) / l\n    if (proj < l) {\n        // projection is within segment\n        return Math.abs(ly * x0 - lx * y0 + x2 * y1 - y2 * x1) / l\n    } else if (proj < 0) {\n        // projection is to the left of segment\n        return Math.sqrt(rx * rx + ry * ry)\n    } else {\n        // projection is to the right of segment\n        return Math.sqrt(Math.pow(x0 - x2, 2) + Math.pow(y0 - y2, 2))\n    }\n}\n\nfunction arcInfo(lineLength, arcHeight) {\n    if (arcHeight == 0.0) {\n        return {\n            inclination: 0.0,\n            radius: Infinity,\n            large: false,\n            sweep: false,\n        }\n    }\n    const halfLength = lineLength / 2\n    const radius = (halfLength * halfLength / arcHeight + arcHeight) / 2\n    const large = Math.abs(arcHeight) > halfLength\n    const sweep = arcHeight < 0\n    const theta = Math.asin(halfLength / radius)\n    return {\n        inclination: (large ? (sweep ? -1 : 1) * Math.PI - theta : theta),\n        radius: radius,\n        large: large,\n        sweep: sweep,\n    }\n}\n\n/** Get the height of the arc between 1 and 2 that also passes through 0. */\nfunction threePointArc(x0, y0, x1, y1, x2, y2) {\n    const ax = x1 - x2\n    const ay = y1 - y2\n    const bx = x2 - x0\n    const by = y2 - y0\n    const cx = x0 - x1\n    const cy = y0 - y1\n    const det = ay * cx - cy * ax\n    if (det == 0) {\n        return 0.0\n    }\n    const t = (cx * bx + cy * by) / det\n    const radius = 0.5 * Math.sqrt(Math.pow(ax - ay * t, 2)\n                                 + Math.pow(ay + ax * t, 2))\n    const side = -sgn(ay * bx - ax * by)\n    const arcHeight = side * radius - t / 2 * Math.sqrt(ax * ax + ay * ay)\n    return arcHeight\n}\n\n/** Choose smoothness = 1 for a Catmull-Rom spline. */\nfunction cardinalSpline(xs, ys, smoothness) {\n    const length = xs.length\n    if (length != ys.length) {\n        throw new Error(\"xs and ys must have same length\")\n    }\n    let d = \"\"\n    let prevSecantX, prevSecantY\n    for (let i = 0; i < length; ++i) {\n        if (i == 0) {\n            // do nothing\n            d += `M ${xs[i]} ${ys[i]} `\n            continue\n        }\n        if (i == 1 && i == length - 1) {\n            d += `L ${xs[i]} ${ys[i]} `\n            continue\n        }\n        const x01 = xs[i] - xs[i - 1]\n        const y01 = ys[i] - ys[i - 1]\n        const d01 = Math.sqrt(x01 * x01 + y01 * y01)\n        const x12 = xs[i + 1] - xs[i]\n        const y12 = ys[i + 1] - ys[i]\n        const d12 = Math.sqrt(x12 * x12 + y12 * y12)\n        let secantX = smoothness * (xs[i + 1] - xs[i - 1]) / (d01 + d12)\n        let secantY = smoothness * (ys[i + 1] - ys[i - 1]) / (d01 + d12)\n        if (i == 1) {\n            // natural condition (i.e. second derivative must vanish)\n            prevSecantX = (3.0 * x01 / d01 - secantX) / 2.0\n            prevSecantY = (3.0 * y01 / d01 - secantY) / 2.0\n        } else if (i == length - 1) {\n            // natural condition (i.e. second derivative must vanish)\n            secantX = (3.0 * x01 / d01 - prevSecantX) / 2.0\n            secantY = (3.0 * y01 / d01 - prevSecantY) / 2.0\n        }\n        const control1X = xs[i - 1] + prevSecantX * d01 / 3.0\n        const control1Y = ys[i - 1] + prevSecantY * d01 / 3.0\n        const control2X = xs[i] - secantX * d01 / 3.0\n        const control2Y = ys[i] - secantY * d01 / 3.0\n        d += `C ${control1X} ${control1Y} ${control2X} ${control2Y} `\n           + `${xs[i]} ${ys[i]}`\n        prevSecantX = secantX\n        prevSecantY = secantY\n    }\n    return d\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Algebra\n\nfunction vectorAdd(v0, ...vs) {\n    v0 = Array.from(v0)\n    for (const v of vs) {\n        for (const [i, vi] of v.entries()) {\n            v0[i] += vi\n        }\n    }\n    return v0\n}\n\nfunction vectorSubtract(v0, ...vs) {\n    v0 = Array.from(v0)\n    for (const v of vs) {\n        for (const [i, vi] of v.entries()) {\n            v0[i] -= vi\n        }\n    }\n    return v0\n}\n\nfunction vectorDot(v1, v2) {\n    let s = 0\n    for (const i of v1.keys()) {\n        s += v1[i] * v2[i]\n    }\n    return s\n}\n\nfunction vectorSquare(v) {\n    return vectorDot(v, v)\n}\n\nfunction scalarMultiply(c, v) {\n    v = Array.from(v)\n    for (const i of v.keys()) {\n        v[i] *= c\n    }\n    return v\n}\n\n/** Galois field of order 2. */\nconst REAL_FIELD = {\n    ZERO: 0,\n    ONE: 1,\n    add: (x, y) => x + y,\n    subtract: (x, y) => x - y,\n    multiply: (x, y) => x * y,\n    divide: (x, y) => {\n        if (!y) {\n            throw new Error(\"division by zero\")\n        }\n        return x / y\n    },\n    eq: defaultEq,\n}\n\n/** Galois field of order 2. */\nconst GF2_FIELD = Object.assign({}, REAL_FIELD, {\n    add: bitXor,\n    subtract: bitXor,\n})\n\nfunction newSparseVectorType(eq, zero) {\n    eq = eq || defaultEq\n    zero = zero === undefined ? 0 : zero\n    return class SparseVector {\n        constructor(iterable) {\n            this.data = new Map()\n            if (iterable) {\n                for (const [k, v] of iterable) {\n                    this.set(k, v)\n                }\n            }\n        }\n\n        copy() {\n            return new SparseVector(this)\n        }\n\n        [Symbol.iterator]() {\n            return this.data.entries()\n        }\n\n        keys() {\n            return this.data.keys()\n        }\n\n        get(key) {\n            const data = this.data\n            return data.has(key) ? data.get(key) : zero\n        }\n\n        set(key, value) {\n            if (eq(value, zero)) {\n                this.delete(key)\n            } else {\n                this.data.set(key, value)\n            }\n        }\n\n        modify(key, f) {\n            this.set(key, f(this.get(key)))\n        }\n\n        delete(key) {\n            this.data.delete(key)\n        }\n\n        map(f) {\n            return new SparseVector(map(([k, x]) => [k, f(x, k)], this))\n        }\n\n        toTable(keys) {\n            keys = keys || this.keys()\n            let t = {}\n            for (const k of keys) {\n                t[k] = this.get(k)\n            }\n            return t\n        }\n    }\n}\n\nconst RealSparseVector = newSparseVectorType()\n\nfunction newSparseMatrixType(SparseVector) {\n    SparseVector = SparseVector || RealSparseVector\n    return class SparseMatrix {\n        constructor(iterable) {\n            this.data = new Map()\n            if (iterable) {\n                for (const [i, j, x] of iterable) {\n                    this.set(i, j, x)\n                }\n            }\n        }\n\n        copy() {\n            return new SparseMatrix(this)\n        }\n\n        * [Symbol.iterator]() {\n            for (const [i, row] of this.rows()) {\n                yield* map(([j, x]) => [i, j, x], row)\n            }\n        }\n\n        rows() {\n            return map(i => [i, this.row(i)], this.data.keys())\n        }\n\n        row(i) {\n            return cachedGet(this.data, i, () => new SparseVector())\n        }\n\n        rowKeys() {\n            return this.data.keys()\n        }\n\n        colKeys() {\n            let js = new Set()\n            for (const row of this.data.values()) {\n                for (const j of row.keys()) {\n                    js.add(j)\n                }\n            }\n            return js\n        }\n\n        get(i, j) {\n            return this.row(i).get(j)\n        }\n\n        set(i, j, x) {\n            this.row(i).set(j, x)\n        }\n\n        modify(i, j, f) {\n            this.set(i, j, f(this.get(i, j)))\n        }\n\n        deleteRow(i) {\n            this.data.delete(i)\n        }\n\n        map(f) {\n            return new SparseMatrix(map(([i, j, x]) => [i, j, f(x, j, i)], this))\n        }\n\n        toTable(rowKeys, colKeys) {\n            rowKeys = rowKeys || this.rowKeys()\n            colKeys = colKeys || Array.from(this.colKeys())\n            let t = {}\n            for (const i of rowKeys) {\n                t[i] = this.row(i).toTable(colKeys)\n            }\n            return t\n        }\n    }\n}\n\nconst RealSparseMatrix = newSparseMatrixType()\n\nfunction sparseMatrixVectorMultiply(rng, matrix, vector) {\n    let r = new vector.constructor()\n    for (const [i, row] of matrix.rows()) {\n        let s = rng.ZERO\n        for (const [j, x] of row) {\n            s = rng.add(s, rng.multiply(row.get(j), vector.get(j)))\n        }\n        r.set(i, s)\n    }\n    return r\n}\n\n/** Sparse Gaussian elimination over an arbitrary field. */\nfunction sparseGaussElim(field, matrix, vector) {\n    // we are going to seriously mangle these\n    matrix = matrix.copy()\n    vector = vector.copy()\n\n    let is = new Set(matrix.rowKeys())\n    let js = Array.from(matrix.colKeys()).reverse()\n    let unconstrained = []\n    let pivots = []\n\n    // we care about the keys in vector too!\n    for (const i of vector.keys()) {\n        is.add(i)\n    }\n\n    // perform Gaussian elimination to obtain row echelon form;\n    // note that we don't bother changing the pivot column to 1 and 0's\n    // as we won't really need them afterward\n    while (js.length) {\n        const jp = js.pop()\n        let ip = null\n        let xp\n        for (const i of is) {\n            xp = matrix.get(i, jp)\n            if (!field.eq(xp, field.ZERO)) {\n                ip = i\n                break\n            }\n        }\n        if (ip == null) {\n            unconstrained.push(jp)\n            continue\n        }\n        pivots.push([ip, jp])\n        is.delete(ip)\n        const invXp = field.divide(field.ONE, xp)\n        for (const j of js) {\n            matrix.modify(ip, j, x => field.multiply(invXp, x))\n        }\n        vector.modify(ip, x => field.multiply(invXp, x))\n        for (const i of is) {\n            const c = matrix.get(i, jp)\n            if (!field.eq(c, field.ZERO)) {\n                for (const j of js) {\n                    matrix.modify(i, j, x => field.subtract(\n                        x, field.multiply(c, matrix.get(ip, j))))\n                }\n                vector.modify(i, x => field.subtract(\n                    x, field.multiply(c, vector.get(ip))))\n            }\n        }\n    }\n\n    // check for consistency among remaining rows\n    let consistent = true\n    for (const i of is) {\n        if (!field.eq(vector.get(i), field.ZERO)) {\n            consistent = false // no consistent solution\n            break\n        }\n    }\n\n    let solution = new vector.constructor()\n    for (const j of js) {\n        solution.set(j, field.ZERO)\n    }\n    for (const j of unconstrained) {\n        solution.set(j, field.ZERO) // arbitrarily pick zero\n    }\n\n    // back substitution\n    pivots.reverse()\n    for (const [u, [i, k]] of pivots.entries()) {\n        let s = vector.get(i)\n        for (const [v, [_, j]] of pivots.entries()) {\n            if (v >= u) {\n                break\n            }\n            s = field.subtract(s, matrix.get(i, j) * solution.get(j))\n        }\n        solution.set(k, s)\n    }\n\n    return {\n        consistent: consistent,\n        solution: solution,\n        unconstrained: unconstrained,\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// DOM manipulation\n\nconst VNODE_KEY = Symbol(\"VNODE_KEY\")\nconst VNODE_SUSPEND_CHILDREN = Symbol(\"VNODE_SUSPEND_CHILDREN\")\nconst VNODE_SYMBOLS = Symbol(\"VNODE_SYMBOLS\")\nconst VNODE_EVENT_LISTENERS = Symbol(\"VNODE_EVENT_LISTENERS\")\n\nfunction vnodeGetSymbol(elem, key) {\n    return (elem[VNODE_SYMBOLS] || {})[key]\n}\n\nfunction vnodeAmendAttributes(attrs, elem) {\n    let listeners = elem[VNODE_EVENT_LISTENERS]\n    let unusedListeners = Object.assign({}, listeners)\n    const keys = Object.keys(attrs)\n    let i = keys.length\n    while (i--) {\n        const k = keys[i]\n        const v = attrs[k]\n        let m = /^on(.+)/.exec(k)\n        if (m) {\n            const event = m[1]\n            if (!listeners) {\n                listeners = {}\n                elem[VNODE_EVENT_LISTENERS] = listeners\n            }\n            let listener = listeners[event]\n            if (listener) {\n                delete unusedListeners[event]\n            } else {\n                listener = [undefined]\n                listeners[event] = listener\n                elem.addEventListener(event, function(e) {\n                    return listener[0].call(this, e)\n                })\n            }\n            listener[0] = v\n        } else if (v == null) {\n            elem.removeAttribute(k, v)\n        } else {\n            if (elem.getAttribute(k) != v) {\n                elem.setAttribute(k, v)\n            }\n        }\n    }\n    const symKeys = Object.getOwnPropertySymbols(attrs)\n    i = symKeys.length\n    while (i--) {\n        let symbols = elem[VNODE_SYMBOLS]\n        if (!symbols) {\n            symbols = {}\n            elem[VNODE_SYMBOLS] = symbols\n        }\n        const k = symKeys[i]\n        symbols[k] = attrs[k]\n    }\n    const unusedEvents = Object.keys(unusedListeners)\n    let j = unusedEvents.length\n    while (j--) {\n        const event = unusedEvents[j]\n        elem.removeEventListener(event, unusedListeners[event])\n    }\n}\n\nfunction vnodeRenderAttributes(attrs, elem) {\n    if (!attrs) {\n        return\n    }\n    let oldAttrs = elem.attributes\n    if (oldAttrs) {\n        let i = 0\n        while (i < oldAttrs.length) {\n            const oldAttr = oldAttrs[i]\n            const name = oldAttr.name\n            if (!attrs.hasOwnProperty(name) && oldAttr.ns == null) {\n                oldAttrs.removeNamedItem(name)\n            } else {\n                i += 1\n            }\n        }\n    }\n    delete elem[VNODE_SYMBOLS]\n    vnodeAmendAttributes(attrs, elem)\n}\n\nfunction vnodeRenderChildren(children, elem) {\n    if (!children) {\n        return\n    }\n    let oldChildren = elem.childNodes\n    if (!oldChildren) {\n        return\n    }\n    // fragment contains a queue of pending elements; if you're about\n    // to increment j without removing an old node, then you should\n    // flush this queue before moving on!\n    let fragment = document.createDocumentFragment()\n    let j = 0\n    for (let i = 0; i < children.length; ++i) {\n        let child = children[i]\n        let oldChild = oldChildren[j]\n        if (child instanceof Vnode) {\n            const key = child.attributes[VNODE_KEY]\n            if (key) {\n                // find matching node, if any\n                while (oldChild) {\n                    if (oldChild instanceof Element ||\n                        oldChild instanceof Text) {\n                        if ((oldChild[VNODE_SYMBOLS] || {})[VNODE_KEY] == key) {\n                            break\n                        }\n                        elem.removeChild(oldChild)\n                    } else {\n                        elem.insertBefore(fragment, oldChild)\n                        j += 1\n                    }\n                    oldChild = oldChildren[j]\n                }\n            } else if (oldChild && (oldChild[VNODE_SYMBOLS] || {})[VNODE_KEY]) {\n                // not a candidate for replacement; try again later\n                oldChild = null\n            }\n            if (oldChild) {\n                // found a candiate; can we update without replacing?\n                // (note: XML is case-sensitive; HTML is not)\n                if (oldChild instanceof HTMLElement\n                    ? (oldChild.nodeName.toLowerCase()\n                        == child.name.toLowerCase())\n                    : (oldChild.namespaceURI == child.namespace &&\n                       oldChild.nodeName == child.name)) {\n                    elem.insertBefore(fragment, oldChild)\n                    j += 1\n                    child.renderTo(oldChild)\n                    continue\n                } else {\n                    elem.removeChild(oldChild)\n                }\n            }\n            child = child.create()\n        } else if (typeof child == \"string\") {\n            if (oldChild instanceof Text) {\n                elem.insertBefore(fragment, oldChild)\n                j += 1\n                if (oldChild.nodeValue != child) {\n                    oldChild.nodeValue = child\n                }\n                continue\n            } else {\n                child = document.createTextNode(child)\n            }\n        }\n        fragment.appendChild(child)\n    }\n    // remove remaining nodes\n    while (j < oldChildren.length) {\n        let oldChild = oldChildren[j]\n        if (oldChild instanceof Element ||\n            oldChild instanceof Text) {\n            // this function is not re-entrant, so this could throw an exception\n            // if a blur event removes the child before we get a chance to;\n            // we work around this by serializing execution of applyRendering\n            elem.removeChild(oldChild)\n        } else {\n            j += 1\n        }\n    }\n    elem.appendChild(fragment)\n}\n\nclass Vnode {\n    constructor(namespace, name, attributes, children) {\n        this.namespace = namespace\n        this.name = name\n        this.attributes = attributes\n        this.children = children\n    }\n\n    // Copy the attributes and children to the given element.\n    // Note: the behavior is unspecified if the element is of a different name.\n    renderTo(elem) {\n        vnodeRenderAttributes(this.attributes, elem)\n        if (!this.attributes[VNODE_SUSPEND_CHILDREN]) {\n            vnodeRenderChildren(this.children, elem)\n        }\n    }\n\n    create() {\n        const namespace = this.namespace\n        let elem = namespace\n                 ? document.createElementNS(namespace, this.name)\n                 : document.createElement(this.name)\n        this.renderTo(elem)\n        return elem\n    }\n}\n\nconst NAMESPACES = {\n    svg: \"http://www.w3.org/2000/svg\",\n    xlink: \"http://www.w3.org/1999/xlink\",\n}\n\nfunction parseNamespace(name) {\n    let namespace = null\n    const m = /([^:]+):(.+)/.exec(name)\n    if (m && NAMESPACES.hasOwnProperty(m[1])) {\n        namespace = NAMESPACES[m[1]]\n        name = m[2]\n    }\n    return [namespace, name]\n}\n\nfunction vnode(name, attributes, ...children) {\n    let namespace\n    ;[namespace, name] = parseNamespace(name)\n    return new Vnode(namespace, name, attributes, children)\n}\n\nlet renderQueue = []\nfunction applyRendering(rendering) {\n    // work around the lack of re-entrancy\n    renderQueue.push(rendering)\n    if (renderQueue.length != 1) {      // we are not alone\n        return\n    }\n    while (renderQueue.length) {\n        const rendering = renderQueue[0]\n        rendering.forEach(spec => {\n            const elem = spec.element\n            if (!elem) {\n                throw new Error(\"invalid elem\")\n            }\n            if (spec.attributes) {\n                vnodeAmendAttributes(spec.attributes, elem)\n            }\n            vnodeRenderChildren(spec.children, elem)\n        })\n        renderQueue.shift()\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Deltas\n//\n// Without qualification, \"deltas\" refer to Kronecker deltas involving\n// magnitudes (j), not projections (m).\n//\n// Each delta is an array of at least two magnitude variables.\n// Within a given list of deltas, the variables must be all distinct.\n\n/** Merges the given deltas and simplifies the result. */\nexport function mergeDeltas(...deltaLists) {\n    let finalDeltas = []\n    let finder = {} // {[entry]: [deltas]} (singleton list)\n    deltaLists.forEach(deltas => deltas.forEach(delta => {\n        if (delta.length < 2) {\n            return\n        }\n        let found = null\n        for (let i = 0; i < delta.length; ++i) {\n            found = finder[delta[i]]\n            if (found) {\n                break\n            }\n        }\n        if (found == null) {\n            found = [[]]\n            finalDeltas.push(found[0])\n        }\n        delta.forEach(x => {\n            const exists = finder[x]\n            if (!exists) {\n                found[0].push(x)\n                finder[x] = found\n            } else if (exists[0] != found[0]) {\n                // merge deltas\n                found[0].push(...exists[0])\n                exists[0].splice(0, exists[0].length)\n                exists[0] = found[0]\n            }\n        })\n    }))\n    // remove the husks\n    return Object.freeze(finalDeltas.map(Object.freeze)\n                                    .filter(delta => delta.length > 1))\n}\n\n/** Tests whether the 'subdeltas' is a subset of (implied by) 'deltas'. */\nexport function containsDeltas(deltas, subdeltas) {\n    deltas = mergeDeltas(deltas)\n    subdeltas = mergeDeltas(subdeltas)\n    let finder = {}\n    deltas.forEach(delta => delta.forEach(x =>\n        finder[x] = delta\n    ))\n    for (let j = 0; j < subdeltas.length; ++j) {\n        const subdelta = subdeltas[j]\n        let found = null\n        for (let i = 0; i < subdelta.length; ++i) {\n            found = finder[subdelta[i]]\n            if (found) {\n                break\n            }\n        }\n        if (found) {\n            for (let i = 0; i < subdelta.length; ++i) {\n                if (finder[subdelta[i]] != found) {\n                    return false\n                }\n            }\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunction equalDeltas(deltas1, deltas2) {\n    return containsDeltas(deltas1, deltas2) && containsDeltas(deltas2, deltas1)\n}\n\nfunction findDeltaEntry(deltas, entry) {\n    for (let j = 0; j < deltas.length; ++j) {\n        for (let i = 0; i < deltas[j].length; ++i) {\n            if (deltas[j][i] == entry) {\n                return [j, i]\n            }\n        }\n    }\n    return null\n}\n\nexport function relatedDelta(deltas, entry) {\n    const ji = findDeltaEntry(deltas, entry)\n    if (!ji) {\n        return [entry]\n    }\n    const [j, i] = ji\n    return [entry].concat(arrayRemoveMany(deltas[j], [i]))\n}\n\n/** Warning: this may not preserve the diagram! */\nexport function removeDeltaEntry(deltas, entry) {\n    const ji = findDeltaEntry(deltas, entry)\n    if (!ji) {\n        return deltas\n    }\n    const [j, i] = ji\n    return Object.freeze(Object.assign([], deltas, {\n        [j]: Object.freeze(arrayRemoveMany(deltas[j], [i])),\n    })).filter(delta => delta.length > 1)\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Superlines\n//\n// Superlines are just magnitudes (j).\n\nexport const EMPTY_SUPERLINE = Object.freeze({\n    phase: 0,\n    summed: false,\n    weight: 0,\n})\n\n/** Convert a superline-like object into a proper superline. */\nfunction ensureSuperline(superline) {\n    return Object.freeze(Object.assign({}, EMPTY_SUPERLINE, superline))\n}\n\n/** Increment the numeric suffix of a string by one.  If there is no suffix,\n   `1` is appended. */\nfunction newLabel(label) {\n    const match = /^([\\s\\S]*?)(\\d*)$/.exec(label)\n    return match[1] + (Number(match[2]) + 1).toString()\n}\n\n/** Generate `count` fresh labels. */\nfunction availLabels(obj) {\n    // avoid \"0\", which is reserved for the actual zero\n    return filter(i => !obj.hasOwnProperty(i),\n                  map(i => i.toString(),\n                      range(1, Number.POSITIVE_INFINITY)))\n}\n\n/** Generate `count` fresh superline labels. */\nfunction availSuperlineLabels(diagram) {\n    let labels = Object.assign({}, diagram.superlines)\n    for (const delta of diagram.deltas) {\n        for (const x of delta) {\n            labels[x] = true\n        }\n    }\n    return availLabels(labels)\n}\n\nfunction isEmptySuperline(superline) {\n    return !superline.phase && !superline.summed && !superline.weight\n}\n\n/** Avoid using this function because it doesn't handle zero lines. */\nfunction mergeSuperlines(...superlines) {\n    let finalSuperline = Object.assign({}, EMPTY_SUPERLINE)\n    superlines.forEach(superline => {\n        finalSuperline.phase = mod(finalSuperline.phase\n                                 + (superline.phase || 0), 4)\n        finalSuperline.weight += superline.weight || 0\n        if (superline.summed != null) {\n            finalSuperline.summed = superline.summed\n        }\n    })\n    return Object.freeze(finalSuperline)\n}\n\nfunction mergeSuperlineLists(...superlineLists) {\n    let finalSuperlines = {}\n    for (const superlines of superlineLists) {\n        for (const id of Object.keys(superlines)) {\n            if (id == \"0\") {\n                finalSuperlines[id] = EMPTY_SUPERLINE\n                continue\n            }\n            const finalSuperline = finalSuperlines[id]\n            let superline = superlines[id]\n            if (finalSuperline) {\n                superline = mergeSuperlines(finalSuperline, superline)\n            }\n            finalSuperlines[id] = superline\n        }\n    }\n    for (const id of Object.keys(finalSuperlines)) {\n        if (id.phase == 0 && id.weight == 0 && !id.summed) {\n            delete finalSuperlines[id]\n        }\n    }\n    return Object.freeze(finalSuperlines)\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Line manipulation\n\n// type Line = {\n//   superline: String,\n//   direction: -1 (left) | 0 | 1 (right),\n//   arrowPos: 0.0 (left) to 1.0 (right),\n//   arcHeight: -INF to INF, (sagitta, + is downward)\n//   angle: 0 to 2PI, (of the direct line, clockwise)\n//   textPos: 0.0 (left) to 1.0 (right),\n//   textOffset: -INF to INF, (+ is downward)\n// }\n//\n// The angle is usually ignored, but if the ratio of arcHeight to lineLength\n// is too big, then 'angle' is used to break the degeneracy.\n//\n// In general, \"pos\" refers to a relative position on a line, with 0.0 being\n// the leftmost point and 1.0 the rightmost.\n\nconst ZERO_LINE = Object.freeze({\n    superline: \"0\",\n    direction: 0,\n    arrowPos: 0.5,\n    arcHeight: 0.0,\n    angle: 0.0,\n    textPos: 0.5,\n    textOffset: 0.0,\n})\n\nexport function newLine(superlineId) {\n    return ensureLine({superline: superlineId})\n}\n\nfunction ensureLine(line) {\n    return Object.freeze(Object.assign({}, ZERO_LINE, line))\n}\n\nfunction reverseLineDirection(line) {\n    return Object.freeze(Object.assign({}, line, {direction: -line.direction}))\n}\n\nfunction reverseLine(line) {\n    line = Object.assign({}, line)\n    if (line.direction != null) {\n        line.direction = -line.direction\n    }\n    if (line.arrowPos != null) {\n        line.arrowPos = 1.0 - line.arrowPos\n    }\n    if (line.arcHeight != null) {\n        line.arcHeight = -line.arcHeight\n    }\n    if (line.angle != null) {\n        line.angle = mod(line.angle + Math.PI, 2 * Math.PI)\n    }\n    if (line.textPos != null) {\n        line.textPos = 1.0 - line.textPos\n    }\n    if (line.textOffset != null) {\n        line.textOffset = -line.textOffset\n    }\n    return Object.freeze(line)\n}\n\nfunction isLineDirectable(line) {\n    return line.superline == \"0\" || mod(line.direction, 2) == 1\n}\n\nfunction mergeDirections(...directions) {\n    return mod(sum(directions) + 1, 4) - 1\n}\n\n/** Beware: this may result in a noncanonical line!\n *\n * Because of averaging, addition isn't quite associative with respect to the\n * superficial attributes.\n *\n * All lines must agree in superline.\n */\nfunction rawConcatLines(...lines) {\n    const n = lines.length\n    const avgProps = [\"arrowPos\", \"arcHeight\",\n                      \"textPos\", \"textOffset\"]\n    let finalLine = {}\n    let sinAngle = 0.0\n    let cosAngle = 0.0\n    let numAngles = 0\n    let counts = {}\n    for (const prop of avgProps) {\n        counts[prop] = 0\n    }\n    for (const [i, line] of lines.entries()) {\n        if (i == 0) {\n            finalLine.superline = line.superline\n        } else if (finalLine.superline != line.superline) {\n            throw new Error(\"cannot add lines with different superlines\")\n        }\n        if (line.direction != null) {\n            if (finalLine.direction == null) {\n                finalLine.direction = 0\n            }\n            finalLine.direction =\n                mergeDirections(finalLine.direction, line.direction)\n        }\n        for (const prop of avgProps) {\n            if (line[prop] != null) {\n                if (finalLine[prop] == null) {\n                    finalLine[prop] = 0\n                }\n                finalLine[prop] += line[prop]\n                counts[prop] += 1\n            }\n        }\n        if (line.angle != null) {\n            sinAngle += Math.sin(line.angle)\n            cosAngle += Math.cos(line.angle)\n            numAngles += 1\n        }\n    }\n    for (const prop of avgProps) {\n        if (counts[prop]) {\n            finalLine[prop] /= counts[prop]\n        }\n    }\n    if (numAngles) {\n        finalLine.angle = Math.atan2(sinAngle, cosAngle)\n    }\n    return Object.freeze(finalLine)\n}\n\n/** Like `rawConcatLines`, but does canonicalization and converts conflicting\n * superlines into a delta. */\nfunction concatLines(...lines) {\n    const canonicalized = canonicalizeLine(rawConcatLines(\n        ...lines.map(line => Object.assign({}, line, {\n            superline: lines[0].superline,\n        }))))\n    return {\n        line: canonicalized.line,\n        phase: canonicalized.phase,\n        delta: lines.map(line => line.superline), // duplicates are fine\n    }\n}\n\nfunction canonicalizeLine(line) {\n    let direction = line.direction % 2\n    let phase = mod(Math.trunc(line.direction / 2), 2) * 2\n    if (line.superline == \"0\") {\n        direction = 0\n        phase = 0\n    }\n    return {\n        line: Object.freeze(Object.assign({}, line, {direction: direction})),\n        phase: phase,\n    }\n}\n\nfunction joinLines(line1, reverse1, line2, reverse2) {\n    line1 = (reverse1 ? reverseLine : identity)(line1)\n    line2 = (reverse2 ? reverseLine : identity)(line2)\n    const superlines = [line1.superline, line2.superline].sort(defaultCmp)\n    line1 = Object.assign({}, line1, {superline: superlines[0]})\n    line2 = Object.assign({}, line1, {superline: superlines[0]})\n    return Object.assign(canonicalizeLine(rawConcatLines(line1, line2)), {\n        otherSuperline: superlines[1]\n    })\n}\n\nfunction getLineInfoBetween(x0, y0, x1, y1, line) {\n    const xMid = (x0 + x1) / 2\n    const yMid = (y0 + y1) / 2\n    let dx = x1 - x0\n    let dy = y1 - y0\n    let lineLength = Math.sqrt(dx * dx + dy * dy)\n    const singular = lineLength == 0.0\n    const trueAngle = Math.atan2(dy, dx)\n    let angle = trueAngle\n    let arcHeight = line.arcHeight\n    // an semiarbitrary sign used to pick a consistent side on lines even\n    // when the line is reversed\n    const halfDisk = mod(line.angle + Math.PI / 2, 2 * Math.PI) < Math.PI\n                   ? -1 : 1\n    if (singular) {\n        // fudge numbers to avoid singularity\n        // (epsilon can't be too small or the SVG rendering becomes jittery)\n        const epsilon = 1e-2\n        dx = epsilon * Math.cos(line.angle)\n        dy = epsilon * Math.sin(line.angle)\n        x0 = xMid - 0.5 * dx\n        y0 = yMid - 0.5 * dy\n        x1 = xMid + 0.5 * dx\n        y1 = yMid + 0.5 * dy\n        lineLength = epsilon\n        angle = line.angle\n        arcHeight = arcHeight == 0.0\n                  ? 50.0 * halfDisk\n                  : sgn(arcHeight) * clamp(50.0, Infinity, Math.abs(arcHeight))\n    }\n    const arc = arcInfo(lineLength, arcHeight)\n    const c = (arc.radius - arcHeight) / lineLength\n    const xCenter = xMid + c * dy\n    const yCenter = yMid - c * dx\n    const arcEx = {\n        xCenter: xCenter,\n        yCenter: yCenter,\n        startAngle: Math.atan2(y0 - yCenter, x0 - xCenter),\n    }\n    return {\n        x0: x0,\n        y0: y0,\n        x1: x1,\n        y1: y1,\n        xMid: xMid,\n        yMid: yMid,\n        dx: dx,\n        dy: dy,\n        angle: angle,\n        trueAngle: trueAngle,\n        lineLength: lineLength,\n        singular: singular,\n        line: line,\n        halfDisk: halfDisk,\n        arcHeight: arcHeight,\n        arc: Object.assign(arc, arcEx),\n    }\n}\n\n/** Calculate geometric information about a line. */\nfunction getLineInfo(diagram, lineId) {\n    const line = diagram.lines[lineId]\n    const ends = endNodeIndices(diagram.nodes, lineId)\n    const node0 = diagram.nodes[ends[0]]\n    const node1 = diagram.nodes[ends[1]]\n    return Object.assign({\n        external: [node0.type, node1.type].includes(\"terminal\"),\n    }, getLineInfoBetween(node0.x, node0.y, node1.x, node1.y, line))\n}\n\n/** Find the closest \"pos\" on a line. */\nfunction findPosOnLine(lineInfo, x, y) {\n    let pos, offset\n    if (lineInfo.arcHeight == 0.0) {\n        const rx = x - lineInfo.x0\n        const ry = y - lineInfo.y0\n        pos = (lineInfo.dx * rx + lineInfo.dy * ry)\n        / Math.pow(lineInfo.lineLength, 2)\n        // left-handed coordinate system!\n        offset = -(rx * lineInfo.dy - ry * lineInfo.dx) / lineInfo.lineLength\n    } else {\n        const arc = lineInfo.arc\n        const rx = x - arc.xCenter\n        const ry = y - arc.yCenter\n        const cycle = Math.abs(Math.PI / arc.inclination)\n        const rawAngle = arc.startAngle - Math.atan2(ry, rx)\n        const shift = 0.5 * cycle - 0.5 // remove the bias toward pos = 1.0\n        pos = mod(rawAngle / (2 * arc.inclination) + shift, cycle) - shift\n        offset = (Math.sqrt(rx * rx + ry * ry) - Math.abs(arc.radius))\n        * sgn(lineInfo.arcHeight)\n    }\n    return {\n        pos: pos,\n        offset: offset,\n    }\n}\n\n/** Translate from a relative \"pos\" to absolute (x, y) coordinates.  `shift`\n * specifies an extra shift in absolute coordinates along the line. */\nfunction positionOnLine(lineInfo, pos, shift) {\n    const arc = lineInfo.arc\n    if (lineInfo.arcHeight == 0.0) {\n        const lineLength = lineInfo.lineLength\n        const newPos = pos + shift / lineLength\n        return {\n            x: lineInfo.x0 + lineInfo.dx * newPos,\n            y: lineInfo.y0 + lineInfo.dy * newPos,\n            normalX: -lineInfo.dy / lineLength,\n            normalY: lineInfo.dx / lineLength,\n            tangentAngle: lineInfo.angle,\n        }\n    } else {\n        const localAngle = 2 * arc.inclination * pos + shift / arc.radius\n        const tangentAngle = lineInfo.angle + arc.inclination - localAngle\n        const normalAngle = tangentAngle + Math.PI / 2\n        const normalX = Math.cos(normalAngle)\n        const normalY = Math.sin(normalAngle)\n        return {\n            x: arc.xCenter + arc.radius * normalX,\n            y: arc.yCenter + arc.radius * normalY,\n            normalX: normalX,\n            normalY: normalY,\n            tangentAngle: tangentAngle,\n        }\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Node manipulation\n\n/** Create a terminal node. */\nexport function terminalNode(lineId, variable, x, y) {\n    // every terminal has an associated name for the \"m\" variable;\n    // because this variable is *free*, rules must never change this variable!\n    // (you are free to rename the lineId whatever you want, but try to reuse\n    // the user's naming if possible)\n    //\n    // when rendering lines connected to terminal(s), be aware that the name(s)\n    // on the terminal(s) *supersede* the name of the line itself (lineId); if\n    // there are two terminals, then an m-delta is implied (this is how we\n    // represent m-deltas)\n    let node = {\n        type: \"terminal\",\n        lines: Object.freeze([lineId]),\n        variable: variable,\n    }\n    if (x != null) {\n        node.x = x\n    }\n    if (y != null) {\n        node.y = y\n    }\n    return Object.freeze(node)\n}\n\n/** Create a Wigner 3-jm node. */\nexport function w3jNode(a, b, c, x, y) {\n    let node = {\n        type: \"w3j\",\n        lines: Object.freeze([a, b, c]),\n    }\n    if (x !== undefined) {\n        node.x = x\n    }\n    if (y !== undefined) {\n        node.y = y\n    }\n    return Object.freeze(node)\n}\n\nfunction endNodeAndLineIndices(nodes, lineId) {\n    let nodeAndLineIndices = []\n    if (lineId == null) {\n        throw new Error(\"lineId must not be null / undefined\")\n    }\n    const numNodes = nodes.length\n    for (let nodeIndex = 0; nodeIndex < numNodes; ++nodeIndex) {\n        const lines = nodes[nodeIndex].lines\n        const numLines = lines.length\n        for (let lineIndex = 0; lineIndex < numLines; ++lineIndex) {\n            const nodeLineId = lines[lineIndex]\n            if (nodeLineId == lineId) {\n                nodeAndLineIndices.push([nodeIndex, lineIndex])\n            }\n        }\n    }\n    if (nodeAndLineIndices.length != 2) {\n        throw new Error(\"line must be connected at 2 points, \"\n                      + `not ${nodeAndLineIndices.length}`)\n    }\n    return nodeAndLineIndices\n}\n\nfunction endNodeIndices(nodes, lineId) {\n    return endNodeAndLineIndices(nodes, lineId).map(x => x[0])\n}\n\nfunction otherNodeAndLineIndex(nodes, nodeIndex, lineIndex) {\n    const lineId = nodes[nodeIndex].lines[lineIndex]\n    if (lineId === undefined) {\n        throw new Error(`cannot find line with lineIndex = ${lineIndex}`)\n    }\n    let nodeAndLineIndices = endNodeAndLineIndices(nodes, lineId)\n    if (lexicalCmp(nodeAndLineIndices[0],\n                   [nodeIndex, lineIndex],\n                   defaultCmp) == 0) {\n        return nodeAndLineIndices[1]\n    } else {\n        return nodeAndLineIndices[0]\n    }\n}\n\nfunction otherNodeIndex(nodes, nodeIndex, lineIndex) {\n    return otherNodeAndLineIndex(nodes, nodeIndex, lineIndex)[0]\n}\n\nfunction isLeftOfLine(nodes, nodeIndex, lineIndex) {\n    return lexicalCmp(otherNodeAndLineIndex(nodes, nodeIndex, lineIndex),\n                      [nodeIndex, lineIndex], defaultCmp) > 0\n}\n\nfunction nearestNodeIndices(nodes, count, x, y) {\n    return nodes\n        .map((node, nodeIndex) => ({\n            distance: Math.pow(x - node.x, 2) + Math.pow(y - node.y, 2),\n            index: nodeIndex\n        }))\n        .sort((x, y) => x.distance - y.distance)\n        .slice(0, count)\n        .map(node => node.index)\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Diagram manipulation\n//\n// NOTE: must maintain invariant that terminals precede all other nodes.\n// Also, the order of nodes is critical!  If you move the nodes around,\n// make sure the lines are also reversed.\n\nexport const EMPTY_DIAGRAM = Object.freeze({\n    nodes: Object.freeze([]),\n    superlines: Object.freeze({}),\n    lines: Object.freeze({}),\n\n    // each entry is an array of j's that are equal to each other\n    deltas: Object.freeze([]),\n})\n\nexport function ensureDiagram(diagram) {\n    return Object.freeze(Object.assign({}, EMPTY_DIAGRAM, diagram))\n}\n\nfunction w3jDiagram(a, b, c, x, y) {\n    if (a == b || b == c || c == a) {\n        throw new Error(\"cannot create w3jDiagram with conflicting labels\")\n    }\n    return ensureDiagram({\n        nodes: Object.freeze([\n            terminalNode(a, a, x - 50, y + 50),\n            terminalNode(b, b, x + 50, y + 50),\n            terminalNode(c, c, x, y - 70),\n            w3jNode(a, b, c, x, y),\n        ]),\n        lines: Object.freeze({\n            [a]: newLine(a),\n            [b]: newLine(b),\n            [c]: newLine(c),\n        }),\n        superlines: Object.freeze({\n            [a]: EMPTY_SUPERLINE,\n            [b]: EMPTY_SUPERLINE,\n            [c]: EMPTY_SUPERLINE,\n        }),\n    })\n}\n\nfunction cgDiagram(a, b, c, x, y) {\n    const diagram = w3jDiagram(a, b, c, x, y)\n    return Object.freeze(Object.assign({}, diagram, {\n        nodes: Object.freeze(Object.assign([], diagram.nodes, {\n            [3]: Object.freeze(Object.assign({}, diagram.nodes[3], {\n                lines: Object.freeze([a, c, b]),\n            })),\n        })),\n        lines: Object.freeze(Object.assign({}, diagram.lines, {\n            [c]: Object.freeze(Object.assign({}, diagram.lines[c], {\n                direction: 1,\n            })),\n        })),\n        superlines: Object.freeze(Object.assign({}, diagram.superlines, {\n            [b]: Object.freeze(Object.assign({}, diagram.superlines[b], {\n                phase: 2,\n            })),\n            [c]: Object.freeze(Object.assign({}, diagram.superlines[c], {\n                weight: 1,\n            })),\n        })),\n    }))\n}\n\nfunction setDiagramLineProps(diagram, lineId, props) {\n    const lines = diagram.lines\n    return Object.freeze(Object.assign({}, diagram, {\n        lines: Object.freeze(Object.assign({}, lines, {\n            [lineId]: Object.freeze(Object.assign({}, lines[lineId], props)),\n        })),\n    }))\n}\n\nfunction setDiagramNodeProps(diagram, nodeIndex, props) {\n    const nodes = diagram.nodes\n    return Object.freeze(Object.assign({}, diagram, {\n        nodes: Object.freeze(Object.assign([], nodes, {\n            [nodeIndex]: Object.freeze(Object.assign({}, nodes[nodeIndex],\n                                                     props)),\n        }))\n    }))\n}\n\nfunction lineAngle(diagram, nodeIndex, lineIndex) {\n    const node = diagram.nodes[nodeIndex]\n    const lineId = node.lines[lineIndex]\n    const line = diagram.lines[lineId]\n    const lineInfo = getLineInfo(diagram, lineId)\n    const reverse = Number(isLeftOfLine(diagram.nodes, nodeIndex, lineIndex))\n    const baseAngle = (lineInfo.singular ? line.angle : lineInfo.angle)\n                    + reverse * Math.PI\n    const sign = reverse ? 1 : -1\n    return baseAngle + sign * lineInfo.arc.inclination\n}\n\nfunction w3jOrientation(diagram, nodeIndex) {\n    const node = diagram.nodes[nodeIndex]\n    if (node.type != \"w3j\") {\n        throw new Error(\"cannot get orientation of generic node\")\n    }\n    const lines = node\n        .lines\n        .map((_, lineIndex) => {\n            const angle = lineAngle(diagram, nodeIndex, lineIndex)\n            return [lineIndex, mod(angle, 2 * Math.PI)]\n        })\n        .sort((line1, line2) => line1[1] - line2[1])\n        .map(([x, _]) => x)\n    return permutSign([0, 1, 2], lines)\n}\n\nfunction mergeDiagrams(diagram1, diagram2) {\n    let diagram = deepClone(diagram1)\n    diagram.superlines = mergeSuperlineLists(diagram1.superlines,\n                                             diagram2.superlines)\n    let renames = {}\n    Object.keys(diagram2.lines).forEach(function(lineId) {\n        let newLineId = lineId\n        while (diagram.lines.hasOwnProperty(newLineId)) {\n            // name collision\n            newLineId = newLabel(newLineId)\n        }\n        renames[lineId] = newLineId\n        diagram.lines[newLineId] = diagram2.lines[lineId]\n    })\n    let terminals = []\n    diagram2.nodes.forEach(function(node) {\n        node = Object.assign({}, node, {\n            lines: node.lines.map(lineId => renames[lineId]),\n        })\n        if (node.type == \"terminal\") {\n            terminals.push(node)\n        } else {\n            diagram.nodes.push(node)\n        }\n    })\n    diagram.nodes = terminals.concat(diagram.nodes)\n    return diagram\n}\n\nfunction isSuperlineExposed(diagram, superlineId) {\n    for (const node of diagram.nodes) {\n        if (node.type == \"terminal\" &&\n            diagram.lines[node.lines[0]].superline == superlineId) {\n            return true\n        }\n    }\n    return false\n}\n\nfunction joinTerminals(diagram, terminalIndex1, terminalIndex2) {\n    diagram = new Diagram(diagram)\n    const terminal1 = diagram.node(terminalIndex1)\n    const terminal2 = diagram.node(terminalIndex2)\n    if (terminal1.type != \"terminal\" || terminal2.type != \"terminal\") {\n        throw \"cannot join non-terminals\"\n    }\n    const line1 = terminal1.line(0)\n    const line2 = terminal2.line(0)\n    let newDiagram = deepClone(diagram.rawDiagram)\n    if (line1.id == line2.id) {\n        if (line1.direction != 0) {\n            return \"cannot form a directed loop\"\n        }\n        newDiagram.superlines[line1.superlineId].weight += 2\n    } else {\n        // TODO can we abstract out this pattern? we do this a lot\n        const combined = concatLines(line1.reverse().line, line2.line)\n        const f = lexicalCmp([line1.node(1).index, line1.lineIndex(1)],\n                             [line2.node(1).index, line2.lineIndex(1)],\n                             defaultCmp) > 0\n                ? reverseLine : identity\n        newDiagram.lines[line1.id] = f(combined.line)\n        line2.rawAssign(newDiagram, 1, line1.id)\n        if (line1.superlineId != line2.superlineId) {\n            newDiagram.superlines[line1.superlineId] = mergeSuperlines(\n                line2.superline,\n                line1.superline,\n                {phase: combined.phase})\n            newDiagram.superlines[line2.superlineId] = EMPTY_SUPERLINE\n        }\n        newDiagram.deltas = mergeDeltas(newDiagram.deltas, [combined.delta])\n    }\n    delete newDiagram.lines[line2.id]\n    newDiagram.nodes = arrayRemoveMany(newDiagram.nodes,\n                                       [terminal1.index, terminal2.index])\n    return new Diagram(newDiagram).removeUnusedSuperlines().rawDiagram\n}\n\nfunction addW1j(diagram, lineId) {\n    diagram = deepClone(diagram)\n    let line = diagram.lines[lineId]\n    // cycle through all possible directions\n    if (line.direction > 0) {\n        line.direction = -1\n    } else if (line.direction < 0) {\n        line.direction = 0\n    } else {\n        line.direction = 1\n    }\n    return diagram\n}\n\nfunction add2j(diagram, lineId) {\n    diagram = new Diagram(diagram)\n    return diagram.substitute({}, {\n        [diagram.line(lineId).superlineId]: {phase: 2}\n    }).rawDiagram\n}\n\nfunction flipW3j(diagram, nodeIndex) {\n    if (diagram.nodes[nodeIndex].type != \"w3j\") {\n        return diagram\n    }\n    diagram = deepClone(diagram)\n    let lines = diagram.nodes[nodeIndex].lines\n    lines.reverse()\n    for (let i = 0; i < 3; ++i) {\n        if (lines[i] == lines[(i + 1) % 3]) {\n            diagram.lines[lines[i]] = reverseLine(diagram.lines[lines[i]])\n            break\n        }\n    }\n    return diagram\n}\n\nfunction isDanglingSuperline(diagram, superlineId) {\n    const lineIds = Object.keys(diagram.lines)\n    let i = lineIds.length\n    while (i--) {\n        if (diagram.lines[lineIds[i]].superline == superlineId) {\n            return false\n        }\n    }\n    return true\n}\n\nfunction deleteNode(diagram, nodeIndex) {\n    diagram = deepClone(diagram)\n    const node = diagram.nodes[nodeIndex]\n    if (node.type == \"terminal\") {\n        const otherIndex = otherNodeIndex(diagram.nodes, nodeIndex, 0)\n        if (diagram.nodes[otherIndex].type != \"terminal\") {\n            throw new Error(\"cannot delete terminal of node\")\n        }\n        const superlineId = diagram.lines[node.lines[0]].superline\n        delete diagram.lines[node.lines[0]]\n        if (isDanglingSuperline(diagram, superlineId)) {\n            delete diagram.superlines[superlineId]\n        }\n        diagram.nodes = arrayRemoveMany(diagram.nodes, [nodeIndex, otherIndex])\n    } else {\n        let terminals = []\n        node.lines.forEach(function(lineId, lineIndex) {\n            const otherIndex = otherNodeIndex(diagram.nodes, nodeIndex, lineIndex)\n            if (otherIndex == nodeIndex) {\n                const line = diagram.lines[lineId]\n                if (!line) {\n                    return\n                }\n                delete diagram.lines[lineId]\n                const superlineId = line.superline\n                if (isDanglingSuperline(diagram, superlineId)) {\n                    delete diagram.superlines[superlineId]\n                }\n                return\n            }\n            if (otherIndex < nodeIndex) {\n                diagram.lines[lineId] = reverseLine(diagram.lines[lineId])\n            }\n            terminals.push(terminalNode(lineId, lineId, node.x, node.y))\n        })\n        diagram.nodes.splice(nodeIndex, 1)\n        diagram.nodes = terminals.concat(diagram.nodes)\n    }\n    return diagram\n}\n\n/** Examine the diagram to see if there are any deltas that are immediately\n * obvious from its topology. */\nfunction inferDeltas(diagram) {\n    let deltas = []\n    let knownZeros = new Set([\"0\"])\n    diagram = new Diagram(diagram)\n    for (const node of diagram.nodes()) {\n        const loop = findW3jLoop(node)\n        if (typeof loop == \"object\") {\n            if (loop.loopLine.direction % 2) {\n                knownZeros.add(loop.cutLine.superlineId)\n            }\n        }\n        if (node.type == \"w3j\") {\n            for (const line of node.lines()) {\n                if (knownZeros.has(line.superlineId)) {\n                    deltas.push([line.cycNodeLine(0, 1).superlineId,\n                                 line.cycNodeLine(0, 2).superlineId])\n                    break\n                }\n            }\n        }\n    }\n    deltas.push(Array.from(knownZeros))\n    return deltas\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Diagrammatic rules\n//\n// We distinguish between transformations used for editing (which generally\n// do not preserve the semantics) and transformations used for derivations\n// that always preserve equivalence.  The latter are called \"rules\".\n\nfunction flipW3jRule(diagram, nodeIndex) {\n    if (diagram.nodes[nodeIndex].type != \"w3j\") {\n        return diagram\n    }\n    diagram = deepClone(flipW3j(diagram, nodeIndex))\n    diagram.nodes[nodeIndex].lines.forEach(lineId =>\n        diagram.superlines = mergeSuperlineLists(diagram.superlines, {\n            [diagram.lines[lineId].superline]: {phase: 1},\n        }))\n    return diagram\n}\n\nfunction flipW1jRule(diagram, lineId) {\n    if (diagram.lines[lineId].superline == \"0\") {\n        diagram = deepClone(diagram)\n        diagram.lines[lineId].direction =\n            (diagram.lines[lineId].direction + 2) % 3 - 1\n    } else if (diagram.lines[lineId].direction) {\n        diagram = deepClone(diagram)\n        diagram.lines[lineId].direction *= -1\n        diagram.superlines = mergeSuperlineLists(diagram.superlines, {\n            [diagram.lines[lineId].superline]: {phase: 2}})\n    }\n    return diagram\n}\n\nfunction threeArrowRule(diagram, nodeIndex) {\n    const oldDiagram = new Diagram(diagram)\n    diagram = deepClone(diagram)\n    let node = diagram.nodes[nodeIndex]\n    if (node.type != \"w3j\") {\n        return diagram\n    }\n    const loop = findW3jLoop(oldDiagram.node(nodeIndex))\n    let loopId = null\n    if (typeof loop == \"object\") {\n        loopId = loop.loopLine.id\n    }\n\n    let direction = 0\n    // figure out the direction that would minimize the phase change\n    node.lines.forEach(function(lineId, lineIndex) {\n        const line = diagram.lines[lineId]\n        if (isLeftOfLine(diagram.nodes, nodeIndex, lineIndex)) {\n            direction -= line.direction\n        } else {\n            direction += line.direction\n        }\n    })\n    if (direction == 0) {\n        // we still don't have a direction, so let's just pick \"outgoing\"\n        direction = 1\n    } else if (direction == -3) {\n        // if all outgoing, completely reverse the direction\n        direction = -2\n    } else {\n        // normalize to one\n        direction = direction / Math.abs(direction)\n    }\n    node.lines.forEach(function(lineId, lineIndex) {\n        let line = Object.assign({}, diagram.lines[lineId])\n        if (isLeftOfLine(diagram.nodes, nodeIndex, lineIndex)) {\n            line.direction += direction\n        } else {\n            line.direction -= direction\n        }\n        diagram.lines[lineId] = line\n    })\n    node.lines.forEach(function(lineId, lineIndex) {\n        const line = diagram.lines[lineId]\n        const canonicalized = canonicalizeLine(line)\n        diagram.lines[lineId] = canonicalized.line\n        diagram.superlines = mergeSuperlineLists(diagram.superlines, {\n            [line.superline]: {phase: canonicalized.phase},\n        })\n    })\n    return diagram\n}\n\n/** @returns {Object<lineId, [nodeIndex1, lineIndex1,\n *                            nodeIndex2, lineIndex2]>} */\nfunction getLineEnds(diagram) {\n    let lineEnds = {}\n    diagram.nodes.forEach((node, nodeIndex) => {\n        node.lines.forEach((lineId, lineIndex) => {\n            let ends = lineEnds[lineId]\n            if (!ends) {\n                lineEnds[lineId] = [nodeIndex, lineIndex]\n            } else if (ends.length == 2) {\n                if (lexicalCmp([ends[0], ends[1]],\n                               [nodeIndex, lineIndex],\n                               defaultCmp) < 0) {\n                    lineEnds[lineId].push(nodeIndex, lineIndex)\n                } else {\n                    lineEnds[lineId].splice(0, 0, nodeIndex, lineIndex)\n                }\n            } else {\n                throw new Error(\"line must be connected to exactly 2 nodes\")\n            }\n        })\n    })\n    return lineEnds\n}\n\nclass DiagramLine {\n    constructor(diagram, id, reversed) {\n        console.assert(diagram)\n        this.diagram = diagram\n        this.id = id\n        this.reversed = Boolean(reversed)\n        Object.freeze(this)\n    }\n\n    get rawLine() {\n        return this.diagram.rawDiagram.lines[this.id]\n    }\n\n    get line() {\n        const f = this.reversed ? reverseLine : identity\n        return f(this.diagram.rawDiagram.lines[this.id])\n    }\n\n    get superline() {\n        return this.diagram.superline(this.superlineId)\n    }\n\n    get superlineId() {\n        return this.line.superline\n    }\n\n    get direction() {\n        if (this.rawLine.direction == null) {\n            return null\n        }\n        return this.rawLine.direction * (1 - this.reversed * 2)\n    }\n\n    node(end) {\n        const lineEnds = this.diagram._lineEnds[this.id]\n        return new DiagramNode(this.diagram,\n                               lineEnds[(this.reversed + end) % 2 * 2])\n    }\n\n    lineIndex(end) {\n        const lineEnds = this.diagram._lineEnds[this.id]\n        return lineEnds[(this.reversed + end) % 2 * 2 + 1]\n    }\n\n    cycNodeLine(end, offset) {\n        return this.node(end).line((this.lineIndex(end) + offset) % 3)\n    }\n\n    /** Called automatically when used as the name of a property. */\n    toString() {\n        return (this.reversed ? \"-\" : \"+\") + this.id\n    }\n\n    signedRebase(diagram) {\n        return diagram.signedLine(this.id, this.reversed)\n    }\n\n    reverse() {\n        return new DiagramLine(this.diagram, this.id, !this.reversed)\n    }\n\n    concat(...lines) {\n        return rawConcatLines(lines.map(line => line.line))\n    }\n\n    static removeSign(signedId) {\n        const id = signedId.substr(1)\n        let reversed = false\n        if (signedId[0] == \"-\") {\n            reversed = !reversed\n        } else if (signedId[0] != \"+\") {\n            throw new Error(`not a valid signed line ID: ${signedId}`)\n        }\n        return [id, reversed]\n    }\n\n    rawAssign(rawDiagram, end, lineId) {\n        rawDiagram.nodes[this.node(end).index].lines[this.lineIndex(end)] = lineId\n    }\n\n    testCuttability() {\n        let errors = [subdiagramOrientability(this),\n                      subdiagramOrientability(this.reverse())].filter(identity)\n        if (errors.length == 2) {\n            errors.sort((x, y) => x.priority - y.priority)\n            return errors[0].error\n        }\n        return null\n    }\n}\n\nclass DiagramNode {\n    constructor(diagram, index) {\n        this.diagram = diagram\n        this.index = index\n        Object.freeze(this)\n    }\n\n    get rawNode() {\n        return this.diagram.rawDiagram.nodes[this.index]\n    }\n\n    get type() {\n        return this.rawNode.type\n    }\n\n    get variable() {\n        if (this.type != \"terminal\") {\n            throw new Error(\"node is not a terminal\")\n        }\n        return this.rawNode.variable\n    }\n\n    get numLines() {\n        return this.rawNode.lines.length\n    }\n\n    line(index) {\n        const lineId = this.rawNode.lines[index]\n        const lineEnd = this.diagram._lineEnds[lineId]\n        const reversed = lineEnd[2] == this.index && lineEnd[3] == index\n        return new DiagramLine(this.diagram, lineId, reversed)\n    }\n\n    lines() {\n        return map(index => this.line(index), range(0, this.numLines))\n    }\n\n    get xy() {\n        return [this.rawNode.x, this.rawNode.y]\n    }\n}\n\nexport class Diagram {\n    constructor(rawDiagram) {\n        this.rawDiagram = Object.freeze(rawDiagram) || EMPTY_DIAGRAM\n        this._cache = {}\n        Object.freeze(this)\n    }\n\n    static deserialize(s) {\n        return new Diagram(JSON.parse(s))\n    }\n\n    get serialize() {\n        return JSON.stringify(this.rawDiagram)\n    }\n\n    get _lineEnds() {\n        let lineEnds = this._cache.lineEnds\n        if (!lineEnds) {\n            lineEnds = getLineEnds(this.rawDiagram)\n            this._cache.lineEnds = lineEnds\n        }\n        return lineEnds\n    }\n\n    get terminals() {\n        let terminals = this._cache.terminals\n        if (!terminals) {\n            terminals = {}\n            for (const node of this.nodes()) {\n                if (node.type == \"terminal\") {\n                    if (terminals[node.variable]) {\n                        throw new Error(\"duplicate terminal variables\")\n                    }\n                    terminals[node.variable] = node\n                }\n            }\n            this._cache.terminals = terminals\n        }\n        return terminals\n    }\n\n    terminal(variable) {\n        return this.terminals[variable]\n    }\n\n    get numNodes() {\n        return this.rawDiagram.nodes.length\n    }\n\n    node(index) {\n        return new DiagramNode(this, index)\n    }\n\n    * nodes() {\n        const numNodes = this.numNodes\n        for (let index = 0; index < numNodes; ++index) {\n            yield this.node(index)\n        }\n    }\n\n    get lineIds() {\n        return Object.keys(this.rawDiagram.lines)\n    }\n\n    signedLine(signedId, reversed) {\n        const [id, sign] = DiagramLine.removeSign(signedId)\n        return this.line(id, sign != Boolean(reversed))\n    }\n\n    line(id, reversed) {\n        return new DiagramLine(this, id, reversed)\n    }\n\n    lines() {\n        return map(id => this.line(id), this.lineIds)\n    }\n\n    get superlines() {\n        return this.rawDiagram.superlines\n    }\n\n    superline(superlineId) {\n        return this.superlines[superlineId]\n    }\n\n    hasSuperline(superlineId) {\n        return !!this.superline(superlineId)\n    }\n\n    isEquallyConstrained(superlineId, deltas) {\n        const related = relatedDelta(this.rawDiagram.deltas, superlineId)\n        const otherRelated = relatedDelta(deltas, superlineId)\n        return equalDeltas([related], [otherRelated])\n    }\n\n    renameLines(renames) {\n        let lines = {}\n        for (const lineId of Object.keys(this.rawDiagram.lines)) {\n            const newLineId = renames.hasOwnProperty(lineId)\n                            ? renames[lineId]\n                            : lineId\n            lines[newLineId] = this.rawDiagram.lines[lineId]\n        }\n        const nodes = this.rawDiagram.nodes.map(node =>\n            Object.freeze(Object.assign({}, node, {\n                lines: Object.freeze(node.lines.map(lineId =>\n                    propOr(renames, lineId, lineId)\n                ))\n            }))\n        )\n        return new Diagram(Object.assign({}, this.rawDiagram, {\n            nodes: Object.freeze(nodes),\n            lines: Object.freeze(lines),\n        }))\n    }\n\n    desumExposedSuperlines() {\n        return new Diagram(Object.assign({}, this.rawDiagram, {\n            superlines: mergeSuperlineLists(\n                this.rawDiagram.superlines,\n                ...Object.entries(this.rawDiagram.superlines)\n                .map(([superlineId, superline]) => (\n                    isSuperlineExposed(this.rawDiagram, superlineId)\n                    ? {[superlineId]: {summed: false}}\n                    : {}\n                ))),\n        }))\n    }\n\n    renameSuperlines(renames) {\n        return new Diagram(Object.assign({}, this.rawDiagram, {\n            lines: Object.freeze(Object.assign(\n                {},\n                ...Object.entries(this.rawDiagram.lines)\n                .map(([lineId, line]) => ({\n                    [lineId]: Object.freeze(Object.assign({}, line, {\n                        superline: propOr(renames, line.superline,\n                                          line.superline),\n                    })),\n                })))),\n            superlines: mergeSuperlineLists(\n                ...Object.entries(this.rawDiagram.superlines)\n                .map(([superlineId, superline]) => ({\n                    [propOr(renames, superlineId, superlineId)]: superline,\n                }))),\n            deltas: mergeDeltas(\n                this.rawDiagram.deltas.map(delta =>\n                    delta.map(superlineId =>\n                        propOr(renames, superlineId, superlineId)))),\n        })).removeUnusedSuperlines().desumExposedSuperlines()\n    }\n\n    removeUnusedSuperlines() {\n        let marked = Object.assign({}, this.rawDiagram.superlines)\n        for (const superlineId of Object.keys(marked)) {\n            if (!isEmptySuperline(marked[superlineId])) {\n                delete marked[superlineId]\n            }\n        }\n        for (const line of this.lines()) {\n            delete marked[line.superlineId]\n        }\n        for (const delta of this.rawDiagram.deltas) {\n            for (const superlineId of delta) {\n                delete marked[superlineId]\n            }\n        }\n        let superlines = Object.assign({}, this.rawDiagram.superlines)\n        for (const superlineId of Object.keys(marked)) {\n            delete superlines[superlineId]\n        }\n        if (superlines[\"0\"]) {\n            superlines[\"0\"] = EMPTY_SUPERLINE\n        }\n        return new Diagram(Object.assign({}, this.rawDiagram, {\n            superlines: superlines,\n        }))\n    }\n\n    /** Substitute a portion of this diagram for another subdiagram.\n     *\n     * Patterns are similar to diagrams, but also slightly different:\n     *\n     * - lineIds must refer to existing lines and must be prefixed by `+` or `-`\n     *   to indicate whether it should be treated as reversed\n     * - `line.direction: MATCH_ANY` will absorb any direction\n     */\n    substitute(pattern, replacement, flags) {\n        // schematic idea:\n        //\n        // orig: --- X1 --- N1 --- N2 --- X2 ---\n        // patt:     T1 --- N1 --- N2 --- T2\n        // repl:     T1 ------- N3 ------ T2\n        // new:  --- X1 ------- N3 ------ X2 ---\n        //\n        // anchor = a node that where gluing occurs;\n        //   for 'pattern', all terminals are anchors\n        //   for 'replacement', only terminals that match the pattern are\n        //\n        // the interesting/tricky parts occur on the terminals of the pattern;\n        // this is where we have to glue the original diagram to the\n        // replacement subdiagram.\n        //\n        // we have to make sure that the phases on X1-N1 are appropriately\n        // merged into X1-N3 and similarly for N2-X2, and also account for\n        // degenerate cases\n\n        flags = flags || {}\n        pattern = ensureDiagram(pattern)\n        replacement = ensureDiagram(replacement)\n        const rawDiagram = this.rawDiagram\n        const pattDiagram = new Diagram(pattern)\n        let replDiagram = new Diagram(replacement)\n\n        // DELTAS\n        // ------\n\n        // (shared with other parts)\n        let deltaMerge = [rawDiagram.deltas, replacement.deltas]\n\n        // match deltas\n        if (!containsDeltas(rawDiagram.deltas, pattern.deltas)) {\n            throw new Error(\"mismatch in deltas\")\n        }\n\n        // SHARED LINES\n        // ------------\n\n        // we allow a limited form of sharing: two pattern lines can map onto\n        // the same original line as long as the orientation is different;\n        // this in turn has the potential to create loops\n        let sharedLines = {}\n        let seenLines = {}\n        for (const pattLine of pattDiagram.lines()) {\n            const id = DiagramLine.removeSign(pattLine.id)[0]\n            const seen = seenLines[id]\n            if (seen) {\n                if (!(seen.node(0).type == \"terminal\" ||\n                      seen.node(1).type == \"terminal\")\n                    || !(pattLine.node(0).type == \"terminal\" ||\n                         pattLine.node(1).type == \"terminal\")) {\n                    throw new Error(\"a single internal line cannot \"\n                                  + \"match multiple lines\")\n                }\n                if (pattLine.node(0).type == \"terminal\"\n                    && pattLine.node(1).type == \"terminal\") {\n                    // this causes ambiguity and breakage\n                    throw new Error(\"a lone pattern line cannot be shared\")\n                }\n                if (sharedLines[pattLine.id] || sharedLines[seen.id]) {\n                    throw new Error(\"looped lines can only appear twice\")\n                }\n                sharedLines[pattLine.id] = seen.id\n                sharedLines[seen.id] = pattLine.id\n                continue\n            }\n            seenLines[id] = pattLine\n        }\n\n        // LINE RENAMING\n        // -------------\n\n        // (shared with other parts)\n        let newLines = Object.assign({}, rawDiagram.lines)\n\n        // must remove the pattern lines first, because we want to know which\n        // line IDs are available to us\n        for (const pattLine of pattDiagram.lines()) {\n            const lineId = DiagramLine.removeSign(pattLine.id)[0]\n            console.assert(newLines[lineId] || sharedLines[pattLine.id])\n            delete newLines[lineId]\n        }\n        // rename the replacement diagram to avoid conflicting line IDs\n        // and also replace the dummy line IDs\n        let freshLineIds = availLabels(newLines)\n        let lineRenames = {}\n        for (const line of replDiagram.lines()) {\n            if (line.id.startsWith(\"$\") || newLines.hasOwnProperty(line.id)) {\n                lineRenames[line.id] = freshLineIds.next().value\n            }\n        }\n        replDiagram = replDiagram.renameLines(lineRenames)\n        replacement = replDiagram.rawDiagram\n\n        // SUPERLINES\n        // ----------\n\n        // (shared with other parts)\n        let superlineMerge = [rawDiagram.superlines]\n\n        // match superlines and adjust phases\n        let summedSuperlines = new Set()\n        for (const superlineId of Object.keys(pattern.superlines)) {\n            const pattSuperline = pattern.superlines[superlineId]\n            const superline = rawDiagram.superlines[superlineId]\n            if (pattSuperline.summed) {\n                if (superlineId != \"0\") {\n                    if (!superline.summed) {\n                        throw new Error(\"expected summed superline\")\n                    }\n                    if (pattSuperline.weight != superline.weight) {\n                        throw new Error(\"weight of summed superline must match\")\n                    }\n                    if (pattSuperline.phase != superline.phase) {\n                        throw new Error(\"phase of summed superline must match\")\n                    }\n                    if (!this.isEquallyConstrained(superlineId,\n                                                   replacement.deltas)) {\n                        throw new Error(\"deltas of summed superline must match\")\n                    }\n                    summedSuperlines.add(superlineId)\n                }\n                superlineMerge.push({[superlineId]: {summed: false}})\n            }\n            superlineMerge.push({\n                [superlineId]: {\n                    weight: -pattSuperline.weight,\n                    phase: -pattSuperline.phase,\n                },\n            })\n        }\n        // forbid variable capture\n        for (const superlineId of Object.keys(replacement.superlines)) {\n            const replSuperline = replacement.superlines[superlineId]\n            if (replSuperline.summed) {\n                const pattSuperline = pattern.superlines[superlineId]\n                if (pattSuperline) {\n                    if (!pattSuperline.summed) {\n                        throw new Error(\"summed variable conflicts \"\n                                      + \"with pattern\")\n                    }\n                } else if (rawDiagram.superlines[superlineId]) {\n                    throw new Error(\"summed variable conflicts with original\")\n                }\n            }\n        }\n        superlineMerge.push(replacement.superlines)\n\n        // NODES\n        // -----\n\n        // match nodes and adjust phases\n        for (const pattNode of pattDiagram.nodes()) {\n            if (pattNode.type == \"terminal\") {\n                continue\n            }\n            if (pattNode.numLines == 0) {\n                throw new Error(\"singleton nodes are not supported\")\n            }\n            const node = pattNode.line(0).signedRebase(this).node(0)\n            if (node.type != pattNode.type) {\n                throw new Error(\"node type mismatch\")\n            }\n            const nodeLines = Array.from(node.rawNode.lines)\n            const pattNodeLines = Array.from(pattNode.rawNode.lines)\n            if (node.type == \"w3j\") {\n                const uniqueLines = permutSign(nodeLines, nodeLines)\n                const sign = permutSign(\n                    nodeLines,\n                    pattNodeLines.map(signedId =>\n                        DiagramLine.removeSign(signedId)[0]))\n                if (uniqueLines && sign == 0) {\n                    throw new Error(\"node lines mismatch\")\n                }\n                if (sign < 0) {\n                    superlineMerge.push(\n                        {[nodeLines[0]]: {phase: 1}},\n                        {[nodeLines[1]]: {phase: 1}},\n                        {[nodeLines[2]]: {phase: 1}},\n                    )\n                }\n            } else if (lexicalCmp(nodeLines, pattNodeLines, defaultCmp) != 0) {\n                throw new Error(\"node lines mismatch\")\n            }\n        }\n\n        // LINES\n        // -----\n\n        // match lines and adjust phases\n        let matchedLineIds = new Set()\n        for (const pattLine of pattDiagram.lines()) {\n            const pattNode0 = pattLine.node(0)\n            const pattNode1 = pattLine.node(1)\n            const line = pattLine.signedRebase(this)\n            if (line.superlineId != pattLine.superlineId) {\n                throw new Error(\"superline ID mismatch in lines\")\n            }\n            if (pattNode0.type != \"terminal\"\n                && pattNode1.type != \"terminal\"\n                && pattLine.direction != null) {\n                const diffDirection = mergeDirections(line.direction,\n                                                     -pattLine.direction)\n                if (line.superlineId != \"0\" && diffDirection % 2 != 0) {\n                    throw new Error(\"directedness mismatch in lines\")\n                }\n                superlineMerge.push({\n                    [line.superlineId]: {phase: diffDirection},\n                })\n            }\n            matchedLineIds.add(line.id)\n        }\n        // prevent summed superlines from appearing outside the pattern\n        const patternSuperlineSet = new Set(Object.keys(pattern.superlines))\n        for (const line of this.lines()) {\n            if (!matchedLineIds.has(line.id) &&\n                summedSuperlines.has(line.superlineId)) {\n                throw new Error(\"summed line must not appear outside match\")\n            }\n        }\n\n        let nodes = rawDiagram.nodes.map(node => Object.assign({}, node, {\n            lines: node.lines.slice(),\n        }))\n        let replNodes = replacement.nodes.map(node => Object.assign({}, node, {\n            lines: node.lines.slice(),\n        }))\n        let seenReplLines = {}\n        // find the node that we should join to\n        //\n        // context: this, pattDiagram, nodes, replNodes, seenReplLines\n        const findJoiningNode = replLine => {\n            // There's several cases to consider here.\n            //\n            // In the simplest case, with no shared lines, we have:\n            //\n            // orig  N1 --->---\n            // patt     ---<--- TP\n            // repl     --->--- TR\n            //\n            // A shared line case might look like this:\n            //\n            //          -------------------------\n            //         /                         \\\n            //         \\                         /\n            // orig     -->---             ------\n            // patt    ---<--- TP1     TP2 --->---\n            // repl    --->--- TR1     TR2 --->---\n            //\n            // This could go on for several jumps, if the node opposite to\n            // TR2 is an anchor too.  It could even loop back to itself.\n            let lines = [replLine.line]\n            while (true) {\n                const replNode = replLine.node(1)\n                const result = {\n                    type: \"replacement\",\n                    lines: lines,\n                    line: replLine,\n                    lineId: replLine.id,\n                    nodes: replNodes,\n                }\n                if (replNode.type != \"terminal\") {\n                    return result\n                }\n                const pattNode = pattDiagram.terminal(replNode.variable)\n                if (!pattNode) {\n                    return result\n                }\n                seenReplLines[replLine.id] = true\n                const pattLine = pattNode.line(0)\n                const line = pattLine.signedRebase(this).reverse()\n                // avoid consuming phases twice if the pattern line is\n                // terminal-to-terminal\n                if (pattLine.node(1).type != \"terminal\" || !pattLine.reversed) {\n                    lines.push(pattLine.line, line.line)\n                }\n                const otherPattLineId = sharedLines[pattLine.id]\n                if (!otherPattLineId) {\n                    // no shared line, so joining node is from original diagram\n                    return {\n                        type: \"original\",\n                        lines: lines,\n                        line: line,\n                        lineId: replLine.id,\n                        nodes: nodes,\n                    }\n                }\n                // we have shared line, so joining node comes from elsewhere\n                const otherPattLine = pattDiagram.line(otherPattLineId,\n                                                       pattLine.reversed)\n                const otherPattNode = otherPattLine.node(0)\n                if (otherPattNode.type != \"terminal\") {\n                    throw new Error(\"expected terminal node\")\n                }\n                lines.push(otherPattLine.reverse().line)\n                replLine = replDiagram.terminal(otherPattNode.variable).line(0)\n                if (seenReplLines[replLine.id]) {\n                    // we found a loop\n                    return {\n                        type: \"cycle\",\n                        lines: lines,\n                    }\n                }\n                lines.push(replLine.line)\n            }\n        }\n        function getPart(joining) {\n            switch (joining.type) {\n                case \"replacement\":\n                    return joining.line.node(1).type == \"terminal\" ? -1 : 1\n                case \"original\":\n                    return 0\n                default:\n                    throw new Error(\"joining type not valid here\")\n            }\n        }\n        for (const replLine of replDiagram.lines()) {\n            if (seenReplLines[replLine.id]) {\n                continue // avoid double-counting\n            }\n            const joining0 = findJoiningNode(replLine.reverse())\n            if (joining0.type == \"cycle\") {\n                // special case: cycle\n                const combined = concatLines(...joining0.lines)\n                deltaMerge.push([combined.delta])\n                if (combined.line.direction % 2) {\n                    throw new Error(\"directed loops are forbidden\")\n                }\n                superlineMerge.push({\n                    [combined.line.superline]: {\n                        phase: combined.phase,\n                        weight: 2,\n                    },\n                })\n                continue\n            }\n            const joining1 = findJoiningNode(replLine)\n            const lineId = joining0.lineId\n            const nodeIndex0 = joining0.line.node(1).index\n            const nodeIndex1 = joining1.line.node(1).index\n            const lineIndex0 = joining0.line.lineIndex(1)\n            const lineIndex1 = joining1.line.lineIndex(1)\n            const lines = joining0.lines\n                                  .map(reverseLine)\n                                  .reverse()\n                                  .concat(joining1.lines.slice(1))\n            const f = lexicalCmp([getPart(joining0), nodeIndex0, lineIndex0],\n                                 [getPart(joining1), nodeIndex1, lineIndex1],\n                                 defaultCmp) > 0\n                    ? reverseLine : identity\n            joining0.nodes[nodeIndex0].lines[lineIndex0] = lineId\n            joining1.nodes[nodeIndex1].lines[lineIndex1] = lineId\n            const combined = concatLines(...lines)\n            // prefer superlines that aren't summed to avoid\n            // exposing them as external lines\n            deltaMerge.push([combined.delta])\n            console.assert(!newLines[lineId])\n            let superline = combined.line.superline\n            for (const superlineId of combined.delta) {\n                if (!this.superline(superlineId) ||\n                    !this.superline(superlineId).summed) {\n                    superline = superlineId\n                    break\n                }\n            }\n            newLines[lineId] = ensureLine(f(Object.assign({}, combined.line, {\n                superline: superline,\n            })))\n            superlineMerge.push({\n                [combined.line.superline]: {phase: combined.phase},\n            })\n        }\n\n        const newNodes = Array.prototype.concat(\n            replacement.nodes.filter((node, nodeIndex) =>\n                node.type == \"terminal\" && !pattDiagram.terminal(node.variable)\n            ),\n            arrayRemoveMany(\n                nodes,\n                Array.from(\n                    map(node => node.line(0)\n                                    .signedRebase(this)\n                                    .node(0)\n                                    .index,\n                        filter(node => node.type != \"terminal\",\n                               pattDiagram.nodes())))),\n            replacement.nodes.filter(node => node.type != \"terminal\"))\n\n        const newDiagram = new Diagram(Object.assign({}, rawDiagram, {\n            nodes: newNodes,\n            lines: newLines,\n            superlines: mergeSuperlineLists(...superlineMerge),\n            deltas: mergeDeltas(...deltaMerge),\n        })).removeUnusedSuperlines()\n\n        if (flags.withLineRenames) {\n            return {diagram: newDiagram, lineRenames: lineRenames}\n        } else {\n            return newDiagram\n        }\n    }\n}\n\nfunction findW3jLoop(node) {\n    if (node.type != \"w3j\") {\n        return \"not a Wigner 3-jm symbol\"\n    }\n    for (let i = 0; i < 3; ++i) {\n        if (node.line(i).id == node.line((i + 1) % 3).id) {\n            return {\n                cutLine: node.line((i + 2) % 3),\n                loopLine: node.line(i),\n            }\n        }\n    }\n    return \"no loops found\"\n}\n\nfunction loopElimRule(diagram, lineId, nodeIndex) {\n    diagram = new Diagram(diagram)\n    const loopNode = diagram.line(lineId).node(0)\n    if (loopNode.index != diagram.line(lineId).node(1).index) {\n        return \"no loops found\"\n    }\n    const loop = findW3jLoop(loopNode)\n    if (typeof loop != \"object\") {\n        return loop\n    }\n    if (!isLineDirectable(loop.loopLine.line)) {\n        return \"loop must be directed\"\n    }\n    const otherNode = loop.cutLine.node(1)\n    if (otherNode.type != \"w3j\") {\n        diagram = deepClone(diagram.rawDiagram)\n        diagram.deltas = mergeDeltas(\n            diagram.deltas,\n            [[diagram.lines[loop.cutLine.id].superline, \"0\"]])\n        diagram.lines[loop.cutLine.id].superline = \"0\"\n        diagram.superlines[\"0\"] = EMPTY_SUPERLINE\n        return diagram\n    }\n    if (otherNode.index != nodeIndex && loopNode.index != nodeIndex) {\n        return \"not sure what you're trying to do\"\n    }\n    const ld = loop.loopLine\n    const lc = loop.cutLine\n    const lb = loop.cutLine.cycNodeLine(1, 1).reverse()\n    const la = loop.cutLine.cycNodeLine(1, 2).reverse()\n    if (la.id == lb.id && !isLineDirectable(la.line)) {\n        // other loop must be directed too if we want to eliminate it\n        diagram = deepClone(diagram.rawDiagram)\n        diagram.deltas = mergeDeltas(\n            diagram.deltas,\n            [[diagram.lines[loop.cutLine.id].superline, \"0\"]])\n        diagram.lines[loop.cutLine.id].superline = \"0\"\n        diagram.superlines[\"0\"] = EMPTY_SUPERLINE\n        return diagram\n    }\n    const md = ld.toString()\n    const mc = lc.toString()\n    const mb = lb.toString()\n    const ma = la.toString()\n    const jd = ld.superlineId\n    const jc = lc.superlineId\n    const jb = lb.superlineId\n    const ja = la.superlineId\n    return diagram.substitute({\n        nodes: [\n            terminalNode(ma, \"a\"),\n            terminalNode(mb, \"b\"),\n            w3jNode(md, md, mc),\n            w3jNode(mc, mb, ma),\n        ],\n        lines: {\n            [md]: {superline: jd, direction: +1},\n            [mc]: {superline: jc, direction: null},\n            [mb]: {superline: jb, direction: 0},\n            [ma]: {superline: ja, direction: +1},\n        },\n        superlines: {\n            [ja]: {weight: 1},\n        },\n    }, {\n        nodes: [\n            terminalNode(\"$1\", \"a\"),\n            terminalNode(\"$1\", \"b\"),\n        ],\n        lines: {\n            $1: {superline: jb, direction: 0,\n                 arcHeight: -8 * lb.line.arcHeight}, // empirically works...\n        },\n        superlines: {\n            [jd]: {weight: 1},\n            \"0\": {},\n        },\n        deltas: [\n            [\"0\", jc],\n        ],\n    }).rawDiagram\n}\n\nfunction loopIntroRule(diagram, lineId, xy1, xy2) {\n    diagram = new Diagram(diagram)\n    const line = diagram.line(lineId)\n    const dxy = vectorSubtract(xy2, xy1)\n    const angle = Math.atan2(dxy[1], dxy[0])\n    return diagram.substitute({\n        nodes: [\n            terminalNode(line.toString(), \"a\"),\n            terminalNode(line.toString(), \"b\"),\n        ],\n        lines: {\n            [line]: {superline: line.superlineId, direction: 0},\n        },\n    }, {\n        nodes: [\n            terminalNode(\"$1\", \"a\"),\n            terminalNode(\"$2\", \"b\"),\n            w3jNode(\"$4\", \"$4\", \"$3\", ...xy2),\n            w3jNode(\"$3\", \"$2\", \"$1\", ...xy1),\n        ],\n        lines: {\n            $4: {superline: \"0\", direction: +1,\n                 angle: angle - 0.5 * Math.PI, arcHeight: 50.0},\n            $3: {superline: \"0\", direction: 0},\n            $2: {superline: line.superlineId, direction: 0,\n                 arcHeight: -line.line.arcHeight / 4},\n            $1: {superline: line.superlineId, direction: +1,\n                 arcHeight: -line.line.arcHeight / 2},\n        },\n        superlines: {\n            [line.superlineId]: {weight: 1},\n        },\n    }).rawDiagram\n}\n\nfunction w3jIntroRule(diagram, lineId1, lineId2, reversed, diagonal) {\n    diagram = new Diagram(diagram)\n    let line1 = diagram.line(lineId1)\n    let line2 = diagram.line(lineId2)\n    if ((vectorDot(\n        vectorSubtract(line1.node(1).xy, line1.node(0).xy),\n        vectorSubtract(line2.node(1).xy, line2.node(0).xy),\n    ) < 0) != Boolean(reversed)) {\n        line2 = line2.reverse()\n    }\n    const xy1 = vectorAdd(\n        scalarMultiply(0.375, vectorAdd(line1.node(0).xy, line2.node(0).xy)),\n        scalarMultiply(0.125, vectorAdd(line1.node(1).xy, line2.node(1).xy)),\n    )\n    const xy2 = vectorAdd(\n        scalarMultiply(0.125, vectorAdd(line1.node(0).xy, line2.node(0).xy)),\n        scalarMultiply(0.375, vectorAdd(line1.node(1).xy, line2.node(1).xy)),\n    )\n    const j = availSuperlineLabels(diagram.rawDiagram).next().value\n    const arcHeight1 = line1.node(0).index == line2.node(0).index ? 50.0 : 0.0\n    const arcHeight2 = line1.node(1).index == line2.node(1).index ? 50.0 : 0.0\n    return diagram.substitute({\n        nodes: [\n            terminalNode(line1.toString(), \"a\"),\n            terminalNode(line1.toString(), \"b\"),\n            terminalNode(line2.toString(), \"c\"),\n            terminalNode(line2.toString(), \"d\"),\n        ],\n        lines: {\n            [line1]: {superline: line1.superlineId, direction: 0},\n            [line2]: {superline: line2.superlineId, direction: 0},\n        },\n    }, {\n        nodes: [\n            terminalNode(\"$1\", \"a\"),\n            terminalNode(\"$2\", \"b\"),\n            terminalNode(\"$3\", \"c\"),\n            terminalNode(\"$4\", \"d\"),\n            w3jNode(\"$1\", \"$3\", \"$5\", ...xy1),\n            w3jNode(\"$2\", \"$4\", \"$5\", ...xy2),\n        ],\n        lines: {\n            $1: {superline: line1.superlineId, direction: Number(diagonal),\n                 arcHeight: -arcHeight1},\n            $2: {superline: line1.superlineId, direction: Number(diagonal),\n                 arcHeight: -arcHeight2},\n            $3: {superline: line2.superlineId, direction: 0,\n                 arcHeight: arcHeight1},\n            $4: {superline: line2.superlineId, direction: 0,\n                 arcHeight: arcHeight2},\n            $5: {superline: j, direction: 0},\n        },\n        superlines: {\n            [j]: {phase: 0, weight: 2, summed: true},\n        },\n    }).rawDiagram\n}\n\nfunction w3jElimRule(diagram, lineId) {\n    diagram = new Diagram(diagram)\n    const line = diagram.line(lineId)\n    const superline = line.superline\n    if (!superline.summed) {\n        return `j[${line.superlineId}] must be summed over`\n    }\n    if (superline.phase != 0) {\n        return `j[${line.superlineId}] must not have any phases`\n    }\n    if (superline.weight != 2) {\n        return `weight of j[${line.superlineId}] must be exactly 2`\n    }\n    if (!diagram.isEquallyConstrained(line.superlineId, [])) {\n        return `j[${line.superlineId}] must not be constrained by deltas`\n    }\n    for (const otherLine of diagram.lines()) {\n        if (otherLine.id != line.id && otherLine.superlineId == line.superlineId) {\n            return `j[${line.superlineId}] must not appear anywhere else`\n        }\n    }\n    if (line.node(0).type != \"w3j\" || line.node(1).type != \"w3j\") {\n        return \"expected Wigner 3-j symbols\"\n    }\n    const line1 = line.cycNodeLine(0, 1).reverse()\n    const line2 = line.cycNodeLine(1, 1).reverse()\n    const line3 = line.cycNodeLine(0, 2).reverse()\n    const line4 = line.cycNodeLine(1, 2).reverse()\n    if (line1.superlineId != line2.superlineId\n        || line3.superlineId != line4.superlineId) {\n        return \"opposing j's don't match\"\n    }\n    const lineIdOther = line1.id == line3.id ? line4.id : line3.id\n    console.assert(line1.id, lineIdOther)\n    return diagram.substitute({\n        nodes: [\n            terminalNode(line1.toString(), \"a\"),\n            terminalNode(line2.toString(), \"b\"),\n            terminalNode(line3.toString(), \"c\"),\n            terminalNode(line4.toString(), \"d\"),\n            w3jNode(line1.toString(), line3.toString(), line.toString()),\n            w3jNode(line2.toString(), line4.toString(), line.toString()),\n        ],\n        lines: {\n            [line1]: {superline: line1.superlineId, direction: 0},\n            [line2]: {superline: line2.superlineId, direction: 0},\n            [line3]: {superline: line3.superlineId, direction: 0},\n            [line4]: {superline: line4.superlineId, direction: 0},\n            [line]: {superline: line.superlineId, direction: 0},\n        },\n        superlines: {\n            [line.superlineId]: {phase: 0, weight: 2, summed: true},\n        },\n    }, {\n        nodes: [\n            terminalNode(line1.id, \"a\"),\n            terminalNode(line1.id, \"b\"),\n            terminalNode(lineIdOther, \"c\"),\n            terminalNode(lineIdOther, \"d\"),\n        ],\n        lines: {\n            [line1.id]: {superline: line1.superlineId, direction: 0},\n            [lineIdOther]: {superline: line3.superlineId, direction: 0},\n        },\n    }).rawDiagram\n}\n\nfunction getAmbientDirections(diagram, ignoreExternal) {\n    // lines we don't care about:\n    // - external lines with no pre-existing direction\n    // - zero lines\n    // however, unlike zero lines, we do still need to *show* the correct\n    // arrows, so we can't toss out those external lines entirely!\n    let excludedLineIds = []\n    let directions = new RealSparseVector()\n    for (const line of diagram.lines()) {\n        if (line.superlineId != \"0\") {\n            if ([line.node(0).type, line.node(1).type].includes(\"terminal\")\n                && (ignoreExternal || line.direction % 2 == 0)) {\n                excludedLineIds.push(line.id)\n            }\n            directions.set(line.id, 1 - mod(line.direction, 2))\n        }\n    }\n    let matrix = new RealSparseMatrix()\n    for (const node of diagram.nodes()) {\n        if (node.type == \"w3j\") {\n            for (const line of node.lines()) {\n                if (line.superlineId != \"0\") {\n                    matrix.modify(line.id, node.index,\n                                  x => x + (line.reversed ? -1 : 1))\n                }\n            }\n        }\n    }\n    let subdirections = directions.copy()\n    let submatrix = matrix.map(x => mod(x, 2))\n    for (const lineId of excludedLineIds) {\n        subdirections.delete(lineId)\n        submatrix.deleteRow(lineId)\n    }\n    const result = sparseGaussElim(GF2_FIELD, submatrix, subdirections)\n    const ambient = sparseMatrixVectorMultiply(REAL_FIELD, matrix,\n                                               result.solution.map(x => -x))\n    return {\n        orientable: result.consistent,\n        directions: ambient,\n        target: subdirections,\n    }\n}\n\nfunction getConnectedSubdiagram(line0) {\n    let closed = true\n    let isolated = true\n    let nodeIndices = new Set()\n    let lines = {}\n    let candidates = [line0]\n    while (candidates.length > 0) {\n        const line = candidates.pop()\n        if (lines.hasOwnProperty(line.id)) {\n            if (line.id == line0.id && line.reversed == line0.reversed) {\n                isolated = false\n            }\n            continue\n        }\n        const node = line.node(1)\n        if (node.type == \"terminal\") {\n            closed = false\n        }\n        nodeIndices.add(node.index)\n        lines[line.id] = line.rawLine\n        for (const line of node.lines()) {\n            candidates.push(line)\n        }\n    }\n    const rawDiagram = line0.diagram.rawDiagram\n    return {\n        closed: closed,\n        isolated: isolated,\n        diagram: Object.assign({}, rawDiagram, {\n            nodes: rawDiagram.nodes.filter((_, nodeIndex) =>\n                nodeIndices.has(nodeIndex)),\n            lines: lines,\n        }),\n    }\n}\n\nfunction subdiagramOrientability(line0) {\n    const subdiagram = getConnectedSubdiagram(line0)\n    if (!subdiagram.isolated) {\n        return {\n            error: \"only bridges can be cut\",\n            priority: 1,\n        }\n    }\n    if (!subdiagram.closed) {\n        return {\n            error: \"subdiagram must be closed\",\n            priority: 2,\n        }\n    }\n    const diagram = Object.assign({}, subdiagram.diagram)\n    diagram.lines = Object.assign({}, diagram.lines)\n    diagram.lines[line0.id] = Object.assign({}, diagram.lines[line0.id], {\n        superline: \"0\",\n    })\n    const ambient = getAmbientDirections(new Diagram(diagram), true)\n    if (!ambient.orientable) {\n        return {\n            error: \"diagram is non-orientable\",\n            priority: 0,\n        }\n    }\n    return null\n}\n\nfunction cutRule(diagram, lineId, xy1, xy2) {\n    diagram = new Diagram(diagram)\n    const line = diagram.line(lineId)\n    if (vectorDot(vectorSubtract(xy1, xy2),\n                  vectorSubtract(line.node(0).xy, line.node(1).xy)) < 0) {\n        [xy1, xy2] = [xy2, xy1]\n    }\n    if (line.superlineId != \"0\") {\n        let error = line.testCuttability()\n        if (error) {\n            return error\n        }\n    }\n    const dxy = vectorSubtract(xy1, xy2)\n    const angle = Math.atan2(dxy[1], dxy[0])\n    const result = diagram.substitute({\n        nodes: [\n            terminalNode(line.toString(), \"a\"),\n            terminalNode(line.toString(), \"b\"),\n        ],\n        lines: {\n            [line]: {superline: line.superlineId, direction: 0},\n        },\n    }, {\n        nodes: [\n            terminalNode(\"$1\", \"a\"),\n            terminalNode(\"$2\", \"b\"),\n            w3jNode(\"$1\", \"$3\", \"$3\", xy1[0], xy1[1]),\n            w3jNode(\"$2\", \"$4\", \"$4\", xy2[0], xy2[1]),\n        ],\n        lines: {\n            $1: {superline: line.superlineId, direction: 0,\n                 arcHeight: -0.5 * line.line.arcHeight},\n            $2: {superline: line.superlineId, direction: 0,\n                 arcHeight: -0.25 * line.line.arcHeight},\n            $3: {superline: \"0\", direction: 0,\n                 angle: angle + 0.5 * Math.PI, arcHeight: 50},\n            $4: {superline: \"0\", direction: 0,\n                 angle: angle + 1.5 * Math.PI, arcHeight: 50},\n        },\n        deltas: [\n            [\"0\", line.superlineId],\n        ],\n    }, {withLineRenames: true})\n    diagram = result.diagram.rawDiagram\n    // try to eliminate the loops if possible\n    const renames = result.lineRenames\n    const loop1Id = result.diagram.line(renames.$3).id\n    const loop2Id = result.diagram.line(renames.$4).id\n    const loopNode1Index = result.diagram.line(loop1Id).node(0).index\n    // kind of fragile: relying on the fact that pruning doesn't relabel lines\n    let newDiagram = loopElimRule(diagram, loop1Id, loopNode1Index)\n    if (typeof newDiagram == \"string\") {\n        return diagram\n    }\n    diagram = newDiagram\n    const loopNode2Index = new Diagram(diagram).line(loop2Id).node(0).index\n    newDiagram = loopElimRule(diagram, loop2Id, loopNode2Index)\n    if (typeof newDiagram == \"string\") {\n        return diagram\n    }\n    return newDiagram\n}\n\nfunction glueRule(diagram, lineId1, lineId2, xy1, xy2) {\n    diagram = new Diagram(diagram)\n    const line1 = diagram.line(lineId1)\n    const line2 = diagram.line(lineId2)\n    if (line1.id == line2.id) {\n        return diagram // not supported (tricky to implement / easy workaround)\n    }\n    return diagram.substitute({\n        nodes: [\n            terminalNode(line1.toString(), \"a\"),\n            terminalNode(line1.toString(), \"b\"),\n            terminalNode(line2.toString(), \"c\"),\n            terminalNode(line2.toString(), \"d\"),\n        ],\n        lines: {\n            [line1]: {superline: line1.superlineId, direction: +1},\n            [line2]: {superline: line2.superlineId, direction: +1},\n        },\n    }, {\n        nodes: [\n            terminalNode(\"$1\", \"a\"),\n            terminalNode(\"$2\", \"b\"),\n            terminalNode(\"$3\", \"c\"),\n            terminalNode(\"$4\", \"d\"),\n            w3jNode(\"$1\", \"$2\", \"$5\", xy1[0], xy1[1]),\n            w3jNode(\"$3\", \"$4\", \"$5\", xy2[0], xy2[1]),\n        ],\n        lines: {\n            $1: {superline: line1.superlineId, direction: 0},\n            $2: {superline: line1.superlineId, direction: 0},\n            $3: {superline: line2.superlineId, direction: 0},\n            $4: {superline: line2.superlineId, direction: 0},\n            $5: {superline: \"0\", direction: 0},\n        },\n        superlines: mergeSuperlineLists( // these superlineIds might collide!\n            {[line1.superlineId]: {weight: +1}},\n            {[line2.superlineId]: {weight: +1}},\n        ),\n    }).rawDiagram\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Drawing\n\nfunction renderArrow(update, diagram, lineId, ambient) {\n    const arrowHeadSize = 15\n    const line = diagram.lines[lineId]\n    let bad = false\n    let expectedDirection = false\n    let direction = line.direction\n    if (ambient) {\n        expectedDirection = ambient.target.get(lineId)\n        const ambientDirection = ambient.directions.get(lineId)\n        bad = !direction == !ambientDirection\n        direction = direction || ambientDirection\n    }\n    if (direction == 0 && !expectedDirection) {\n        return []\n    }\n    if (line.arrowPos < 0.0) {\n        line.arrowPos = 0.0\n    } else if (line.arrowPos > 1.0) {\n        line.arrowPos = 1.0\n    }\n    const info = getLineInfo(diagram, lineId)\n    // the coordinate we need is the tip of the arrow (which follows the\n    // contour of the line), but we want to try to keep the body of\n    // the arrow centered\n    const correction = direction * arrowHeadSize / 2\n    const position = positionOnLine(info, line.arrowPos, correction)\n    const rawPosition = positionOnLine(info, line.arrowPos, 0)\n    const angle = position.tangentAngle\n                + Number(direction < 0) * Math.PI\n    return [vnode(\n        \"svg:g\",\n        {\n            \"class\": \"arrow \"\n                   + (!line.direction ? \"ambient \" : \"\")\n                   + (info.external ? \"external \" : \"\")\n                   + (bad ? \"bad \" : \"\"),\n            onmousedown: function(e) {\n                if (e.buttons == 1) {\n                    update(startDrag(rawPosition.x, rawPosition.y, {\n                        superficial: true,\n                    }, (diagram, x, y, snap) => {\n                        const pos = findPosOnLine(info, x, y).pos\n                        let lines = Object.assign({}, diagram.lines)\n                        // prevent arrows from getting stuck under nodes\n                        lines[lineId] = Object.assign({}, lines[lineId], {\n                            arrowPos: clamp(0.1, 0.9, round(snap && 0.1, pos)),\n                        })\n                        return Object.assign({}, diagram, {lines: lines})\n                    }))\n                    e.stopPropagation()\n                } else if (e.buttons == 2 && e.ctrlKey) {\n                    update(modifyDiagram({superficial: true}, diagram => {\n                        let lines = Object.assign({}, diagram.lines)\n                        lines[lineId] = Object.assign({}, lines[lineId], {\n                            arrowPos: 0.5,\n                        })\n                        return Object.assign({}, diagram, {lines: lines})\n                    }))\n                    e.stopPropagation()\n                }\n            },\n        },\n        vnode(\"svg:circle\", {\n            \"class\": \"hit\",\n            r: 15,\n            cx: rawPosition.x,\n            cy: rawPosition.y,\n        }),\n        direction ? vnode(\"svg:use\", {\n            \"class\": \"arrowhead\",\n            href: \"#arrowhead\",\n            x: -arrowHeadSize,\n            y: -arrowHeadSize / 2,\n            width: arrowHeadSize,\n            height: arrowHeadSize,\n            transform: `translate(${position.x}, ${position.y}) `\n                     + `rotate(${angle * 180 / Math.PI})`,\n        }) : vnode(\"svg:circle\", {\n            \"class\": \"arrowhead\",\n            cx: position.x,\n            cy: position.y,\n            r: arrowHeadSize / 2,\n        }),\n    )]\n}\n\nfunction renderLine(update, editor, lineId, ambient) {\n    const diagram = editor.snapshot.diagram\n    const line = diagram.lines[lineId]\n    const superline = diagram.superlines[line.superline]\n    const minTextOffset = 20\n    const info = getLineInfo(diagram, lineId)\n    const position = positionOnLine(info, line.textPos, 0)\n    let textOffset = line.textOffset\n    if (textOffset == 0) {\n        textOffset = minTextOffset * info.halfDisk\n    } else if (textOffset > 0 && textOffset < minTextOffset) {\n        textOffset = minTextOffset\n    } else if (textOffset < 0 && textOffset > -minTextOffset) {\n        textOffset = -minTextOffset\n    }\n    let d = `M ${info.x0} ${info.y0} `\n    if (info.arc.radius == Infinity) {\n        // don't make Inkscape sad\n        d += `L `\n    } else {\n        const radius = Math.abs(info.arc.radius)\n        d += `A ${radius} ${radius} 0 `\n           + `${Number(info.arc.large)} ${Number(info.arc.sweep)} `\n    }\n    d += `${info.x1} ${info.y1}`\n    const textX = position.x + textOffset * position.normalX\n    const textY = position.y + textOffset * position.normalY\n    function onmousedown(e) {\n        const [x, y] = toSvgCoords([e.clientX, e.clientY])\n        if (e.buttons == 1) {\n            update(startDrag(x, y, {\n                superficial: true,\n            }, (diagram, x, y, snap) => {\n                let change\n                if (info.singular) {\n                    const dx = x - info.xMid\n                    const dy = y - info.yMid\n                    const angle = Math.atan2(dy, dx) - Math.PI / 2\n                    const height = Math.sqrt(dx * dx + dy * dy)\n                    change = {\n                        angle: round(snap && Math.PI / 6, angle),\n                        arcHeight: clamp(20.0, Infinity,\n                                         round(snap && 20.0, height)),\n                    }\n                } else {\n                    change = {\n                        angle: info.trueAngle,\n                        arcHeight: round(snap && 20.0,\n                                         threePointArc(x, y,\n                                                       info.x0, info.y0,\n                                                       info.x1, info.y1)),\n                    }\n                }\n                return setDiagramLineProps(diagram, lineId, change)\n            }))\n            e.stopPropagation()\n        } else if (e.buttons == 2 && e.ctrlKey == true) {\n            update(modifyDiagram({superficial: true}, diagram =>\n                info.singular ? diagram : setDiagramLineProps(diagram, lineId, {\n                    angle: info.angle,\n                    arcHeight: 0.0,\n                })\n            ))\n            e.stopPropagation()\n        }\n    }\n    return vnode(\n        \"svg:g\",\n        {\n            // prevent hover effects from sticking when nodes change\n            [VNODE_KEY]: lineId,\n            \"class\": \"line \"\n                   + (line.superline == \"0\" ? \"zero \" : \"\")\n                   + (superline.summed ? \"summed \" : \"\")\n                   + (superline.phase % 2 ? \"one-j \" : \"\")\n                   + (mod(superline.phase, 4) >= 2 ? \"two-j \" : \"\")\n                   + ((editor.trackStart.type == \"line\" &&\n                       editor.trackStart.lineId == lineId)\n                   || (editor.trackStop.type == \"line\" &&\n                       editor.trackStop.lineId == lineId)\n                    ? (editor.trackType + \" \") : \"\"),\n            onmouseenter: function(e) {\n                update(setHover({\n                    type: \"line\",\n                    lineId: lineId,\n                }))\n            },\n            onmouseleave: function(e) {\n                update(setHover({type: null}))\n            },\n        },\n        vnode(\"svg:title\", {}, `j[${line.superline}] m[${lineId}]`),\n        // this path (1) increases hit area (2) helps delineate crossing lines\n        vnode(\"svg:path\", {\n            \"class\": \"bg\",\n            d: d,\n            onmousedown: onmousedown,\n        }),\n        vnode(\"svg:path\", {\n            \"class\": \"fg\",\n            d: d,\n            onmousedown: onmousedown,\n        }),\n        vnode(\"svg:path\", {\n            \"class\": \"pith\",\n            d: d,\n            onmousedown: onmousedown,\n        }),\n        vnode(\"svg:path\", {\n            \"class\": \"hit\",\n            d: d,\n            onmousedown: onmousedown,\n        }),\n        vnode(\"svg:text\", {\n            \"class\": \"label\",\n            x: textX,\n            y: textY,\n            onmousedown: function(e) {\n                if (e.buttons == 1) {\n                    update(startDrag(textX, textY, {\n                        superficial: true,\n                    }, (diagram, x, y, snap) => {\n                        const where = findPosOnLine(info, x, y)\n                        // prevent text from getting stuck under nodes\n                        return setDiagramLineProps(diagram, lineId, {\n                            textPos: clamp(0.1, 0.9,\n                                           round(snap && 0.1, where.pos)),\n                            textOffset: round(snap && 10.0, where.offset),\n                        })\n                    }))\n                    e.stopPropagation()\n                } else if (e.buttons == 2 && e.ctrlKey == true) {\n                    update(modifyDiagram({superficial: true}, diagram =>\n                        setDiagramLineProps(diagram, lineId, {\n                            textPos: 0.5,\n                            textOffset: 0.0,\n                        })\n                    ))\n                    e.stopPropagation()\n                }\n            },\n        }, line.superline),\n        ...renderArrow(update, diagram, lineId, ambient),\n    )\n}\n\nfunction renderNode(update, editor, nodeIndex, frozen) {\n    const diagram = editor.snapshot.diagram\n    const node = diagram.nodes[nodeIndex]\n    let gChildren = [vnode(\"svg:title\", {},\n                           node.type == \"w3j\"\n                         ? `{${node.lines.join(\" \")}} #${nodeIndex}`\n                         : node.type == \"terminal\"\n                         ? `m[${node.variable}] #${nodeIndex}`\n                         : node.type)]\n\n    if (node.type == \"w3j\") {\n        const circularArrowSize = 30\n        const orientation = w3jOrientation(diagram, nodeIndex) > 0\n                          ? \"flipped \" : \"\"\n        gChildren.push(vnode(\"svg:circle\", {\n            \"class\": \"bg \" + orientation,\n            r: 20,\n        }))\n        gChildren.push(vnode(\"svg:circle\", {\n            \"class\": \"fg \" + orientation,\n            r: 18,\n        }))\n        gChildren.push(vnode(\"svg:circle\", {\n            \"class\": \"hit \" + orientation,\n            r: 25,\n        }))\n        gChildren.push(vnode(\"svg:use\", {\n            \"class\": \"arrow \" + orientation,\n            href: \"#clockwise\",\n            x: -circularArrowSize / 2,\n            y: -circularArrowSize / 2,\n            width: circularArrowSize,\n            height: circularArrowSize,\n        }))\n\n    } else if (node.type == \"terminal\") {\n        const frozenClass = frozen ? \"frozen \" : \"\"\n        gChildren.push(vnode(\"svg:circle\", {\n            \"class\": \"fg \" + frozenClass,\n            r: 8,\n        }))\n        gChildren.push(vnode(\"svg:circle\", {\n            \"class\": \"hit\",\n            r: 15,\n        }))\n\n    } else {\n        gChildren.push(vnode(\"svg:circle\", {\n            \"class\": \"fg\",\n            r: 20,\n        }))\n        gChildren.push(vnode(\"svg:circle\", {\n            \"class\": \"hit\",\n            r: 25,\n        }))\n        gChildren.push(vnode(\"svg:text\", {\n            \"class\": \"label\",\n        }))\n    }\n\n    return vnode(\"svg:g\", {\n        // prevent hover effects from sticking when nodes change\n        [VNODE_KEY]: objectId(node),\n        \"class\": \"node \"\n               + node.type + \" \"\n               + ((editor.trackStart.type == \"node\" &&\n                   editor.trackStart.nodeIndex == nodeIndex)\n               || (editor.trackStop.type == \"node\" &&\n                   editor.trackStop.nodeIndex == nodeIndex)\n                ? (editor.trackType + \" \") : \"\"),\n        transform: `translate(${node.x}, ${node.y})`,\n        onmouseenter: function(e) {\n            update(setHover({\n                type: \"node\",\n                nodeIndex: nodeIndex,\n            }))\n        },\n        onmouseleave: function(e) {\n            update(setHover({type: null}))\n        },\n        onmousedown: function(e) {\n            if (e.buttons == 1) {\n                update(startDrag(node.x, node.y, {\n                    // moving terminals and/or custom nodes\n                    // changes the semantics of the diagram\n                    superficial: node.type == \"w3j\",\n                }, (diagram, x, y, snap) =>\n                    setDiagramNodeProps(diagram, nodeIndex, {\n                        x: round(snap && 20.0, x),\n                        y: round(snap && 20.0, y),\n                    })\n                ))\n                e.stopPropagation()\n            } else if (e.buttons == 4) {\n                if (node.type == \"terminal\") {\n                    return\n                }\n                if (e.shiftKey) { // do it twice!\n                    update(modifyDiagram({equivalent: true}, diagram =>\n                        flipW3jRule(\n                            flipW3jRule(diagram, nodeIndex),\n                            nodeIndex)))\n                } else {\n                    update(modifyDiagram({equivalent: true}, diagram =>\n                        flipW3jRule(diagram, nodeIndex)))\n                }\n                e.stopPropagation()\n            } else if (e.buttons == 2) {\n                if (node.type == \"terminal\") {\n                    return\n                }\n                update(modifyDiagram({equivalent: true}, diagram =>\n                    threeArrowRule(diagram, nodeIndex)))\n                e.stopPropagation()\n            }\n        },\n    }, ...gChildren)\n}\n\nfunction cmpSuperlineId(x, y) {\n    if (x == \"0\") {\n        if (y == \"0\") {\n            return 0\n        }\n        return -1\n    }\n    if (y == \"0\") {\n        return +1\n    }\n    let d = x.length - y.length\n    if (d == 0) {\n        d = Number(x > y) - Number(x < y)\n    }\n    return d\n}\n\nconst GREEK_LATEX = {\n    \"Α\": \"A\",\n    \"α\": \"\\\\alpha\",\n    \"Β\": \"B\",\n    \"β\": \"\\\\beta\",\n    \"Γ\": \"\\\\Gamma\",\n    \"γ\": \"\\\\gamma\",\n    \"Δ\": \"\\\\Delta\",\n    \"δ\": \"\\\\delta\",\n    \"Ε\": \"E\",\n    \"ε\": \"\\\\varepsilon\",\n    \"ϵ\": \"\\\\epsilon\",\n    \"Ζ\": \"Z\",\n    \"ζ\": \"\\\\zeta\",\n    \"Η\": \"H\",\n    \"η\": \"\\\\eta\",\n    \"Θ\": \"\\\\Theta\",\n    \"θ\": \"\\\\theta\",\n    \"ϑ\": \"\\\\vartheta\",\n    \"Ι\": \"I\",\n    \"ι\": \"\\\\iota\",\n    \"Κ\": \"K\",\n    \"κ\": \"\\\\kappa\",\n    \"ϰ\": \"\\\\varkappa\",\n    \"Λ\": \"\\\\Lambda\",\n    \"λ\": \"\\\\lambda\",\n    \"Μ\": \"M\",\n    \"μ\": \"\\\\mu\",\n    \"Ν\": \"N\",\n    \"ν\": \"\\\\nu\",\n    \"Ξ\": \"\\\\Xi\",\n    \"ξ\": \"\\\\xi\",\n    \"Ο\": \"O\",\n    \"ο\": \"o\",\n    \"Π\": \"\\\\Pi\",\n    \"π\": \"\\\\pi\",\n    \"ϖ\": \"\\\\varpi\",\n    \"Ρ\": \"P\",\n    \"ρ\": \"\\\\rho\",\n    \"ϱ\": \"\\\\varrho\",\n    \"Σ\": \"\\\\Sigma\",\n    \"σ\": \"\\\\sigma\",\n    \"ς\": \"\\\\varsigma\",\n    \"Τ\": \"T\",\n    \"τ\": \"\\\\tau\",\n    \"Υ\": \"Y\",\n    \"ϒ\": \"\\\\Upsilon\",\n    \"υ\": \"\\\\upsilon\",\n    \"Φ\": \"\\\\Phi\",\n    \"φ\": \"\\\\varphi\",\n    \"ϕ\": \"\\\\phi\",\n    \"Χ\": \"X\",\n    \"χ\": \"\\\\chi\",\n    \"Ψ\": \"\\\\Psi\",\n    \"ψ\": \"\\\\psi\",\n    \"Ω\": \"\\\\Omega\",\n    \"ω\": \"\\\\omega\",\n}\nconst GREEK_LETTERS = \"ΑαΒβΓγΔδΕεϵΖζΗηΘθϑΙιΚκϰΛλΜμΝνΞξΟοΠπϖΡρϱΣσςΤτΥϒυΦφϕΧχΨψΩω\"\nconst IDENT_CHAR_REGEX = `['′_.,\\\\w${GREEK_LETTERS}]`\n\nfunction isValidSuperlineId(superlineId) {\n    // prevent exotic characters from messing up the delta input syntax\n    return !!new RegExp(`^${IDENT_CHAR_REGEX}+$`).exec(superlineId)\n}\n\nfunction isLoopLine(line) {\n    return line.node(0).type == \"w3j\"\n        && line.node(0).index == line.node(1).index\n        && (line.superlineId == \"0\" || line.direction % 2)\n}\n\nfunction editSummed(diagram, superlineId) {\n    if (superlineId == \"0\") {\n        return \"\"\n    }\n    if (isSuperlineExposed(diagram, superlineId)) {\n        return \"\"\n    }\n    const superline = diagram.superlines[superlineId]\n    // special case: eliminate summations through deltas\n    if (superline.summed) {\n        const deltas = diagram.deltas\n        const found = findDeltaEntry(deltas, superlineId)\n        if (found) {\n            const deltas = diagram.deltas\n            const newSuperlineId = deltas[found[0]][(found[1] + 1) %\n                deltas[found[0]].length]\n            const summed = diagram.superlines[superlineId].summed\n                        && diagram.superlines[newSuperlineId].summed\n            diagram = new Diagram(diagram).renameSuperlines({\n                    [superlineId]: newSuperlineId,\n                }).rawDiagram\n            diagram = Object.assign({}, diagram)\n            diagram.superlines = Object.assign({}, diagram.superlines)\n            diagram.superlines[newSuperlineId] = Object.assign(\n                {}, diagram.superlines[newSuperlineId], {summed: summed})\n            return {\n                equivalent: true,\n                diagram: diagram,\n            }\n        }\n    }\n    diagram = deepClone(diagram)\n    diagram.superlines[superlineId].summed =\n        !superline.summed\n    return {\n        equivalent: false,\n        diagram: diagram\n    }\n}\n\nfunction introSum(diagram, superlineId) {\n    // introduce sum[j_fresh] delta[j_fresh j]\n    const freshSuperlineId = availSuperlineLabels(diagram).next().value\n    diagram = deepClone(diagram)\n    diagram.superlines[freshSuperlineId] = Object.assign({}, EMPTY_SUPERLINE, {\n        summed: true,\n    })\n    diagram.deltas = mergeDeltas(diagram.deltas, [\n        [superlineId, freshSuperlineId],\n    ])\n    return {\n        equivalent: true,\n        diagram: diagram,\n    }\n}\n\nfunction renderJTableau(update, superlines, editor) {\n    const frozen = editor.snapshot.frozen\n    const focus = editor.focus\n    return Array.from(new Set(\n        Object.keys(superlines).concat(\"0\")\n    )).sort(cmpSuperlineId).map(superlineId => {\n        const focusedName = focus.type == \"tableauJName\"\n                         && focus.superlineId == superlineId\n        const superline = superlineId == \"0\"\n                        ? EMPTY_SUPERLINE\n                        : superlines[superlineId]\n        const twoJ = vnode(\"span\", {\"class\": \"two-j\"}, \"\\u2022\\u2022\")\n        let phase\n        switch (mod(superline.phase, 4)) {\n            case 0:\n                phase = [\"\\xa0\\xa0\\xa0\"]\n                break\n            case 1:\n                phase = [\"\\u2022\\xa0\\xa0\"]\n                break\n            case 2:\n                phase = [twoJ, \"\\xa0\"]\n                break\n            case 3:\n                phase = [twoJ, \"\\u2022\"]\n                break\n        }\n        let weight = superline.weight\n                   ? (superline.weight > 0\n                    ? \"+\"\n                    : superline.weight < 0\n                    ? \"\\u2212\"\n                    : \"\")\n                   + Math.abs(superline.weight)\n                   : \"\"\n        return vnode(\n            \"tr\", {},\n            vnode(\"td\", {\n                \"class\": \"summed\",\n                onmousedown: function(e) {\n                    if (e.buttons == 1) {\n                        update(modifyDiagramWith(diagram =>\n                            editSummed(diagram, superlineId)))\n                        e.stopPropagation()\n                    } else if (e.buttons == 4) {\n                        update(modifyDiagramWith(diagram =>\n                            introSum(diagram, superlineId)))\n                        e.stopPropagation()\n                    }\n                },\n            }, superline.summed ? \"\\u2211\" : \"\"),\n            vnode(\"td\", {\n                \"class\": \"name\",\n                contenteditable: superlineId != \"0\",\n                spellcheck: \"false\",\n                [VNODE_SUSPEND_CHILDREN]: focusedName,\n                onfocus: function(e) {\n                    update(setFocus({\n                        type: \"tableauJName\",\n                        superlineId: superlineId,\n                    }))\n                },\n                onblur: function(e) {\n                    let newSuperlineId = this.textContent\n                    newSuperlineId = newSuperlineId.trim()\n                    if (!newSuperlineId) {\n                        newSuperlineId = \"0\"\n                    }\n                    update(editor => {\n                        modifyDiagramWith(diagram => {\n                            diagram = new Diagram(diagram)\n                            if (superlineId == newSuperlineId\n                                || !isValidSuperlineId(newSuperlineId)) {\n                                return \"\"\n                            }\n                            const superline = diagram.superline(superlineId)\n                            const deltas = diagram.rawDiagram.deltas\n                            // special case for loop lines, which can\n                            // change into anything\n                            if (frozen\n                                && superline.phase == 0\n                                && !superline.summed\n                                && !findDeltaEntry(deltas, superlineId)) {\n                                let numLoops = 0\n                                for (const line of diagram.lines()) {\n                                    if (line.superlineId == superlineId) {\n                                        if (isLoopLine(line)) {\n                                            numLoops += 1\n                                        } else {\n                                            numLoops = null\n                                            break\n                                        }\n                                    }\n                                }\n                                if (numLoops != null\n                                    && superline.weight == -numLoops) {\n                                    return {\n                                        equivalent: true,\n                                        diagram: diagram.renameSuperlines({\n                                            [superlineId]: newSuperlineId,\n                                        }).rawDiagram,\n                                    }\n                                }\n                            }\n                            return {\n                                equivalent: superline.summed\n                                         && !diagram.superline(newSuperlineId),\n                                diagram: diagram.renameSuperlines({\n                                    [superlineId]: newSuperlineId,\n                                }).rawDiagram,\n                            }\n                        })(editor)\n                        clearFocus(editor)\n                    })\n                },\n            }, superlineId == \"0\"\n                ? vnode(\"span\", {\"class\": \"zero\"}, \"0\")\n                : superlineId),\n            vnode(\"td\", Object.assign({\n                \"class\": \"phase \"\n                       + (editor.drag.type == \"phase\"\n                       && editor.drag.superlineId == superlineId ? \"drag \" : \"\")\n                       + (editor.drop.type == \"phase\"\n                       && editor.drop.superlineId == superlineId ? \"drop \" : \"\"),\n                oncontextmenu: function(e) { e.preventDefault() },\n                onmousedown: function(e) {\n                    if (e.buttons == 2) {\n                        update(modifyDiagram({}, diagram => {\n                            return Object.assign({}, diagram, {\n                                superlines: mergeSuperlineLists(\n                                    diagram.superlines,\n                                    {[superlineId]: {phase: +1}}),\n                            })\n                        }))\n                        e.stopPropagation()\n                        e.preventDefault()\n                    } else if (e.buttons == 4) {\n                        update(modifyDiagram({}, diagram => {\n                            return Object.assign({}, diagram, {\n                                superlines: mergeSuperlineLists(\n                                    diagram.superlines,\n                                    {[superlineId]: {phase: -1}}),\n                            })\n                        }))\n                        e.stopPropagation()\n                        e.preventDefault()\n                    }\n                },\n            }, handleDrag(update, (editor, e) => ({\n                type: \"phase\",\n                superlineId: superlineId,\n            })), handleDrop(update, (editor, e) => {\n                if (editor.drag.type != \"phase\"\n                    || editor.drag.superlineId == superlineId\n                    || (editor.snapshot.frozen &&\n                        !containsDeltas(editor.snapshot.diagram.deltas,\n                                        [[editor.drag.superlineId,\n                                          superlineId]]))) {\n                    return null\n                }\n                return {\n                    type: \"phase\",\n                    superlineId: superlineId,\n                }\n            }, (editor, e) => {\n                modifyDiagramWith(diagram => {\n                    const equivalent = containsDeltas(diagram.deltas,\n                                                      [[editor.drag.superlineId,\n                                                        superlineId]])\n                    diagram = Object.assign({}, diagram, {\n                        superlines: mergeSuperlineLists(\n                            diagram.superlines,\n                            {\n                                [editor.drag.superlineId]: {phase: -1},\n                                [superlineId]: {phase: +1},\n                            }\n                        )\n                    })\n                    return {equivalent: equivalent, diagram: diagram}\n                })(editor)\n            })), ...phase),\n            vnode(\"td\", Object.assign({\n                \"class\": \"weight \"\n                       + (editor.drag.type == \"weight\"\n                       && editor.drag.superlineId == superlineId ? \"drag \" : \"\")\n                       + (editor.drop.type == \"weight\"\n                       && editor.drop.superlineId == superlineId ? \"drop \" : \"\"),\n                oncontextmenu: function(e) { e.preventDefault() },\n                onmousedown: function(e) {\n                    if (e.buttons == 2) {\n                        update(modifyDiagram({}, diagram => {\n                            return Object.assign({}, diagram, {\n                                superlines: mergeSuperlineLists(\n                                    diagram.superlines,\n                                    {[superlineId]: {weight: +1}}),\n                            })\n                        }))\n                        e.stopPropagation()\n                        e.preventDefault()\n                    } else if (e.buttons == 4) {\n                        update(modifyDiagram({}, diagram => {\n                            return Object.assign({}, diagram, {\n                                superlines: mergeSuperlineLists(\n                                    diagram.superlines,\n                                    {[superlineId]: {weight: -1}}),\n                            })\n                        }))\n                        e.stopPropagation()\n                        e.preventDefault()\n                    }\n                },\n            }, handleDrag(update, (editor, e) => ({\n                type: \"weight\",\n                superlineId: superlineId,\n            })), handleDrop(update, (editor, e) => {\n                if (editor.drag.type != \"weight\"\n                    || editor.drag.superlineId == superlineId\n                    || (editor.snapshot.frozen &&\n                        !containsDeltas(editor.snapshot.diagram.deltas,\n                                        [[editor.drag.superlineId,\n                                          superlineId]]))) {\n                    return null\n                }\n                return {\n                    type: \"weight\",\n                    superlineId: superlineId,\n                }\n            }, (editor, e) => {\n                modifyDiagramWith(diagram => {\n                    const equivalent = containsDeltas(diagram.deltas,\n                                                      [[editor.drag.superlineId,\n                                                        superlineId]])\n                    diagram = Object.assign({}, diagram, {\n                        superlines: mergeSuperlineLists(\n                            diagram.superlines,\n                            {\n                                [editor.drag.superlineId]: {weight: -1},\n                                [superlineId]: {weight: +1},\n                            }\n                        )\n                    })\n                    return {equivalent: equivalent, diagram: diagram}\n                })(editor)\n            })), weight),\n        )\n    })\n}\n\nfunction editDelta(deltaIndex, input) {\n    return diagram => {\n        const oldDeltas = diagram.deltas\n        let invalid = null\n        diagram = Object.assign({}, diagram)\n        diagram.deltas = oldDeltas.slice()\n        diagram.deltas.splice(\n            deltaIndex, 1,\n            ...input.split(/[;\\n]/).map(delta =>\n                delta.split(\"=\").map(s => {\n                    s = s.trim()\n                    if (s && !isValidSuperlineId(s)) {\n                        invalid = s\n                    }\n                    return s\n                }).filter(identity)))\n        if (invalid != null) {\n            return \"invalid label: \" + invalid\n        }\n        diagram.deltas = mergeDeltas(diagram.deltas)\n        diagram.superlines = Object.assign({}, diagram.superlines)\n        for (const delta of diagram.deltas) {\n            for (const j of delta) {\n                if (!diagram.superlines[j]) {\n                    diagram.superlines[j] = EMPTY_SUPERLINE\n                }\n            }\n        }\n        const inferredDeltas = inferDeltas(diagram)\n        const oldInferredDeltas = mergeDeltas(inferredDeltas, oldDeltas)\n        const newInferredDeltas = mergeDeltas(inferredDeltas, diagram.deltas)\n        let equivalent = equalDeltas(oldInferredDeltas, newInferredDeltas)\n        diagram = new Diagram(diagram)\n        if (!equivalent) {\n            // inferDeltas doesn't infer zero lines due to bridges between\n            // orientable subdiagrams for efficiency reasons; instead we look\n            // for the remaining j's in the zero delta and try to infer those\n            const oldZeroDelta = new Set(relatedDelta(oldInferredDeltas, \"0\"))\n            const newZeroDelta = new Set(relatedDelta(newInferredDeltas, \"0\"))\n            let diff = new Set([...oldZeroDelta, ...newZeroDelta]\n                .filter(x => !oldZeroDelta.has(x) || !newZeroDelta.has(x)))\n            const diffDelta = [\"0\", ...diff]\n            if (equalDeltas(mergeDeltas([diffDelta], oldInferredDeltas),\n                            mergeDeltas([diffDelta], newInferredDeltas))) {\n                for (const line of diagram.lines()) {\n                    if (diff.has(line.superlineId) && !line.testCuttability()) {\n                        diff.delete(line.superlineId)\n                    }\n                }\n                equivalent = diff.size == 0\n            }\n        }\n        return {\n            equivalent,\n            diagram: diagram.removeUnusedSuperlines().rawDiagram,\n        }\n    }\n}\n\nfunction renderDeltaJ(j) {\n    return j == \"0\"\n         ? vnode(\"span\", {\"class\": \"zero\"}, \"0\")\n         : String(j)\n}\n\nfunction renderDeltaTableau(update, deltas, focus, frozen) {\n    return vnode(\"ul\", {}, ...deltas.concat([null]).map((delta, deltaIndex) => {\n        const focused = focus.type == \"delta\"\n                     && focus.deltaIndex == deltaIndex\n        const children = delta == null\n                       ? [vnode(\"i\", {}, \"(create \\u03b4)\")]\n                       : arrayIntercalate(\" = \", Array.from(delta)\n                                                      .map(renderDeltaJ))\n        return vnode(\"li\", {\n            \"class\": delta == null ? \"tip \" : \"\",\n            contenteditable: \"true\",\n            spellcheck: \"false\",\n            [VNODE_SUSPEND_CHILDREN]: focused,\n            onmousedown: function(e) {\n                if (e.buttons == 4) {\n                    update(modifyDiagramWith(editDelta(deltaIndex, \"\")))\n                    e.preventDefault()\n                }\n            },\n            onfocus: function(e) {\n                if (delta == null) {\n                    this.textContent = \"\"\n                    // clearing the text somehow deselects the text\n                    // so this is a workaround\n                    let range = document.createRange()\n                    range.selectNodeContents(this)\n                    let sel = window.getSelection()\n                    sel.removeAllRanges()\n                    sel.addRange(range)\n                }\n                update(setFocus({type: \"delta\", deltaIndex: deltaIndex}))\n            },\n            onblur: function(e) {\n                const input = this.textContent\n                update(editor => {\n                    modifyDiagramWith(editDelta(deltaIndex, input))(editor)\n                    clearFocus(editor)\n                })\n            },\n        }, ...children)\n    }))\n}\n\nfunction renderVariable(type, name) {\n    if (type == \"j\" && name == \"0\") {\n        return \"0\"\n    }\n    name = name.replace(\"′\", \"'\")\n               .replace(\"_\", \"\\\\_\")\n               .replace(new RegExp(`[${GREEK_LETTERS}]`),\n                        x => GREEK_LATEX[x] + \" \")\n    return `${type}_{${name}}`\n}\n\nfunction renderEquationLine(diagram, nodeIndex, lineIndex, summedVars) {\n    const lineId = diagram.nodes[nodeIndex].lines[lineIndex]\n    const line = diagram.lines[lineId]\n    const otherIndex = otherNodeIndex(diagram.nodes, nodeIndex, lineIndex)\n    const otherNode = diagram.nodes[otherIndex]\n    // avoid redundant summation over an m-delta\n    const mName = otherNode.type == \"terminal\"\n                ? otherNode.variable\n                : lineId\n    const mNaked = renderVariable(\"m\", mName)\n    const jm = {\n        j: renderVariable(\"j\", diagram.lines[lineId].superline),\n        m: otherIndex < nodeIndex && line.direction != 0\n         ? `-${mNaked}`\n         : mNaked,\n    }\n    if (line.superline.summed) {\n        summedVars.js[jm.j] = true\n    }\n    if (otherNode.type != \"terminal\") {\n        summedVars.ms[mNaked] = true\n    }\n    return jm\n}\n\nfunction renderEquation(diagram, container) {\n    const nodes = diagram.nodes\n    let s = \"\"\n    let summedVars = {js: {}, ms: {}}\n    let phases = []\n    let mDeltas = []\n    nodes.forEach(function(node, nodeIndex) {\n        if (node.type == \"terminal\") {\n            const otherIndex = otherNodeIndex(nodes, nodeIndex, 0)\n            if (otherIndex > nodeIndex) {\n                return\n            }\n            const var1 = nodes[otherIndex].variable\n            const var2 = node.variable\n            if (var1 == var2) {\n                return\n            }\n            const m1 = renderVariable(\"m\", var1)\n            const m2 = renderVariable(\"m\", var2)\n            switch (diagram.lines[node.lines[0]].direction) {\n                case 0:\n                    mDeltas.push(`\\\\delta_{${m1}, ${m2}}`)\n                    break\n                case -1:\n                    mDeltas.push(`\\\\delta_{${m1}, -${m2}}`)\n                    break\n                case 1:\n                    mDeltas.push(`\\\\delta_{-${m1}, ${m2}}`)\n                    break\n                default:\n                    throw new Error(`unnormalized direction: ${direction}`)\n            }\n        } else if (node.type == \"w3j\") {\n            s += \"\\\\begin{pmatrix}\"\n            let jRow = \"\"\n            let mRow = \"\"\n            node.lines.forEach(function(lineId, lineIndex) {\n                if (lineIndex > 0) {\n                    jRow += \" & \"\n                    mRow += \" & \"\n                }\n                const jm = renderEquationLine(diagram, nodeIndex,\n                                              lineIndex, summedVars)\n                jRow += jm.j\n                mRow += jm.m\n            })\n            s += jRow + \" \\\\\\\\\"\n            s += mRow + \" \\\\\\\\\"\n            s += \"\\\\end{pmatrix}\"\n        } else {\n            s += \"\\\\mathtt{${node.type}}_{\"\n            node.lines.forEach(function(lineId, lineIndex) {\n                if (lineIndex > 0) {\n                    s += \" \"\n                }\n                const jm = renderEquationLine(diagram, nodeIndex,\n                                              lineId, summedVars)\n                s += jm[0] + \" \" + jm[1]\n            })\n            s += \"}\"\n        }\n    })\n    let weights = \"\"\n    Object.keys(diagram.superlines).forEach(function(superlineId) {\n        const superline = diagram.superlines[superlineId]\n        const jVar = renderVariable(\"j\", superlineId)\n        switch (mod(superline.phase, 4)) {\n            case 0:\n                break\n            case 1:\n                phases.push(`+ ${jVar}`)\n                break\n            case 2:\n                phases.push(`+ 2 ${jVar}`)\n                break\n            case 3:\n                phases.push(`- ${jVar}`)\n                break\n        }\n        if (superline.weight == 0) {\n        } else if (superline.weight == 2) {\n            weights += ` (2 ${jVar} + 1)`\n        } else if (superline.weight % 2 == 0) {\n            weights += ` (2 ${jVar} + 1)^{${superline.weight / 2}}`\n        } else {\n            weights += ` (2 ${jVar} + 1)^{${superline.weight} / 2}`\n        }\n    })\n    Object.keys(diagram.lines).forEach(function(lineId) {\n        const line = diagram.lines[lineId]\n        let name\n        switch (line.direction) {\n            case 0:\n                return\n            case -1:\n                const node2 = nodes[endNodeIndices(nodes, lineId)[1]]\n                if (node2.type == \"terminal\") {\n                    name = node2.variable\n                } else {\n                    name = lineId\n                }\n                break\n            case 1:\n                const node1 = nodes[endNodeIndices(nodes, lineId)[0]]\n                if (node1.type == \"terminal\") {\n                    name = node1.variable\n                } else {\n                    name = lineId\n                }\n                break\n            default:\n                throw new Error(`unnormalized direction: ${direction}`)\n        }\n        const j = renderVariable(\"j\", diagram.lines[lineId].superline)\n        const m = renderVariable(\"m\", name)\n        phases.push(`+ ${j} ${line.direction < 0 ? \"+\" : \"-\"} ${m}`)\n    })\n    let summedVarsStr =\n        Object.keys(summedVars.js)\n              .concat(Object.keys(summedVars.ms)).join(\", \")\n    if (summedVarsStr) {\n        summedVarsStr = `\\\\sum_{${summedVarsStr}}`\n    }\n    let phasesStr = phases.join(\" \")\n    if (phasesStr) {\n        if (phasesStr.startsWith(\"+ \")) {\n            phasesStr = phasesStr.substr(2)\n        }\n        phasesStr = `(-1)^{${phasesStr}}`\n    }\n    const mDeltasStr = mDeltas.join(\" \")\n    const jDeltas = diagram.deltas.map(js => {\n        if (js.length < 2) {\n            return \"\"\n        }\n        const j0 = renderVariable(\"j\", js[0])\n        return js.slice(1)\n                 .map(j => `\\\\delta_{${j0} ${renderVariable(\"j\", j)}}`)\n                 .join(\" \")\n    }).join(\" \")\n    container.textContent = `\\\\[${summedVarsStr} ${jDeltas} ${mDeltasStr} `\n                          + `${weights} ${phasesStr} ${s}\\\\]`\n    MathJax.Hub.Queue([\"Typeset\", MathJax.Hub])\n}\n\nfunction renderTrack(trackType, start, stop) {\n    return [\n        vnode(\"svg:circle\", {\n            \"class\": trackType,\n            cx: start[0],\n            cy: start[1],\n            r: 8,\n        }),\n        vnode(\"svg:path\", {\n            \"class\": trackType,\n            d: `M ${start[0]} ${start[1]} `\n             + `L ${stop[0]} ${stop[1]} `,\n        }),\n        vnode(\"svg:circle\", {\n            \"class\": trackType,\n            cx: stop[0],\n            cy: stop[1],\n            r: 8,\n        }),\n    ]\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// State management\n//\n// The \"update\" function is responsible for making changes to the model (and\n// updating the DOM as needed).  It has type (&mut Editor -> ()) -> ().\n// In the future, \"update\" may ask for a Promise instead.\n\nconst ALT = 0x1\nconst CTRL = 0x2\nconst SHIFT = 0x4\n\nconst EMPTY_SNAPSHOT = {\n    diagram: EMPTY_DIAGRAM,\n    frozen: false,\n    showAmbient: true,\n}\n\nfunction newEditor() {\n    return {\n        snapshot: EMPTY_SNAPSHOT,\n        savedSnapshot: EMPTY_SNAPSHOT,\n        savedHash: \"\",\n        staleEquation: true,\n\n        // controls\n        error: \"\",\n        notice: \"An editor for angular momentum diagrams\",\n        hover: {type: null},\n        focus: {type: null},\n        drag: {type: null},\n        drop: {type: null},\n        mouseX: null,\n        mouseY: null,\n        trackType: null,\n        trackStart: {type: null, xy: null},\n        trackStop: {type: null, xy: null},\n    }\n}\n\nfunction saveEditor(editor) {\n    editor.savedSnapshot = editor.snapshot\n    editor.savedHash = \"#\" + encodeURIComponent(JSON.stringify(editor.snapshot))\n    window.location.hash = editor.savedHash\n}\n\nfunction loadEditor(editor) {\n    const hash = window.location.hash\n    // prevent hashchange listener from observing our own changes\n    if (hash.length < 3) {\n        Object.assign(editor, newEditor())\n    } else if (editor.savedHash != hash) {\n        editor.snapshot = JSON.parse(decodeURIComponent(hash.substr(1)))\n        editor.staleEquation = true\n        editor.savedSnapshot = editor.snapshot\n        editor.savedHash = hash\n    }\n}\n\nfunction toSvgCoords(p) {\n    if (!p) {\n        return p\n    }\n    const rect = document.getElementById(\"diagram\").getBoundingClientRect()\n    return [p[0] - rect.left, p[1] - rect.top]\n}\n\nfunction renderEditor(update, editor) {\n    const diagram = editor.snapshot.diagram\n    let ambient = null\n    if (editor.snapshot.showAmbient) {\n        // first try to match external lines (not needed, but looks nicer)\n        ambient = getAmbientDirections(new Diagram(diagram), false)\n        if (!ambient.orientable) {\n            // if it's not orientable, it might be because the external-line\n            // constraints aren't satisfiable\n            ambient = getAmbientDirections(new Diagram(diagram), true)\n        }\n    }\n    return [\n        {\n            element: window,\n            attributes: {\n                onhashchange: _ => update(loadEditor),\n                onkeydown: e => update(keyDown.bind(null, e)),\n                onmousemove: e => update(mouseMove(e)),\n                onmouseup: e => update(mouseUp(e)),\n            },\n        },\n        {\n            element: document.getElementsByTagName(\"body\")[0],\n            attributes: {\n                \"class\": editor.snapshot.frozen ? \"frozen\" : \"\",\n            },\n        },\n        {\n            element: document.getElementById(\"notice\"),\n            attributes: {\n                \"class\": editor.error ? \"warning\" : \"\",\n            },\n            children: [editor.error || editor.notice],\n        },\n        {\n            element: document.getElementById(\"freeze\"),\n            attributes: {\n                \"class\": editor.snapshot.frozen ? \"active\" : \"\",\n            },\n        },\n        {\n            element: document.getElementById(\"ambient\"),\n            attributes: {\n                \"class\": editor.snapshot.showAmbient ? \"active\" : \"\",\n            },\n        },\n        {\n            element: document.getElementById(\"diagram\"),\n            attributes: {\n                oncontextmenu: function(e) { e.preventDefault() },\n                onmousedown: e => {\n                    if (e.buttons == 4) {\n                        update(startTrack(e, \"track1\"))\n                        e.stopPropagation()\n                    } else if (e.buttons == 2) {\n                        update(startTrack(e, \"track2\"))\n                        e.stopPropagation()\n                    }\n                },\n            },\n        },\n        {\n            element: document.getElementById(\"diagram-lines\"),\n            children: Object.keys(diagram.lines).map(lineId =>\n                renderLine(update, editor, lineId, ambient)),\n        },\n        {\n            element: document.getElementById(\"diagram-nodes\"),\n            children: diagram.nodes.map((_, nodeIndex) =>\n                renderNode(update, editor, nodeIndex, editor.snapshot.frozen)),\n        },\n        {\n            element: document.getElementById(\"diagram-track\"),\n            children: editor.trackStop.xy != null\n                    ? renderTrack(editor.trackType,\n                                  toSvgCoords(editor.trackStart.xy),\n                                  toSvgCoords(editor.trackStop.xy))\n                    : [],\n        },\n        {\n            element: document.getElementById(\"tableau-body\"),\n            children: renderJTableau(update, diagram.superlines, editor),\n        },\n        {\n            // Kronecker delta relations\n            element: document.getElementById(\"delta-tableau\"),\n            children: [renderDeltaTableau(update, diagram.deltas,\n                                          editor.focus, editor.snapshot.frozen)],\n        },\n        {\n            element: document.getElementById(\"equation-container\"),\n            attributes: {\n                \"class\": editor.staleEquation ? \"stale\" : \"\",\n            },\n        },\n        {\n            element: document.getElementById(\"equation\"),\n            attributes: {\n                onclick: e => update(freshenEquation(e.currentTarget)),\n            },\n        },\n    ]\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Actions\n\n/** Supported boolean flags:\n *   transient,\n *   equivalent,\n *   superficial (implies equivalent),\n *   toggleFreeze (implies superficial),\n *   toggleAmbient (implies superficial),\n *   clearHover.\n */\nfunction modifyDiagram(flags, diagramTransform) {\n    return modifyDiagramWith(diagram => Object.assign(flags, {\n        diagram: diagramTransform(diagram),\n    }))\n}\n\n/** Similar to modifyDiagram, but gets the flags from the result of the\n   transformation. */\nfunction modifyDiagramWith(transformer) {\n    return editor => {\n        const result = transformer(editor.snapshot.diagram, editor.snapshot.frozen)\n        if (result == null || (typeof result == \"object\"\n                            && result.diagram == null)) {\n            setError(editor, \"not yet implemented\")\n            return\n        }\n        if (typeof result == \"string\") { // error?\n            setError(editor, result)\n            return\n        }\n        const superficial = result.superficial\n                         || result.toggleFreeze\n                         || result.toggleAmbient\n        const equivalent = result.equivalent\n                        || superficial\n        const diagram = result.diagram\n        if (editor.snapshot.frozen && !equivalent) {\n            // nonequivalent changes are forbidden while frozen\n            return\n        }\n        if (typeof diagram == \"string\") { // error?\n            setError(editor, diagram)\n            return\n        }\n        editor.snapshot = Object.assign({}, editor.snapshot, {\n            diagram: diagram,\n            frozen: Boolean(result.toggleFreeze) != editor.snapshot.frozen,\n            showAmbient: Boolean(result.toggleAmbient) !=\n                editor.snapshot.showAmbient,\n        })\n        if (!result.transient) {\n            saveEditor(editor)\n        }\n        if (result.clearHover) {\n            setHover({type: null})(editor)\n        }\n        editor.staleEquation = !superficial || editor.staleEquation\n    }\n}\n\nfunction getModifiers(event) {\n    return event.altKey | (event.ctrlKey << 1) | (event.shiftKey << 2)\n}\n\nfunction freshenEquation(container) {\n    return editor => {\n        if (editor.staleEquation) {\n            editor.staleEquation = false\n            renderEquation(editor.snapshot.diagram, container)\n        }\n    }\n}\n\nlet errorTimeout = 0\nfunction setError(editor, msg) {\n    editor.error = msg\n    if (errorTimeout) {\n        window.clearTimeout(errorTimeout)\n    }\n    errorTimeout = window.setTimeout(function() {\n        const update = getUpdate(editor)\n        update(editor => editor.error = \"\")\n    }, 10000)\n}\n\nfunction setHover(entity) {\n    return editor => {\n        editor.hover = entity\n    }\n}\n\nfunction setFocus(entity) {\n    return editor => {\n        editor.focus = entity\n    }\n}\n\nconst clearFocus = setFocus({type: null})\n\nfunction handleDrag(update, canDrag) {\n    return {\n        [ENABLE_DRAG]: \"true\",\n        draggable: \"true\",\n        ondragstart: function(e) {\n            // Firefox needs this to work\n            e.dataTransfer.setData(\"text/plain\", null)\n            update(editor => {\n                const dragState = canDrag.call(this, editor, e)\n                if (dragState) {\n                    editor.drag = dragState\n                }\n            })\n        },\n        ondragend: function(e) {\n            update(editor => editor.drag = {type: null})\n        },\n    }\n}\n\nfunction handleDrop(update, canDrop, drop) {\n    function dragleave(e) {\n        update(editor => editor.drop = {type: null})\n    }\n    return {\n        ondragenter: function(e) {\n            update(editor => {\n                const dropState = canDrop.call(this, editor, e)\n                if (dropState) {\n                    editor.drop = dropState\n                }\n            })\n        },\n        ondragleave: dragleave,\n        ondragexit: dragleave,\n        ondragover: function(e) {\n            update(editor => {\n                const dropState = canDrop.call(this, editor, e)\n                if (dropState) {\n                    editor.drop = dropState\n                    e.preventDefault()\n                }\n            })\n        },\n        ondrop: function(e) {\n            update(editor => {\n                e.preventDefault()\n                drop.call(this, editor, e)\n                editor.drag = {type: null}\n                editor.drop = {type: null}\n            })\n        },\n    }\n}\n\nfunction startTrack(event, trackType) {\n    return editor => {\n        editor.trackType = trackType\n        editor.trackStart.xy = [event.clientX, event.clientY]\n        if (editor.hover.type == \"line\") {\n            editor.trackStart.type = \"line\"\n            editor.trackStart.lineId = editor.hover.lineId\n        }\n    }\n}\n\nfunction updateTrack(event) {\n    return editor => {\n        if (editor.trackStart.xy == null) {\n            return\n        }\n        editor.trackStop.xy = [event.clientX, event.clientY]\n        if (editor.trackStart.type != null) {\n            if (editor.hover.type == \"line\") {\n                editor.trackStop.type = \"line\"\n                editor.trackStop.lineId = editor.hover.lineId\n            } else if (editor.hover.type == \"node\") {\n                editor.trackStop.type = \"node\"\n                editor.trackStop.nodeIndex = editor.hover.nodeIndex\n            } else {\n                editor.trackStop.type = null\n            }\n        }\n    }\n}\n\nfunction isSuperlineOfLineUnique(diagram, lineId) {\n    const line0 = diagram.lines[lineId]\n    if (line0.superline == \"0\") {\n        return false\n    }\n    for (const [id, line] of Object.entries(diagram.lines)) {\n        if (id != lineId &&\n            line.superline == line0.superline) {\n            return false\n        }\n    }\n    return !findDeltaEntry(diagram.deltas, line0.superline)\n}\n\nfunction generateLoopSuperline(diagram, lineId) {\n    let line = new Diagram(diagram).line(lineId)\n    if (!isLoopLine(line)) {\n        return null\n    }\n    if (isSuperlineOfLineUnique(diagram, lineId)) {\n        return diagram\n    }\n    // a loop line can become whatever it wants\n    diagram = Object.assign({}, diagram)\n    const newLabel = availSuperlineLabels(diagram).next().value\n    const oldLabel = diagram.lines[lineId].superline\n    if (line.lineIndex(0) == 0\n        && line.lineIndex(1) == 2) {\n        line = line.reverse()\n    }\n    diagram.lines = Object.assign({}, diagram.lines, {\n        [lineId]: Object.assign({}, diagram.lines[lineId], {\n            direction: line.reversed ? -1 : 1,\n            superline: newLabel,\n        })\n    })\n    const phase = line.direction == -1 ? 2 : 0\n    diagram.superlines = mergeSuperlineLists(diagram.superlines, {\n        [oldLabel]: ensureSuperline({weight: +1, phase: phase}),\n        [newLabel]: ensureSuperline({weight: -1}),\n    })\n    return new Diagram(diagram).removeUnusedSuperlines().rawDiagram\n}\n\nfunction finishTrack(editor, event) {\n    if (editor.trackStop.xy == null\n        || (editor.trackStart.type == editor.trackStop.type\n         && editor.trackStart.nodeIndex == editor.trackStop.nodeIndex\n         && editor.trackStart.lineId == editor.trackStop.lineId\n         && vectorSquare(vectorSubtract(editor.trackStart.xy,\n                                        editor.trackStop.xy)) < 10)) {\n        if (editor.trackStart.type == \"line\") {\n            if (editor.trackType == \"track2\") {\n                if (editor.snapshot.frozen) {\n                    modifyDiagram({equivalent: true}, diagram =>\n                        flipW1jRule(diagram, editor.trackStart.lineId))(editor)\n                } else {\n                    modifyDiagram({}, diagram =>\n                        addW1j(diagram, editor.trackStart.lineId))(editor)\n                }\n                return\n            } else if (editor.trackType == \"track1\") {\n                const lineId = editor.trackStart.lineId\n                if (editor.snapshot.frozen) {\n                    modifyDiagram({equivalent: true}, diagram => {\n                        const result = generateLoopSuperline(diagram, lineId)\n                        if (result) {\n                            return result\n                        }\n                        const line = Object.assign({}, diagram.lines[lineId])\n                        const found = findDeltaEntry(diagram.deltas, line.superline)\n                        if (!found) {\n                            return diagram\n                        }\n                        const [j, i] = found\n                        line.superline = diagram.deltas[j][(i + 1) %\n                            diagram.deltas[j].length]\n                        return Object.assign({}, diagram, {\n                            lines: Object.assign({}, diagram.lines, {\n                                [lineId]: line,\n                            }),\n                        })\n                    })(editor)\n                } else {\n                    modifyDiagram({}, diagram => {\n                        // don't bother if it's already unique\n                        if (isSuperlineOfLineUnique(diagram, lineId)) {\n                            return diagram\n                        }\n                        diagram = Object.assign({}, diagram)\n                        const newLabel = availSuperlineLabels(diagram).next().value\n                        diagram.lines = Object.assign({}, diagram.lines, {\n                            [lineId]: Object.assign({}, diagram.lines[lineId], {\n                                superline: newLabel,\n                            })\n                        })\n                        diagram.superlines = mergeSuperlineLists(diagram.superlines, {\n                            [newLabel]: EMPTY_SUPERLINE\n                        })\n                        return diagram\n                    })(editor)\n                }\n                return\n            }\n        }\n    } else {\n        const stopXy = toSvgCoords(editor.trackStop.xy)\n        const startXy = toSvgCoords(editor.trackStart.xy)\n        if (editor.trackType == \"track1\") { // red - middle\n            if (editor.trackStop.type == \"line\") {\n                if (editor.trackStart.lineId == editor.trackStop.lineId) {\n                    modifyDiagram({equivalent: true, clearHover: true}, diagram =>\n                        w3jElimRule(diagram, editor.trackStart.lineId))(editor)\n                } else {\n                    modifyDiagram({equivalent: true, clearHover: true}, diagram =>\n                        glueRule(diagram, editor.trackStart.lineId,\n                                 editor.trackStop.lineId,\n                                 startXy, stopXy))(editor)\n                }\n            } else if (editor.trackStart.type == \"line\") {\n                modifyDiagram({equivalent: true, clearHover: true}, diagram =>\n                    loopIntroRule(diagram,\n                                  editor.trackStart.lineId,\n                                  startXy,\n                                  stopXy))(editor)\n            }\n        } else if (editor.trackType == \"track2\") { // green - right\n            if (editor.trackStop.type == \"line\") {\n                if (editor.trackStart.lineId == editor.trackStop.lineId) {\n                    modifyDiagram({equivalent: true, clearHover: true}, diagram =>\n                        cutRule(diagram, editor.trackStart.lineId,\n                                startXy, stopXy))(editor)\n                } else {\n                    modifyDiagram({\n                        equivalent: true,\n                        clearHover: true,\n                    }, diagram => {\n                        // prefer orientable diagrams\n                        let candidateDiagram\n                        for (const diagonal of [false, true]) {\n                            candidateDiagram =\n                                w3jIntroRule(diagram,\n                                             editor.trackStart.lineId,\n                                             editor.trackStop.lineId,\n                                             event.shiftKey,\n                                             diagonal)\n                            const ambient = getAmbientDirections(\n                                new Diagram(candidateDiagram), true)\n                            if (ambient.orientable) {\n                                return candidateDiagram\n                            }\n                        }\n                        return candidateDiagram\n                    })(editor)\n                }\n            } else if (editor.trackStop.type == \"node\") {\n                modifyDiagram({equivalent: true, clearHover: true}, diagram =>\n                    loopElimRule(diagram,\n                                 editor.trackStart.lineId,\n                                 editor.trackStop.nodeIndex))(editor)\n            }\n        }\n    }\n}\n\nfunction clearTrack(editor, event) {\n    finishTrack(editor, event)\n    editor.trackType = null\n    editor.trackStart = {type: null, xy: null}\n    editor.trackStop = {type: null, xy: null}\n}\n\nfunction mouseUp(event) {\n    return editor => {\n        if (editor.dragger) {\n            modifyDiagram(editor.draggerFlags, identity)(editor)\n            editor.dragger = null\n        } else {\n            clearTrack(editor, event)\n        }\n        event.stopPropagation()\n        event.preventDefault()\n    }\n}\n\nconst ENABLE_DRAG = Symbol(\"ENABLE_DRAG\")\n\nfunction mouseMove(event) {\n    return editor => {\n        let svg = document.getElementById(\"diagram\")\n        const rect = svg.getBoundingClientRect()\n        editor.rawMouseX = event.clientX\n        editor.rawMouseY = event.clientY\n        editor.mouseX = event.clientX - rect.left\n        editor.mouseY = event.clientY - rect.top\n        if (editor.dragger) {\n            modifyDiagram(\n                Object.assign({}, editor.draggerFlags, {transient: true}),\n                diagram => editor.dragger(\n                    diagram,\n                    event.clientX + editor.dragOffsetX,\n                    event.clientY + editor.dragOffsetY,\n                    event.ctrlKey))(editor)\n            event.stopPropagation()\n        } else {\n            updateTrack(event)(editor)\n        }\n        // prevent user from selecting things by accident;\n        // we can't do this in mousedown, because that breaks deselection;\n        // we also can't use user-select, because that also breaks deselection\n        // (a textbox might *look* like it's deselected, but middle-click paste\n        // and backspace still works!);\n        // it also breaks dragging too ... be careful!\n        if (!vnodeGetSymbol(event.target, ENABLE_DRAG)\n            && editor.focus.type == null) {\n            event.preventDefault()\n        }\n    }\n}\n\nfunction startDrag(x, y, flags, dragger) {\n    return editor => {\n        editor.dragger = dragger\n        editor.draggerFlags = flags\n        editor.dragOffsetX = x - editor.rawMouseX\n        editor.dragOffsetY = y - editor.rawMouseY\n    }\n}\n\nfunction traverseElem(elem, f) {\n    if (!elem instanceof Element) {\n        return\n    }\n    f(elem)\n    let children = elem.children\n    for (const i of range(0, children.length)) {\n        traverseElem(children[i], f)\n    }\n}\n\nfunction applyStylesheet(stylesheet, elem) {\n    traverseElem(elem, elem => {\n        let style = []\n        for (const selector of Object.keys(stylesheet)) {\n            if (elem.matches(selector)) {\n                const rule = stylesheet[selector]\n                for (const prop of Object.keys(rule)) {\n                    const propName = prop.replace(/[A-Z]/g, c =>\n                        \"-\" + c.toLowerCase())\n                    if (propName == \"transform\") {\n                        // Inkscape doesn't handle transforms in style\n                        elem.setAttribute(propName, rule[prop])\n                    } else if (filter(propName)) {\n                        style.push(propName + \": \" + rule[prop])\n                    }\n                }\n            }\n        }\n        const inlineStyle = elem.getAttribute(\"style\")\n        if (inlineStyle) {\n            style.push(inlineStyle)\n        }\n        if (style.length) {\n            elem.setAttribute(\"style\", style.join(\"; \"))\n        }\n    })\n}\n\nlet prevKey\nfunction keyDown(e, editor) {\n    const snapshot = editor.snapshot\n    const update = f => f(editor)\n\n    if (prevKey == \"\\x3a\" && e.key == \"\\x33\") {\n        editor.notice = prevKey + e.key\n    }\n\n    // don't steal focus when editing text\n    if (editor.focus.type != null) {\n        return\n    }\n\n    // reload\n    if (getModifiers(e) == 0 && e.key == \"r\") {\n        window.location.href = \"\"\n        e.preventDefault()\n        return\n    }\n\n    // help\n    if (getModifiers(e) == SHIFT && e.key == \"?\") {\n        window.location.href = document.getElementById(\"help-link\").href;\n        e.preventDefault()\n        return\n    }\n\n    // help\n    if (getModifiers(e) == 0 && e.key == \"v\") {\n        update(modifyDiagram({toggleAmbient: true}, identity))\n        e.preventDefault()\n        return\n    }\n\n    // mouse events require the position\n    if (editor.mouseX === null) {\n        return\n    }\n\n    // create Clebsch-Gordan coefficient\n    if (getModifiers(e) == 0 && e.key == \"f\") {\n        update(modifyDiagram({toggleFreeze: true}, identity))\n        e.preventDefault()\n        return\n    }\n\n    // create Clebsch-Gordan coefficient\n    if (getModifiers(e) == 0 && e.key == \"c\") {\n        update(modifyDiagram({}, diagram => {\n            const labels = Array.from(take(3, availSuperlineLabels(diagram)))\n            return mergeDiagrams(diagram,\n                                 cgDiagram(labels[0],\n                                           labels[1],\n                                           labels[2],\n                                           editor.mouseX,\n                                           editor.mouseY))\n        }))\n        e.preventDefault()\n        return\n    }\n\n    // create Wigner 3-jm\n    if (getModifiers(e) == 0 && e.key == \"w\") {\n        update(modifyDiagram({}, diagram => {\n            const labels = Array.from(take(3, availSuperlineLabels(diagram)))\n            return mergeDiagrams(diagram, w3jDiagram(labels[0],\n                                                     labels[1],\n                                                     labels[2],\n                                                     editor.mouseX,\n                                                     editor.mouseY))\n        }))\n        e.preventDefault()\n        return\n    }\n\n    // attach\n    if (getModifiers(e) == 0 && e.key == \"a\") {\n        update(modifyDiagram({}, diagram => {\n            const nearest = nearestNodeIndices(diagram.nodes, 2,\n                                               editor.mouseX,\n                                               editor.mouseY)\n            if (!(nearest.length == 2 &&\n                  diagram.nodes[nearest[0]].type == \"terminal\" &&\n                  diagram.nodes[nearest[1]].type == \"terminal\")) {\n                return \"no nearby terminals found\"\n            } else {\n                return joinTerminals(diagram, nearest[0], nearest[1])\n            }\n        }))\n        e.preventDefault()\n        return\n    }\n\n    // create Wigner 1-jm\n    if (getModifiers(e) == 0 && e.key == \"m\" && editor.hover.type == \"line\") {\n        update(modifyDiagram({}, diagram =>\n            addW1j(diagram, editor.hover.lineId)))\n        e.preventDefault()\n        return\n    }\n\n    // add 2j phase / flip Wigner 3j node\n    if (getModifiers(e) == 0 && e.key == \"j\") {\n        if (editor.hover.type == \"line\") {\n            update(modifyDiagram({}, diagram =>\n                add2j(diagram, editor.hover.lineId)))\n            e.preventDefault()\n            return\n        } else if (editor.hover.type == \"node\") {\n            update(modifyDiagram({}, diagram =>\n                flipW3j(diagram, editor.hover.nodeIndex)))\n            e.preventDefault()\n            return\n        }\n    }\n\n    // delete node\n    if (getModifiers(e) == 0 && e.key == \"x\") {\n        update(modifyDiagram({}, diagram => {\n            const nodes = diagram.nodes\n            const nearest = nearestNodeIndices(nodes, 1,\n                                               editor.mouseX,\n                                               editor.mouseY)\n            if (nearest.length != 1 ||\n                (nodes[nearest[0]].type == \"terminal\" &&\n                 nodes[otherNodeIndex(nodes, nearest[0], 0)].type\n                    != \"terminal\")) {\n                return \"no nearby nodes found\"\n            } else {\n                return deleteNode(diagram, nearest[0])\n            }\n        }))\n        e.preventDefault()\n        return\n    }\n\n    // save as SVG\n    if (getModifiers(e) == 0 && e.key == \"s\") {\n        const diagram = document.getElementById(\"diagram\")\n        let svg = diagram.cloneNode(true)\n        const rect = diagram.getBoundingClientRect()\n        svg.setAttribute(\"viewBox\", `0 0 ${rect.width} ${rect.height}`)\n        applyStylesheet(diagramStylesheet, svg)\n        // downgrade href attribute to the deprecated xlink:href\n        traverseElem(svg, elem => {\n            const href = elem.getAttribute(\"href\")\n            if (href) {\n                elem.removeAttribute(\"href\")\n                elem.setAttributeNS(NAMESPACES.xlink, \"href\", href)\n            }\n        })\n        const url = URL.createObjectURL(\n            new Blob([new XMLSerializer().serializeToString(svg)],\n                     {type: \"image/svg+xml;charset=utf-8\"}))\n        let a = document.createElement(\"a\")\n        a.href = url\n        a.download = \"diagram.svg\"\n        document.getElementsByTagName(\"body\")[0].appendChild(a)\n        a.click()\n        a.remove()\n        URL.revokeObjectURL(url)\n    }\n\n    prevKey = e.key\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Global stuff\n\nfunction getUpdate(editor) {\n    return (...changes) => {\n        const update = getUpdate(editor)\n        const n = changes.length\n        for (let i = 0; i < n; ++i) {\n            changes[i](editor)\n        }\n        applyRendering(renderEditor(update, editor))\n    }\n}\n\nexport function main() {\n    let editor = {}\n    Object.assign(editor, newEditor())\n    const update = getUpdate(editor)\n    update(loadEditor)\n}\n","import * as script from './script.js'\n\nlet failed = false\n\nfunction assert(condition) {\n    failed = failed || !condition\n    console.assert(condition)\n}\n\nassert(script.permutSign([2, 1, 3], [2, 1, 3]) == 1)\n\nassert(JSON.stringify(script.mergeDeltas([\n    [1, 2],\n    [3, 4],\n])) == JSON.stringify([\n    [1, 2],\n    [3, 4],\n]))\n\nassert(JSON.stringify(script.mergeDeltas([\n    [1, 2],\n    [3, 4],\n    [2, 3],\n    [5, 6],\n])) == JSON.stringify([\n    [1, 2, 3, 4],\n    [5, 6],\n]))\n\nassert(script.containsDeltas([\n    [1, 2, 3, 4],\n    [5, 6],\n], [[5, 6]]))\n\nassert(script.containsDeltas([\n    [1, 2, 3, 4],\n    [5, 6],\n], [[5, 6]]))\n\nassert(JSON.stringify(script.removeDeltaEntry([\n    [1, 2, 3, 4],\n    [5, 6],\n], 6)) == JSON.stringify([\n    [1, 2, 3, 4],\n]))\n\nassert(JSON.stringify(script.relatedDelta([\n    [1, 2, 3, 4],\n    [5, 6],\n], 2)) == JSON.stringify([2, 1, 3, 4]))\n\n//////////////////////////////////////////////////////////////////////////////\n// Diagram.substitute\n\nconst d1 = script.ensureDiagram({\n    nodes: [\n        script.terminalNode(\"a\", \"a\", 0, 0),\n        script.terminalNode(\"a\", \"b\", 0, 0),\n    ],\n    lines: {\n        a: script.newLine(\"a\"),\n    },\n    superlines: {\n        a: script.EMPTY_SUPERLINE,\n    },\n})\n\nscript.assertEq(\n    new script.Diagram(d1).renameLines({a: \"b\"}).rawDiagram,\n    new script.Diagram(script.ensureDiagram({\n        nodes: [\n            script.terminalNode(\"b\", \"a\", 0, 0),\n            script.terminalNode(\"b\", \"b\", 0, 0),\n        ],\n        lines: {\n            b: script.newLine(\"a\"),\n        },\n        superlines: {\n            a: script.EMPTY_SUPERLINE,\n        },\n    })).rawDiagram)\n\nscript.assertEq(\n    new script.Diagram().substitute(\n        script.EMPTY_DIAGRAM,\n        script.EMPTY_DIAGRAM,\n    ).rawDiagram,\n    script.EMPTY_DIAGRAM,\n)\n\nscript.assertEq(\n    new script.Diagram(d1).substitute(\n        script.EMPTY_DIAGRAM,\n        script.EMPTY_DIAGRAM,\n    ).rawDiagram,\n    d1,\n)\n\nscript.assertEq(new script.Diagram(d1).substitute({\n    nodes: [\n        script.terminalNode(\"+a\", \"x\"),\n        script.terminalNode(\"+a\", \"y\"),\n    ],\n    lines: {\n        [\"+a\"]: {superline: \"a\", direction: 0},\n    },\n    superlines: {\n        a: script.EMPTY_SUPERLINE,\n    },\n}, {\n    nodes: [\n        script.terminalNode(\"a\", \"x\"),\n        script.terminalNode(\"a\", \"y\"),\n    ],\n    lines: {\n        a: {superline: \"a\", direction: 0},\n    },\n    superlines: {\n        a: script.EMPTY_SUPERLINE,\n    },\n}).rawDiagram, d1)\n\nscript.assertEq(new script.Diagram(d1).substitute({\n    nodes: [\n        script.terminalNode(\"+a\", \"x\"),\n        script.terminalNode(\"+a\", \"y\"),\n    ],\n    lines: {\n        \"+a\": {superline: \"a\", direction: 0},\n    },\n}, {\n    nodes: [\n        script.terminalNode(\"$1\", \"x\"),\n        script.terminalNode(\"$2\", \"y\"),\n        script.w3jNode(\"$4\", \"$4\", \"$3\"),\n        script.w3jNode(\"$3\", \"$2\", \"$1\"),\n    ],\n    lines: {\n        $4: {superline: \"0\", direction: +1},\n        $3: {superline: \"0\", direction: 0},\n        $2: {superline: \"a\", direction: 0},\n        $1: {superline: \"a\", direction: +1},\n    },\n    superlines: {\n        a: {weight: 1},\n    },\n}).rawDiagram, {\"nodes\":[{\"type\":\"terminal\",\"lines\":[\"4\"],\"variable\":\"a\",\"x\":0,\"y\":0},{\"type\":\"terminal\",\"lines\":[\"3\"],\"variable\":\"b\",\"x\":0,\"y\":0},{\"type\":\"w3j\",\"lines\":[\"1\",\"1\",\"2\"]},{\"type\":\"w3j\",\"lines\":[\"2\",\"3\",\"4\"]}],\"superlines\":{\"0\":{\"phase\":0,\"summed\":false,\"weight\":0},\"a\":{\"phase\":0,\"summed\":false,\"weight\":1}},\"lines\":{\"1\":{\"superline\":\"0\",\"direction\":0,\"arrowPos\":0.5,\"arcHeight\":0,\"angle\":0,\"textPos\":0.5,\"textOffset\":0},\"2\":{\"superline\":\"0\",\"direction\":0,\"arrowPos\":0.5,\"arcHeight\":0,\"angle\":0,\"textPos\":0.5,\"textOffset\":0},\"3\":{\"superline\":\"a\",\"direction\":0,\"arrowPos\":0.5,\"arcHeight\":0,\"angle\":0,\"textPos\":0.5,\"textOffset\":0},\"4\":{\"superline\":\"a\",\"direction\":1,\"arrowPos\":0.5,\"arcHeight\":0,\"angle\":0,\"textPos\":0.5,\"textOffset\":0}},\"deltas\":[]})\n\nif (!failed) {\n    document.getElementsByTagName(\"body\")[0].style.background = \"black\"\n}\n","module.exports = {\"g.line *\":{\"transition\":\"fill 0.3s, fill-opacity 0.3s, stroke 0.3s, stroke-opacity 0.3s\"},\"g.line path.bg,\\ng.line path.fg,\\ng.line path.hit\":{\"fill\":\"none\"},\"g.line path.bg\":{\"stroke\":\"#ffffff\",\"strokeOpacity\":\"0.7\",\"strokeWidth\":\"10\",\"strokeLinecap\":\"round\"},\"g.line path.hit\":{\"strokeOpacity\":\"0\",\"strokeWidth\":\"25\",\"strokeLinecap\":\"round\"},\"g.line:hover path.hit\":{\"stroke\":\"#e3bd2e\",\"strokeOpacity\":\"0.2\"},\"g.arrow:hover circle.hit\":{\"fill\":\"#e3bd2e\",\"fillOpacity\":\"0.2\"},\"g.node:hover circle.hit\":{\"fill\":\"#e3bd2e\",\"fillOpacity\":\"0.2\"},\"g.line path.fg\":{\"strokeWidth\":\"2\",\"stroke\":\"#051308\"},\"g.line path.pith\":{\"fill\":\"none\",\"stroke\":\"none\"},\"g.line.summed path.fg\":{\"strokeWidth\":\"6\"},\"g.line.summed path.pith\":{\"stroke\":\"white\",\"strokeWidth\":\"2\"},\"g.line text.label\":{\"fill\":\"#051308\",\"alignmentBaseline\":\"middle\",\"textAnchor\":\"middle\",\"fontSize\":\"large\"},\"g.line.two-j text.label\":{\"fill\":\"#3274b0\"},\"g.line.two-j path.fg\":{\"stroke\":\"#3274b0\"},\"g.line.two-j .arrowhead\":{\"fill\":\"#3274b0\"},\"g.line.zero path.fg\":{\"stroke\":\"#a89a9f\",\"fontWeight\":\"bold\"},\"g.line.zero text.label\":{\"fill\":\"#a89a9f\",\"fontWeight\":\"bold\"},\"g.line.zero .arrowhead\":{\"fill\":\"#a89a9f\",\"fontWeight\":\"bold\"},\"g.arrow.ambient .arrowhead\":{\"opacity\":\"0.35\"},\"g.arrow.bad .hit\":{\"fill\":\"#e74551\"},\"g.arrow.bad .arrowhead\":{\"fill\":\"#e74551\"},\"g.arrow.bad.external .arrowhead\":{\"fill\":\"#dcb406\"},\"g.arrow.bad circle.arrowhead\":{\"opacity\":\".7\"},\"g.arrow circle.hit\":{\"fillOpacity\":\"0\"},\"g.node *\":{\"transition\":\"fill 0.3s, fill-opacity 0.3s\"},\"g.node circle.bg,\\ng.node circle.hit\":{\"fill\":\"#ffffff\",\"fillOpacity\":\"0\"},\"g.node circle.fg\":{\"fill\":\"#dddddd\"},\"g.node text.label\":{\"alignmentBaseline\":\"middle\",\"textAnchor\":\"middle\",\"fontSize\":\"large\"},\"g.node.w3j circle.fg\":{\"fill\":\"#21b0ae\"},\"g.node.w3j circle.fg.flipped\":{\"fill\":\"#8d74c5\"},\"g.node.w3j use.arrow\":{\"fill\":\"white\"},\"g.node.w3j use.arrow.flipped\":{\"transform\":\"scale(-1,1)\"},\"g.node.terminal circle.fg\":{\"fill\":\"#000000\",\"fillOpacity\":\"0.3\"},\"g.node.terminal:hover circle.fg\":{\"fill\":\"#646464\",\"fillOpacity\":\"0.3\"},\"g.node.terminal circle.fg.frozen\":{\"fillOpacity\":\"0\"}}"],"sourceRoot":""}