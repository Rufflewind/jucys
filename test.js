(()=>{var e={2859(e){e.exports={"g.line *":{transition:"fill 0.3s, fill-opacity 0.3s, stroke 0.3s, stroke-opacity 0.3s"},"g.line path.bg,\ng.line path.fg,\ng.line path.hit":{fill:"none"},"g.line path.bg":{stroke:"#ffffff",strokeOpacity:.7,strokeWidth:10,strokeLinecap:"round"},"g.line path.hit":{strokeOpacity:0,strokeWidth:25,strokeLinecap:"round"},"g.line:hover path.hit":{stroke:"#e3bd2e",strokeOpacity:.2},"g.arrow:hover circle.hit":{fill:"#e3bd2e",fillOpacity:.2},"g.node:hover circle.hit":{fill:"#e3bd2e",fillOpacity:.2},"g.line path.fg":{strokeWidth:2,stroke:"#051308"},"g.line path.pith":{fill:"none",stroke:"none"},"g.line.summed path.fg":{strokeWidth:6},"g.line.summed path.pith":{stroke:"white",strokeWidth:2},"g.line text.label":{fill:"#051308",alignmentBaseline:"middle",textAnchor:"middle",fontSize:"large"},"g.line.two-j text.label":{fill:"#3274b0"},"g.line.two-j path.fg":{stroke:"#3274b0"},"g.line.two-j .arrowhead":{fill:"#3274b0"},"g.line.zero path.fg":{stroke:"#a89a9f",fontWeight:"bold"},"g.line.zero text.label":{fill:"#a89a9f",fontWeight:"bold"},"g.line.zero .arrowhead":{fill:"#a89a9f",fontWeight:"bold"},"g.arrow.ambient .arrowhead":{opacity:.35},"g.arrow.bad .hit":{fill:"#e74551"},"g.arrow.bad .arrowhead":{fill:"#e74551"},"g.arrow.bad.external .arrowhead":{fill:"#dcb406"},"g.arrow.bad circle.arrowhead":{opacity:.7},"g.arrow circle.hit":{fillOpacity:0},"g.node *":{transition:"fill 0.3s, fill-opacity 0.3s"},"g.node circle.bg,\ng.node circle.hit":{fill:"#ffffff",fillOpacity:0},"g.node circle.fg":{fill:"#dddddd"},"g.node text.label":{alignmentBaseline:"middle",textAnchor:"middle",fontSize:"large"},"g.node.w3j circle.fg":{fill:"#21b0ae"},"g.node.w3j circle.fg.flipped":{fill:"#8d74c5"},"g.node.w3j use.arrow":{fill:"white"},"g.node.w3j use.arrow.flipped":{transform:"scale(-1,1)"},"g.node.terminal circle.fg":{fill:"#000000",fillOpacity:.3},"g.node.terminal:hover circle.fg":{fill:"#646464",fillOpacity:.3},"g.node.terminal circle.fg.frozen":{fillOpacity:0}}}},t={};function r(n){var i=t[n];if(void 0!==i)return i.exports;var s=t[n]={exports:{}};return e[n](s,s.exports,r),s.exports}(()=>{"use strict";function e(e){return e}function t(e,t){return e==t}function n(e,t){return e<t?-1:t<e?1:0}function i(e,t,r){const i=e.length,s=t.length,o=i<s?i:s;for(let n=0;n<o;++n){const i=r(e[n],t[n]);if(i)return i}return n(i,s)}function s(e,t){let r=new Map;for(const[n,i]of t.entries()){if(r.has(i))return 0;r.set(i,e[n])}let n=new Set(e),i=1;for(;n.size;){const e=n.values().next().value;n.delete(e);let t=e;do{if(!r.has(t))return 0;t=r.get(t),n.delete(t),i*=-1}while(t!=e);i*=-1}return i}function o(e,t){return(e%t+t)%t}function l(e,t){return e^t}function*a(e,t){for(let r=e;r<t;++r)yield r}function*c(e,t,r){r=r||0;for(const n of t)yield e(n,r),r+=1}function*f(e,t){for(const r of t)e(r)&&(yield r)}function d(e,t){e=e.slice(),(t=Array.from(t)).sort((e,t)=>t-e);const r=t.length;for(let n=0;n<r;++n){if(t[n]>=e.length)throw new Error("index out of range");e.splice(t[n],1)}return e}function u(e,t,r){return e.hasOwnProperty(t)?e[t]:r}function h(e,t){if(e===t)return null;if(typeof e!=typeof t)return{type:"typeMismatch",left:e,right:t};const r=Array.isArray(e),n=Array.isArray(t);if(r||n){if(r!=n)return{type:"typeMismatch",left:e,right:t};const i=e.length,s=t.length;if(i!=s)return{type:"lengthMismatch",left:i,right:s};for(const[r,n]of e.entries()){const e=h(n,t[r]);if(e)return{type:"propertyValueMismatch",prop:r,diff:e}}return null}if("object"==typeof e){const r=Object.getPrototypeOf(e),n=Object.getPrototypeOf(t);if(r!=n)return{type:"prototypeMismatch",left:r,right:n};for(const r of Object.keys(e)){if(!t.hasOwnProperty(r))return{type:"missingProperty",left:r};const n=h(e[r],t[r]);if(n)return{type:"propertyValueMismatch",prop:r,diff:n}}for(const r of Object.keys(t))if(!e.hasOwnProperty(r))return{type:"missingProperty",right:r};return null}return{type:"notEqual",left:e,right:t}}function p(e,t){const r=h(e,t);null!=r&&console.warn(e,t,r),console.assert(null==r)}r(2859),new WeakMap;const g={ZERO:0,ONE:1,add:(e,t)=>e+t,subtract:(e,t)=>e-t,multiply:(e,t)=>e*t,divide:(e,t)=>{if(!t)throw new Error("division by zero");return e/t},eq:t},m=Object.assign({},g,{add:l,subtract:l}),w=(y=y||t,b=void 0===b?0:b,class e{constructor(e){if(this.data=new Map,e)for(const[t,r]of e)this.set(t,r)}copy(){return new e(this)}[Symbol.iterator](){return this.data.entries()}keys(){return this.data.keys()}get(e){const t=this.data;return t.has(e)?t.get(e):b}set(e,t){y(t,b)?this.delete(e):this.data.set(e,t)}modify(e,t){this.set(e,t(this.get(e)))}delete(e){this.data.delete(e)}map(t){return new e(c(([e,r])=>[e,t(r,e)],this))}toTable(e){e=e||this.keys();let t={};for(const r of e)t[r]=this.get(r);return t}});var y,b;const O=(j=j||w,class e{constructor(e){if(this.data=new Map,e)for(const[t,r,n]of e)this.set(t,r,n)}copy(){return new e(this)}*[Symbol.iterator](){for(const[e,t]of this.rows())yield*c(([t,r])=>[e,t,r],t)}rows(){return c(e=>[e,this.row(e)],this.data.keys())}row(e){return function(e,t){if(!e.has(t)){const r=new j;return e.set(t,r),r}return e.get(t)}(this.data,e)}rowKeys(){return this.data.keys()}colKeys(){let e=new Set;for(const t of this.data.values())for(const r of t.keys())e.add(r);return e}get(e,t){return this.row(e).get(t)}set(e,t,r){this.row(e).set(t,r)}modify(e,t,r){this.set(e,t,r(this.get(e,t)))}deleteRow(e){this.data.delete(e)}map(t){return new e(c(([e,r,n])=>[e,r,t(n,r,e)],this))}toTable(e,t){e=e||this.rowKeys(),t=t||Array.from(this.colKeys());let r={};for(const n of e)r[n]=this.row(n).toTable(t);return r}});var j;function E(...e){let t=[],r={};return e.forEach(e=>e.forEach(e=>{if(e.length<2)return;let n=null;for(let t=0;t<e.length&&(n=r[e[t]],!n);++t);null==n&&(n=[[]],t.push(n[0])),e.forEach(e=>{const t=r[e];t?t[0]!=n[0]&&(n[0].push(...t[0]),t[0].splice(0,t[0].length),t[0]=n[0]):(n[0].push(e),r[e]=n)})})),Object.freeze(t.map(Object.freeze).filter(e=>e.length>1))}function v(e,t){e=E(e),t=E(t);let r={};e.forEach(e=>e.forEach(t=>r[t]=e));for(let e=0;e<t.length;++e){const n=t[e];let i=null;for(let e=0;e<n.length&&(i=r[n[e]],!i);++e);if(!i)return!1;for(let e=0;e<n.length;++e)if(r[n[e]]!=i)return!1}return!0}function x(e,t){for(let r=0;r<e.length;++r)for(let n=0;n<e[r].length;++n)if(e[r][n]==t)return[r,n];return null}function S(e,t){const r=x(e,t);if(!r)return[t];const[n,i]=r;return[t].concat(d(e[n],[i]))}Symbol("VNODE_KEY"),Symbol("VNODE_SUSPEND_CHILDREN"),Symbol("VNODE_SYMBOLS"),Symbol("VNODE_EVENT_LISTENERS");const k=Object.freeze({phase:0,summed:!1,weight:0});function D(e){return!e.phase&&!e.summed&&!e.weight}function z(...e){let t=Object.assign({},k);return e.forEach(e=>{t.phase=o(t.phase+(e.phase||0),4),t.weight+=e.weight||0,null!=e.summed&&(t.summed=e.summed)}),Object.freeze(t)}function N(...e){let t={};for(const r of e)for(const e of Object.keys(r)){if("0"==e){t[e]=k;continue}const n=t[e];let i=r[e];n&&(i=z(n,i)),t[e]=i}for(const e of Object.keys(t))0!=e.phase||0!=e.weight||e.summed||delete t[e];return Object.freeze(t)}const P=Object.freeze({superline:"0",direction:0,arrowPos:.5,arcHeight:0,angle:0,textPos:.5,textOffset:0});function I(e){return L({superline:e})}function L(e){return Object.freeze(Object.assign({},P,e))}function R(e){return null!=(e=Object.assign({},e)).direction&&(e.direction=-e.direction),null!=e.arrowPos&&(e.arrowPos=1-e.arrowPos),null!=e.arcHeight&&(e.arcHeight=-e.arcHeight),null!=e.angle&&(e.angle=o(e.angle+Math.PI,2*Math.PI)),null!=e.textPos&&(e.textPos=1-e.textPos),null!=e.textOffset&&(e.textOffset=-e.textOffset),Object.freeze(e)}function M(...e){return o(function(e){let t=0;for(const r of e)t+=r;return t}(e)+1,4)-1}function _(...e){e.length;const t=["arrowPos","arcHeight","textPos","textOffset"];let r={},n=0,i=0,s=0,o={};for(const e of t)o[e]=0;for(const[l,a]of e.entries()){if(0==l)r.superline=a.superline;else if(r.superline!=a.superline)throw new Error("cannot add lines with different superlines");null!=a.direction&&(null==r.direction&&(r.direction=0),r.direction=M(r.direction,a.direction));for(const e of t)null!=a[e]&&(null==r[e]&&(r[e]=0),r[e]+=a[e],o[e]+=1);null!=a.angle&&(n+=Math.sin(a.angle),i+=Math.cos(a.angle),s+=1)}for(const e of t)o[e]&&(r[e]/=o[e]);return s&&(r.angle=Math.atan2(n,i)),Object.freeze(r)}function A(...e){const t=function(e){let t=e.direction%2,r=2*o(Math.trunc(e.direction/2),2);return"0"==e.superline&&(t=0,r=0),{line:Object.freeze(Object.assign({},e,{direction:t})),phase:r}}(_(...e.map(t=>Object.assign({},t,{superline:e[0].superline}))));return{line:t.line,phase:t.phase,delta:e.map(e=>e.superline)}}function $(e,t,r,n){let i={type:"terminal",lines:Object.freeze([e]),variable:t};return null!=r&&(i.x=r),null!=n&&(i.y=n),Object.freeze(i)}function H(e,t,r,n,i){let s={type:"w3j",lines:Object.freeze([e,t,r])};return void 0!==n&&(s.x=n),void 0!==i&&(s.y=i),Object.freeze(s)}const J=Object.freeze({nodes:Object.freeze([]),superlines:Object.freeze({}),lines:Object.freeze({}),deltas:Object.freeze([])});function W(e){return Object.freeze(Object.assign({},J,e))}class T{constructor(e,t,r){console.assert(e),this.diagram=e,this.id=t,this.reversed=Boolean(r),Object.freeze(this)}get rawLine(){return this.diagram.rawDiagram.lines[this.id]}get line(){return(this.reversed?R:e)(this.diagram.rawDiagram.lines[this.id])}get superline(){return this.diagram.superline(this.superlineId)}get superlineId(){return this.line.superline}get direction(){return null==this.rawLine.direction?null:this.rawLine.direction*(1-2*this.reversed)}node(e){const t=this.diagram._lineEnds[this.id];return new V(this.diagram,t[(this.reversed+e)%2*2])}lineIndex(e){return this.diagram._lineEnds[this.id][(this.reversed+e)%2*2+1]}cycNodeLine(e,t){return this.node(e).line((this.lineIndex(e)+t)%3)}toString(){return(this.reversed?"-":"+")+this.id}signedRebase(e){return e.signedLine(this.id,this.reversed)}reverse(){return new T(this.diagram,this.id,!this.reversed)}concat(...e){return _(e.map(e=>e.line))}static removeSign(e){const t=e.substr(1);let r=!1;if("-"==e[0])r=!r;else if("+"!=e[0])throw new Error(`not a valid signed line ID: ${e}`);return[t,r]}rawAssign(e,t,r){e.nodes[this.node(t).index].lines[this.lineIndex(t)]=r}testCuttability(){let t=[B(this),B(this.reverse())].filter(e);return 2==t.length?(t.sort((e,t)=>e.priority-t.priority),t[0].error):null}}class V{constructor(e,t){this.diagram=e,this.index=t,Object.freeze(this)}get rawNode(){return this.diagram.rawDiagram.nodes[this.index]}get type(){return this.rawNode.type}get variable(){if("terminal"!=this.type)throw new Error("node is not a terminal");return this.rawNode.variable}get numLines(){return this.rawNode.lines.length}line(e){const t=this.rawNode.lines[e],r=this.diagram._lineEnds[t],n=r[2]==this.index&&r[3]==e;return new T(this.diagram,t,n)}lines(){return c(e=>this.line(e),a(0,this.numLines))}get xy(){return[this.rawNode.x,this.rawNode.y]}}class q{constructor(e){this.rawDiagram=Object.freeze(e)||J,this._cache={},Object.freeze(this)}static deserialize(e){return new q(JSON.parse(e))}get serialize(){return JSON.stringify(this.rawDiagram)}get _lineEnds(){let e=this._cache.lineEnds;return e||(e=function(e){let t={};return e.nodes.forEach((e,r)=>{e.lines.forEach((e,s)=>{let o=t[e];if(o){if(2!=o.length)throw new Error("line must be connected to exactly 2 nodes");i([o[0],o[1]],[r,s],n)<0?t[e].push(r,s):t[e].splice(0,0,r,s)}else t[e]=[r,s]})}),t}(this.rawDiagram),this._cache.lineEnds=e),e}get terminals(){let e=this._cache.terminals;if(!e){e={};for(const t of this.nodes())if("terminal"==t.type){if(e[t.variable])throw new Error("duplicate terminal variables");e[t.variable]=t}this._cache.terminals=e}return e}terminal(e){return this.terminals[e]}get numNodes(){return this.rawDiagram.nodes.length}node(e){return new V(this,e)}*nodes(){const e=this.numNodes;for(let t=0;t<e;++t)yield this.node(t)}get lineIds(){return Object.keys(this.rawDiagram.lines)}signedLine(e,t){const[r,n]=T.removeSign(e);return this.line(r,n!=Boolean(t))}line(e,t){return new T(this,e,t)}lines(){return c(e=>this.line(e),this.lineIds)}get superlines(){return this.rawDiagram.superlines}superline(e){return this.superlines[e]}hasSuperline(e){return!!this.superline(e)}isEquallyConstrained(e,t){return r=[S(this.rawDiagram.deltas,e)],n=[S(t,e)],v(r,n)&&v(n,r);var r,n}renameLines(e){let t={};for(const r of Object.keys(this.rawDiagram.lines))t[e.hasOwnProperty(r)?e[r]:r]=this.rawDiagram.lines[r];const r=this.rawDiagram.nodes.map(t=>Object.freeze(Object.assign({},t,{lines:Object.freeze(t.lines.map(t=>u(e,t,t)))})));return new q(Object.assign({},this.rawDiagram,{nodes:Object.freeze(r),lines:Object.freeze(t)}))}desumExposedSuperlines(){return new q(Object.assign({},this.rawDiagram,{superlines:N(this.rawDiagram.superlines,...Object.entries(this.rawDiagram.superlines).map(([e,t])=>function(e,t){for(const r of e.nodes)if("terminal"==r.type&&e.lines[r.lines[0]].superline==t)return!0;return!1}(this.rawDiagram,e)?{[e]:{summed:!1}}:{}))}))}renameSuperlines(e){return new q(Object.assign({},this.rawDiagram,{lines:Object.freeze(Object.assign({},...Object.entries(this.rawDiagram.lines).map(([t,r])=>({[t]:Object.freeze(Object.assign({},r,{superline:u(e,r.superline,r.superline)}))})))),superlines:N(...Object.entries(this.rawDiagram.superlines).map(([t,r])=>({[u(e,t,t)]:r}))),deltas:E(this.rawDiagram.deltas.map(t=>t.map(t=>u(e,t,t))))})).removeUnusedSuperlines().desumExposedSuperlines()}removeUnusedSuperlines(){let e=Object.assign({},this.rawDiagram.superlines);for(const t of Object.keys(e))D(e[t])||delete e[t];for(const t of this.lines())delete e[t.superlineId];for(const t of this.rawDiagram.deltas)for(const r of t)delete e[r];let t=Object.assign({},this.rawDiagram.superlines);for(const r of Object.keys(e))delete t[r];return t[0]&&(t[0]=k),new q(Object.assign({},this.rawDiagram,{superlines:t}))}substitute(t,r,o){o=o||{},t=W(t),r=W(r);const l=this.rawDiagram,u=new q(t);let h=new q(r),p=[l.deltas,r.deltas];if(!v(l.deltas,t.deltas))throw new Error("mismatch in deltas");let g={},m={};for(const e of u.lines()){const t=T.removeSign(e.id)[0],r=m[t];if(r){if("terminal"!=r.node(0).type&&"terminal"!=r.node(1).type||"terminal"!=e.node(0).type&&"terminal"!=e.node(1).type)throw new Error("a single internal line cannot match multiple lines");if("terminal"==e.node(0).type&&"terminal"==e.node(1).type)throw new Error("a lone pattern line cannot be shared");if(g[e.id]||g[r.id])throw new Error("looped lines can only appear twice");g[e.id]=r.id,g[r.id]=e.id}else m[t]=e}let w=Object.assign({},l.lines);for(const e of u.lines()){const t=T.removeSign(e.id)[0];console.assert(w[t]||g[e.id]),delete w[t]}let y=(O=w,f(e=>!O.hasOwnProperty(e),c(e=>e.toString(),a(1,Number.POSITIVE_INFINITY)))),b={};var O;for(const e of h.lines())(e.id.startsWith("$")||w.hasOwnProperty(e.id))&&(b[e.id]=y.next().value);h=h.renameLines(b),r=h.rawDiagram;let j=[l.superlines],x=new Set;for(const e of Object.keys(t.superlines)){const n=t.superlines[e],i=l.superlines[e];if(n.summed){if("0"!=e){if(!i.summed)throw new Error("expected summed superline");if(n.weight!=i.weight)throw new Error("weight of summed superline must match");if(n.phase!=i.phase)throw new Error("phase of summed superline must match");if(!this.isEquallyConstrained(e,r.deltas))throw new Error("deltas of summed superline must match");x.add(e)}j.push({[e]:{summed:!1}})}j.push({[e]:{weight:-n.weight,phase:-n.phase}})}for(const e of Object.keys(r.superlines))if(r.superlines[e].summed){const r=t.superlines[e];if(r){if(!r.summed)throw new Error("summed variable conflicts with pattern")}else if(l.superlines[e])throw new Error("summed variable conflicts with original")}j.push(r.superlines);for(const e of u.nodes()){if("terminal"==e.type)continue;if(0==e.numLines)throw new Error("singleton nodes are not supported");const t=e.line(0).signedRebase(this).node(0);if(t.type!=e.type)throw new Error("node type mismatch");const r=Array.from(t.rawNode.lines),o=Array.from(e.rawNode.lines);if("w3j"==t.type){const e=s(r,r),t=s(r,o.map(e=>T.removeSign(e)[0]));if(e&&0==t)throw new Error("node lines mismatch");t<0&&j.push({[r[0]]:{phase:1}},{[r[1]]:{phase:1}},{[r[2]]:{phase:1}})}else if(0!=i(r,o,n))throw new Error("node lines mismatch")}let S=new Set;for(const e of u.lines()){const t=e.node(0),r=e.node(1),n=e.signedRebase(this);if(n.superlineId!=e.superlineId)throw new Error("superline ID mismatch in lines");if("terminal"!=t.type&&"terminal"!=r.type&&null!=e.direction){const t=M(n.direction,-e.direction);if("0"!=n.superlineId&&t%2!=0)throw new Error("directedness mismatch in lines");j.push({[n.superlineId]:{phase:t}})}S.add(n.id)}new Set(Object.keys(t.superlines));for(const e of this.lines())if(!S.has(e.id)&&x.has(e.superlineId))throw new Error("summed line must not appear outside match");let k=l.nodes.map(e=>Object.assign({},e,{lines:e.lines.slice()})),D=r.nodes.map(e=>Object.assign({},e,{lines:e.lines.slice()})),z={};const P=e=>{let t=[e.line];for(;;){const r=e.node(1),n={type:"replacement",lines:t,line:e,lineId:e.id,nodes:D};if("terminal"!=r.type)return n;const i=u.terminal(r.variable);if(!i)return n;z[e.id]=!0;const s=i.line(0),o=s.signedRebase(this).reverse();"terminal"==s.node(1).type&&s.reversed||t.push(s.line,o.line);const l=g[s.id];if(!l)return{type:"original",lines:t,line:o,lineId:e.id,nodes:k};const a=u.line(l,s.reversed),c=a.node(0);if("terminal"!=c.type)throw new Error("expected terminal node");if(t.push(a.reverse().line),e=h.terminal(c.variable).line(0),z[e.id])return{type:"cycle",lines:t};t.push(e.line)}};function I(e){switch(e.type){case"replacement":return"terminal"==e.line.node(1).type?-1:1;case"original":return 0;default:throw new Error("joining type not valid here")}}for(const t of h.lines()){if(z[t.id])continue;const r=P(t.reverse());if("cycle"==r.type){const e=A(...r.lines);if(p.push([e.delta]),e.line.direction%2)throw new Error("directed loops are forbidden");j.push({[e.line.superline]:{phase:e.phase,weight:2}});continue}const s=P(t),o=r.lineId,l=r.line.node(1).index,a=s.line.node(1).index,c=r.line.lineIndex(1),f=s.line.lineIndex(1),d=r.lines.map(R).reverse().concat(s.lines.slice(1)),u=i([I(r),l,c],[I(s),a,f],n)>0?R:e;r.nodes[l].lines[c]=o,s.nodes[a].lines[f]=o;const h=A(...d);p.push([h.delta]),console.assert(!w[o]);let g=h.line.superline;for(const e of h.delta)if(!this.superline(e)||!this.superline(e).summed){g=e;break}w[o]=L(u(Object.assign({},h.line,{superline:g}))),j.push({[h.line.superline]:{phase:h.phase}})}const _=Array.prototype.concat(r.nodes.filter((e,t)=>"terminal"==e.type&&!u.terminal(e.variable)),d(k,Array.from(c(e=>e.line(0).signedRebase(this).node(0).index,f(e=>"terminal"!=e.type,u.nodes())))),r.nodes.filter(e=>"terminal"!=e.type)),$=new q(Object.assign({},l,{nodes:_,lines:w,superlines:N(...j),deltas:E(...p)})).removeUnusedSuperlines();return o.withLineRenames?{diagram:$,lineRenames:b}:$}}function B(e){const t=function(e){let t=!0,r=!0,n=new Set,i={},s=[e];for(;s.length>0;){const o=s.pop();if(i.hasOwnProperty(o.id)){o.id==e.id&&o.reversed==e.reversed&&(r=!1);continue}const l=o.node(1);"terminal"==l.type&&(t=!1),n.add(l.index),i[o.id]=o.rawLine;for(const e of l.lines())s.push(e)}const o=e.diagram.rawDiagram;return{closed:t,isolated:r,diagram:Object.assign({},o,{nodes:o.nodes.filter((e,t)=>n.has(t)),lines:i})}}(e);if(!t.isolated)return{error:"only bridges can be cut",priority:1};if(!t.closed)return{error:"subdiagram must be closed",priority:2};const r=Object.assign({},t.diagram);return r.lines=Object.assign({},r.lines),r.lines[e.id]=Object.assign({},r.lines[e.id],{superline:"0"}),function(e,t){let r=[],n=new w;for(const i of e.lines())"0"!=i.superlineId&&([i.node(0).type,i.node(1).type].includes("terminal")&&(t||i.direction%2==0)&&r.push(i.id),n.set(i.id,1-o(i.direction,2)));let i=new O;for(const t of e.nodes())if("w3j"==t.type)for(const e of t.lines())"0"!=e.superlineId&&i.modify(e.id,t.index,t=>t+(e.reversed?-1:1));let s=n.copy(),l=i.map(e=>o(e,2));for(const e of r)s.delete(e),l.deleteRow(e);const a=function(e,t,r){t=t.copy(),r=r.copy();let n=new Set(t.rowKeys()),i=Array.from(t.colKeys()).reverse(),s=[],o=[];for(const e of r.keys())n.add(e);for(;i.length;){const l=i.pop();let a,c=null;for(const r of n)if(a=t.get(r,l),!e.eq(a,e.ZERO)){c=r;break}if(null==c){s.push(l);continue}o.push([c,l]),n.delete(c);const f=e.divide(e.ONE,a);for(const r of i)t.modify(c,r,t=>e.multiply(f,t));r.modify(c,t=>e.multiply(f,t));for(const s of n){const n=t.get(s,l);if(!e.eq(n,e.ZERO)){for(const r of i)t.modify(s,r,i=>e.subtract(i,e.multiply(n,t.get(c,r))));r.modify(s,t=>e.subtract(t,e.multiply(n,r.get(c))))}}}let l=!0;for(const t of n)if(!e.eq(r.get(t),e.ZERO)){l=!1;break}let a=new r.constructor;for(const t of i)a.set(t,e.ZERO);for(const t of s)a.set(t,e.ZERO);o.reverse();for(const[n,[i,s]]of o.entries()){let l=r.get(i);for(const[r,[s,c]]of o.entries()){if(r>=n)break;l=e.subtract(l,t.get(i,c)*a.get(c))}a.set(s,l)}return{consistent:l,solution:a,unconstrained:s}}(m,l,s),c=function(e,t,r){let n=new r.constructor;for(const[i,s]of t.rows()){let t=e.ZERO;for(const[n,i]of s)t=e.add(t,e.multiply(s.get(n),r.get(n)));n.set(i,t)}return n}(g,i,a.solution.map(e=>-e));return{orientable:a.consistent,directions:c,target:s}}(new q(r),!0).orientable?null:{error:"diagram is non-orientable",priority:0}}Symbol("ENABLE_DRAG");let K=!1;function Z(e){K=K||!e,console.assert(e)}Z(1==s([2,1,3],[2,1,3])),Z(JSON.stringify(E([[1,2],[3,4]]))==JSON.stringify([[1,2],[3,4]])),Z(JSON.stringify(E([[1,2],[3,4],[2,3],[5,6]]))==JSON.stringify([[1,2,3,4],[5,6]])),Z(v([[1,2,3,4],[5,6]],[[5,6]])),Z(v([[1,2,3,4],[5,6]],[[5,6]])),Z(JSON.stringify(function(e){const t=x(e,6);if(!t)return e;const[r,n]=t;return Object.freeze(Object.assign([],e,{[r]:Object.freeze(d(e[r],[n]))})).filter(e=>e.length>1)}([[1,2,3,4],[5,6]]))==JSON.stringify([[1,2,3,4]])),Z(JSON.stringify(S([[1,2,3,4],[5,6]],2))==JSON.stringify([2,1,3,4]));const C=W({nodes:[$("a","a",0,0),$("a","b",0,0)],lines:{a:I("a")},superlines:{a:k}});p(new q(C).renameLines({a:"b"}).rawDiagram,new q(W({nodes:[$("b","a",0,0),$("b","b",0,0)],lines:{b:I("a")},superlines:{a:k}})).rawDiagram),p((new q).substitute(J,J).rawDiagram,J),p(new q(C).substitute(J,J).rawDiagram,C),p(new q(C).substitute({nodes:[$("+a","x"),$("+a","y")],lines:{"+a":{superline:"a",direction:0}},superlines:{a:k}},{nodes:[$("a","x"),$("a","y")],lines:{a:{superline:"a",direction:0}},superlines:{a:k}}).rawDiagram,C),p(new q(C).substitute({nodes:[$("+a","x"),$("+a","y")],lines:{"+a":{superline:"a",direction:0}}},{nodes:[$("$1","x"),$("$2","y"),H("$4","$4","$3"),H("$3","$2","$1")],lines:{$4:{superline:"0",direction:1},$3:{superline:"0",direction:0},$2:{superline:"a",direction:0},$1:{superline:"a",direction:1}},superlines:{a:{weight:1}}}).rawDiagram,{nodes:[{type:"terminal",lines:["4"],variable:"a",x:0,y:0},{type:"terminal",lines:["3"],variable:"b",x:0,y:0},{type:"w3j",lines:["1","1","2"]},{type:"w3j",lines:["2","3","4"]}],superlines:{0:{phase:0,summed:!1,weight:0},a:{phase:0,summed:!1,weight:1}},lines:{1:{superline:"0",direction:0,arrowPos:.5,arcHeight:0,angle:0,textPos:.5,textOffset:0},2:{superline:"0",direction:0,arrowPos:.5,arcHeight:0,angle:0,textPos:.5,textOffset:0},3:{superline:"a",direction:0,arrowPos:.5,arcHeight:0,angle:0,textPos:.5,textOffset:0},4:{superline:"a",direction:1,arrowPos:.5,arcHeight:0,angle:0,textPos:.5,textOffset:0}},deltas:[]}),K||(document.getElementsByTagName("body")[0].style.background="black")})()})();
//# sourceMappingURL=test.js.map