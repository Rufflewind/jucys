{"version":3,"file":"index.js","mappings":"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","sources":["webpack://jucys/./diagram.css?192a","webpack://jucys/webpack/bootstrap","webpack://jucys/webpack/runtime/compat get default export","webpack://jucys/webpack/runtime/define property getters","webpack://jucys/webpack/runtime/hasOwnProperty shorthand","webpack://jucys/./script.js","webpack://jucys/./index.js"],"sourcesContent":["module.exports = {\"g.line *\":{\"transition\":\"fill 0.3s, fill-opacity 0.3s, stroke 0.3s, stroke-opacity 0.3s\"},\"g.line path.bg,\\ng.line path.fg,\\ng.line path.hit\":{\"fill\":\"none\"},\"g.line path.bg\":{\"stroke\":\"#ffffff\",\"strokeOpacity\":0.7,\"strokeWidth\":10,\"strokeLinecap\":\"round\"},\"g.line path.hit\":{\"strokeOpacity\":0,\"strokeWidth\":25,\"strokeLinecap\":\"round\"},\"g.line:hover path.hit\":{\"stroke\":\"#e3bd2e\",\"strokeOpacity\":0.2},\"g.arrow:hover circle.hit\":{\"fill\":\"#e3bd2e\",\"fillOpacity\":0.2},\"g.node:hover circle.hit\":{\"fill\":\"#e3bd2e\",\"fillOpacity\":0.2},\"g.line path.fg\":{\"strokeWidth\":2,\"stroke\":\"#051308\"},\"g.line path.pith\":{\"fill\":\"none\",\"stroke\":\"none\"},\"g.line.summed path.fg\":{\"strokeWidth\":6},\"g.line.summed path.pith\":{\"stroke\":\"white\",\"strokeWidth\":2},\"g.line text.label\":{\"fill\":\"#051308\",\"alignmentBaseline\":\"middle\",\"textAnchor\":\"middle\",\"fontSize\":\"large\"},\"g.line.two-j text.label\":{\"fill\":\"#3274b0\"},\"g.line.two-j path.fg\":{\"stroke\":\"#3274b0\"},\"g.line.two-j .arrowhead\":{\"fill\":\"#3274b0\"},\"g.line.zero path.fg\":{\"stroke\":\"#a89a9f\",\"fontWeight\":\"bold\"},\"g.line.zero text.label\":{\"fill\":\"#a89a9f\",\"fontWeight\":\"bold\"},\"g.line.zero .arrowhead\":{\"fill\":\"#a89a9f\",\"fontWeight\":\"bold\"},\"g.arrow.ambient .arrowhead\":{\"opacity\":0.35},\"g.arrow.bad .hit\":{\"fill\":\"#e74551\"},\"g.arrow.bad .arrowhead\":{\"fill\":\"#e74551\"},\"g.arrow.bad.external .arrowhead\":{\"fill\":\"#dcb406\"},\"g.arrow.bad circle.arrowhead\":{\"opacity\":0.7},\"g.arrow circle.hit\":{\"fillOpacity\":0},\"g.node *\":{\"transition\":\"fill 0.3s, fill-opacity 0.3s\"},\"g.node circle.bg,\\ng.node circle.hit\":{\"fill\":\"#ffffff\",\"fillOpacity\":0},\"g.node circle.fg\":{\"fill\":\"#dddddd\"},\"g.node text.label\":{\"alignmentBaseline\":\"middle\",\"textAnchor\":\"middle\",\"fontSize\":\"large\"},\"g.node.w3j circle.fg\":{\"fill\":\"#21b0ae\"},\"g.node.w3j circle.fg.flipped\":{\"fill\":\"#8d74c5\"},\"g.node.w3j use.arrow\":{\"fill\":\"white\"},\"g.node.w3j use.arrow.flipped\":{\"transform\":\"scale(-1,1)\"},\"g.node.terminal circle.fg\":{\"fill\":\"#000000\",\"fillOpacity\":0.3},\"g.node.terminal:hover circle.fg\":{\"fill\":\"#646464\",\"fillOpacity\":0.3},\"g.node.terminal circle.fg.frozen\":{\"fillOpacity\":0}}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","\"use strict\"\n\nimport \"./style.css\"\nimport \"./diagram.css\"\nimport diagramStylesheet from \"./diagram.css?postcss\"\n\n//////////////////////////////////////////////////////////////////////////////\n// Utility: Generic\n\nfunction identity(x) {\n    return x\n}\n\nfunction defaultEq(x, y) {\n    return x == y\n}\n\nfunction defaultCmp(x, y) {\n    if (x < y) {\n        return -1\n    } else if (y < x) {\n        return 1\n    } else {\n        return 0\n    }\n}\n\nfunction lexicalCmp(xs, ys, cmp) {\n    const nx = xs.length\n    const ny = ys.length\n    const n = nx < ny ? nx : ny\n    for (let i = 0; i < n; ++i) {\n        const r = cmp(xs[i], ys[i])\n        if (r) {\n            return r\n        }\n    }\n    return defaultCmp(nx, ny)\n}\n\nexport function permutSign(xs, ys) {\n    let permut = new Map()\n    for (const [i, y] of ys.entries()) {\n        if (permut.has(y)) {\n            return 0 // not a permutation\n        }\n        permut.set(y, xs[i])\n    }\n    let visited = new Set(xs)\n    let sign = 1\n    while (visited.size) {\n        const x0 = visited.values().next().value\n        visited.delete(x0)\n        let x = x0\n        do {\n            if (!permut.has(x)) {\n                return 0 // not a permutation\n            }\n            x = permut.get(x)\n            visited.delete(x)\n            sign *= -1\n        } while (x != x0)\n        sign *= -1\n    }\n    return sign\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Utility: Basic math\n\nfunction sgn(x) {\n    return x > 0 ? 1 : x < 0 ? -1 : 0\n}\n\n/** Floored modulo */\nfunction mod(x, y) {\n    return (x % y + y) % y\n}\n\nfunction clamp(min, max, x) {\n    if (x < min) {\n        return min\n    } else if (x > max) {\n        return max\n    } else {\n        return x\n    }\n}\n\nfunction round(dx, x) {\n    if (!dx) {\n        return x\n    }\n    return x + dx / 2 - mod(x + dx / 2, dx)\n}\n\nfunction bitXor(x, y) {\n    return x ^ y\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Utility: Iterators\n\nfunction* range(start, stop) {\n    for (let i = start; i < stop; ++i) {\n        yield i\n    }\n}\n\nfunction* map(f, xs, start) {\n    start = start || 0\n    for (const x of xs) {\n        yield f(x, start)\n        start += 1\n    }\n}\n\nfunction* filter(f, xs) {\n    for (const x of xs) {\n        if (f(x)) {\n            yield x\n        }\n    }\n}\n\nfunction* take(n, xs) {\n    let i = 0\n    for (const x of xs) {\n        if (i >= n) {\n            break\n        }\n        yield x\n        i += 1\n    }\n}\n\nfunction sum(xs) {\n    let s = 0\n    for (const x of xs) {\n        s += x\n    }\n    return s\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Utility: Arrays\n\nfunction arrayEqual(xs, ys, cmp) {\n    if (!cmp) {\n        cmp = defaultCmp\n    }\n    const length = xs.length\n    if (length != ys.length) {\n        return false\n    }\n    for (let i = 0; i < length; ++i) {\n        if (xs[i] != ys[i]) {\n            return false\n        }\n    }\n    return true\n}\n\nfunction arrayRemoveMany(xs, indices) {\n    xs = xs.slice()\n    indices = Array.from(indices)\n    // sort in reverse order\n    indices.sort((x, y) => y - x)\n    const n = indices.length\n    for (let i = 0; i < n; ++i) {\n        if (indices[i] >= xs.length) {\n            throw new Error(\"index out of range\")\n        }\n        xs.splice(indices[i], 1)\n    }\n    return xs\n}\n\nfunction arrayIntercalate(sep, xs) {\n    const n = xs.length\n    let ys = []\n    for (let i = 0; i < n; ++i) {\n        if (i != 0) {\n            ys.push(sep)\n        }\n        ys.push(xs[i])\n    }\n    return ys\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Utility: Objects\n\n// Kind of a hack -- hopefully we won't need this in the future.\nlet currentId = 0\nconst idMap = new WeakMap()\nfunction objectId(obj) {\n    if (!idMap.has(obj)) {\n        idMap.set(obj, ++currentId)\n    }\n    return idMap.get(obj)\n}\n\nfunction propOr(obj, prop, def) {\n    return obj.hasOwnProperty(prop)\n         ? obj[prop]\n         : def\n}\n\nfunction cachedGet(map, key, getDefault) {\n    if (!map.has(key)) {\n        const x = getDefault()\n        map.set(key, x)\n        return x\n    }\n    return map.get(key)\n}\n\nfunction deduplicateObject(obj, image) {\n    const ks = Object.keys(obj)\n    if (ks.length != Object.keys(image).length) {\n        return obj\n    }\n    ks.forEach(k => {\n        if (!(image.hasOwnProperty(k) && obj[k] === image[k])) {\n            return obj\n        }\n    })\n    return image\n}\n\nfunction deepClone(x) {\n    return JSON.parse(JSON.stringify(x))\n}\n\nfunction deepFreeze(obj) {\n    if (Object.isFrozen(obj)) {\n        return obj\n    }\n    Object.freeze(obj)\n    const keys = Object.keys(obj)\n    let i = keys.length\n    while (i--) {\n        deepFreeze(obj[keys[i]])\n    }\n    return obj\n}\n\nfunction deepDiff(x, y) {\n    if (x === y) {\n        return null\n    }\n    if (typeof x != typeof y) {\n        return {type: \"typeMismatch\", left: x, right: y}\n    }\n\n    const xIsArray = Array.isArray(x)\n    const yIsArray = Array.isArray(y)\n    if (xIsArray || yIsArray) {\n        if (xIsArray != yIsArray) {\n            return {type: \"typeMismatch\", left: x, right: y}\n        }\n        const nx = x.length\n        const ny = y.length\n        if (nx != ny) {\n            return {type: \"lengthMismatch\", left: nx, right: ny}\n        }\n        for (const [i, xi] of x.entries()) {\n            const diff = deepDiff(xi, y[i])\n            if (diff) {\n                return {type: \"propertyValueMismatch\", prop: i, diff: diff}\n            }\n        }\n        return null\n    }\n\n    if (typeof x == \"object\") {\n        const xProto = Object.getPrototypeOf(x)\n        const yProto = Object.getPrototypeOf(y)\n        if (xProto != yProto) {\n            return {type: \"prototypeMismatch\", left: xProto, right: yProto}\n        }\n        for (const k of Object.keys(x)) {\n            if (!y.hasOwnProperty(k)) {\n                return {type: \"missingProperty\", left: k}\n            }\n            const diff = deepDiff(x[k], y[k])\n            if (diff) {\n                return {type: \"propertyValueMismatch\", prop: k, diff: diff}\n            }\n        }\n        for (const k of Object.keys(y)) {\n            if (!x.hasOwnProperty(k)) {\n                return {type: \"missingProperty\", right: k}\n            }\n        }\n        return null\n    }\n    return {type: \"notEqual\", left: x, right: y}\n}\n\nexport function assertEq(x, y) {\n    const diff = deepDiff(x, y)\n    if (diff != null) {\n        console.warn(x, y, diff)\n    }\n    console.assert(diff == null)\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Geometry\n\nfunction linePointDistance(x1, y1, x2, y2, x0, y0) {\n    const rx = x0 - x1\n    const ry = y0 - y1\n    const lx = x2 - x1\n    const ly = y2 - y1\n    const l = Math.sqrt(lx * lx + ly * ly)\n    const proj = (rx * lx + ry * ly) / l\n    if (proj < l) {\n        // projection is within segment\n        return Math.abs(ly * x0 - lx * y0 + x2 * y1 - y2 * x1) / l\n    } else if (proj < 0) {\n        // projection is to the left of segment\n        return Math.sqrt(rx * rx + ry * ry)\n    } else {\n        // projection is to the right of segment\n        return Math.sqrt(Math.pow(x0 - x2, 2) + Math.pow(y0 - y2, 2))\n    }\n}\n\nfunction arcInfo(lineLength, arcHeight) {\n    if (arcHeight == 0.0) {\n        return {\n            inclination: 0.0,\n            radius: Infinity,\n            large: false,\n            sweep: false,\n        }\n    }\n    const halfLength = lineLength / 2\n    const radius = (halfLength * halfLength / arcHeight + arcHeight) / 2\n    const large = Math.abs(arcHeight) > halfLength\n    const sweep = arcHeight < 0\n    const theta = Math.asin(halfLength / radius)\n    return {\n        inclination: (large ? (sweep ? -1 : 1) * Math.PI - theta : theta),\n        radius: radius,\n        large: large,\n        sweep: sweep,\n    }\n}\n\n/** Get the height of the arc between 1 and 2 that also passes through 0. */\nfunction threePointArc(x0, y0, x1, y1, x2, y2) {\n    const ax = x1 - x2\n    const ay = y1 - y2\n    const bx = x2 - x0\n    const by = y2 - y0\n    const cx = x0 - x1\n    const cy = y0 - y1\n    const det = ay * cx - cy * ax\n    if (det == 0) {\n        return 0.0\n    }\n    const t = (cx * bx + cy * by) / det\n    const radius = 0.5 * Math.sqrt(Math.pow(ax - ay * t, 2)\n                                 + Math.pow(ay + ax * t, 2))\n    const side = -sgn(ay * bx - ax * by)\n    const arcHeight = side * radius - t / 2 * Math.sqrt(ax * ax + ay * ay)\n    return arcHeight\n}\n\n/** Choose smoothness = 1 for a Catmull-Rom spline. */\nfunction cardinalSpline(xs, ys, smoothness) {\n    const length = xs.length\n    if (length != ys.length) {\n        throw new Error(\"xs and ys must have same length\")\n    }\n    let d = \"\"\n    let prevSecantX, prevSecantY\n    for (let i = 0; i < length; ++i) {\n        if (i == 0) {\n            // do nothing\n            d += `M ${xs[i]} ${ys[i]} `\n            continue\n        }\n        if (i == 1 && i == length - 1) {\n            d += `L ${xs[i]} ${ys[i]} `\n            continue\n        }\n        const x01 = xs[i] - xs[i - 1]\n        const y01 = ys[i] - ys[i - 1]\n        const d01 = Math.sqrt(x01 * x01 + y01 * y01)\n        const x12 = xs[i + 1] - xs[i]\n        const y12 = ys[i + 1] - ys[i]\n        const d12 = Math.sqrt(x12 * x12 + y12 * y12)\n        let secantX = smoothness * (xs[i + 1] - xs[i - 1]) / (d01 + d12)\n        let secantY = smoothness * (ys[i + 1] - ys[i - 1]) / (d01 + d12)\n        if (i == 1) {\n            // natural condition (i.e. second derivative must vanish)\n            prevSecantX = (3.0 * x01 / d01 - secantX) / 2.0\n            prevSecantY = (3.0 * y01 / d01 - secantY) / 2.0\n        } else if (i == length - 1) {\n            // natural condition (i.e. second derivative must vanish)\n            secantX = (3.0 * x01 / d01 - prevSecantX) / 2.0\n            secantY = (3.0 * y01 / d01 - prevSecantY) / 2.0\n        }\n        const control1X = xs[i - 1] + prevSecantX * d01 / 3.0\n        const control1Y = ys[i - 1] + prevSecantY * d01 / 3.0\n        const control2X = xs[i] - secantX * d01 / 3.0\n        const control2Y = ys[i] - secantY * d01 / 3.0\n        d += `C ${control1X} ${control1Y} ${control2X} ${control2Y} `\n           + `${xs[i]} ${ys[i]}`\n        prevSecantX = secantX\n        prevSecantY = secantY\n    }\n    return d\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Algebra\n\nfunction vectorAdd(v0, ...vs) {\n    v0 = Array.from(v0)\n    for (const v of vs) {\n        for (const [i, vi] of v.entries()) {\n            v0[i] += vi\n        }\n    }\n    return v0\n}\n\nfunction vectorSubtract(v0, ...vs) {\n    v0 = Array.from(v0)\n    for (const v of vs) {\n        for (const [i, vi] of v.entries()) {\n            v0[i] -= vi\n        }\n    }\n    return v0\n}\n\nfunction vectorDot(v1, v2) {\n    let s = 0\n    for (const i of v1.keys()) {\n        s += v1[i] * v2[i]\n    }\n    return s\n}\n\nfunction vectorSquare(v) {\n    return vectorDot(v, v)\n}\n\nfunction scalarMultiply(c, v) {\n    v = Array.from(v)\n    for (const i of v.keys()) {\n        v[i] *= c\n    }\n    return v\n}\n\n/** Galois field of order 2. */\nconst REAL_FIELD = {\n    ZERO: 0,\n    ONE: 1,\n    add: (x, y) => x + y,\n    subtract: (x, y) => x - y,\n    multiply: (x, y) => x * y,\n    divide: (x, y) => {\n        if (!y) {\n            throw new Error(\"division by zero\")\n        }\n        return x / y\n    },\n    eq: defaultEq,\n}\n\n/** Galois field of order 2. */\nconst GF2_FIELD = Object.assign({}, REAL_FIELD, {\n    add: bitXor,\n    subtract: bitXor,\n})\n\nfunction newSparseVectorType(eq, zero) {\n    eq = eq || defaultEq\n    zero = zero === undefined ? 0 : zero\n    return class SparseVector {\n        constructor(iterable) {\n            this.data = new Map()\n            if (iterable) {\n                for (const [k, v] of iterable) {\n                    this.set(k, v)\n                }\n            }\n        }\n\n        copy() {\n            return new SparseVector(this)\n        }\n\n        [Symbol.iterator]() {\n            return this.data.entries()\n        }\n\n        keys() {\n            return this.data.keys()\n        }\n\n        get(key) {\n            const data = this.data\n            return data.has(key) ? data.get(key) : zero\n        }\n\n        set(key, value) {\n            if (eq(value, zero)) {\n                this.delete(key)\n            } else {\n                this.data.set(key, value)\n            }\n        }\n\n        modify(key, f) {\n            this.set(key, f(this.get(key)))\n        }\n\n        delete(key) {\n            this.data.delete(key)\n        }\n\n        map(f) {\n            return new SparseVector(map(([k, x]) => [k, f(x, k)], this))\n        }\n\n        toTable(keys) {\n            keys = keys || this.keys()\n            let t = {}\n            for (const k of keys) {\n                t[k] = this.get(k)\n            }\n            return t\n        }\n    }\n}\n\nconst RealSparseVector = newSparseVectorType()\n\nfunction newSparseMatrixType(SparseVector) {\n    SparseVector = SparseVector || RealSparseVector\n    return class SparseMatrix {\n        constructor(iterable) {\n            this.data = new Map()\n            if (iterable) {\n                for (const [i, j, x] of iterable) {\n                    this.set(i, j, x)\n                }\n            }\n        }\n\n        copy() {\n            return new SparseMatrix(this)\n        }\n\n        * [Symbol.iterator]() {\n            for (const [i, row] of this.rows()) {\n                yield* map(([j, x]) => [i, j, x], row)\n            }\n        }\n\n        rows() {\n            return map(i => [i, this.row(i)], this.data.keys())\n        }\n\n        row(i) {\n            return cachedGet(this.data, i, () => new SparseVector())\n        }\n\n        rowKeys() {\n            return this.data.keys()\n        }\n\n        colKeys() {\n            let js = new Set()\n            for (const row of this.data.values()) {\n                for (const j of row.keys()) {\n                    js.add(j)\n                }\n            }\n            return js\n        }\n\n        get(i, j) {\n            return this.row(i).get(j)\n        }\n\n        set(i, j, x) {\n            this.row(i).set(j, x)\n        }\n\n        modify(i, j, f) {\n            this.set(i, j, f(this.get(i, j)))\n        }\n\n        deleteRow(i) {\n            this.data.delete(i)\n        }\n\n        map(f) {\n            return new SparseMatrix(map(([i, j, x]) => [i, j, f(x, j, i)], this))\n        }\n\n        toTable(rowKeys, colKeys) {\n            rowKeys = rowKeys || this.rowKeys()\n            colKeys = colKeys || Array.from(this.colKeys())\n            let t = {}\n            for (const i of rowKeys) {\n                t[i] = this.row(i).toTable(colKeys)\n            }\n            return t\n        }\n    }\n}\n\nconst RealSparseMatrix = newSparseMatrixType()\n\nfunction sparseMatrixVectorMultiply(rng, matrix, vector) {\n    let r = new vector.constructor()\n    for (const [i, row] of matrix.rows()) {\n        let s = rng.ZERO\n        for (const [j, x] of row) {\n            s = rng.add(s, rng.multiply(row.get(j), vector.get(j)))\n        }\n        r.set(i, s)\n    }\n    return r\n}\n\n/** Sparse Gaussian elimination over an arbitrary field. */\nfunction sparseGaussElim(field, matrix, vector) {\n    // we are going to seriously mangle these\n    matrix = matrix.copy()\n    vector = vector.copy()\n\n    let is = new Set(matrix.rowKeys())\n    let js = Array.from(matrix.colKeys()).reverse()\n    let unconstrained = []\n    let pivots = []\n\n    // we care about the keys in vector too!\n    for (const i of vector.keys()) {\n        is.add(i)\n    }\n\n    // perform Gaussian elimination to obtain row echelon form;\n    // note that we don't bother changing the pivot column to 1 and 0's\n    // as we won't really need them afterward\n    while (js.length) {\n        const jp = js.pop()\n        let ip = null\n        let xp\n        for (const i of is) {\n            xp = matrix.get(i, jp)\n            if (!field.eq(xp, field.ZERO)) {\n                ip = i\n                break\n            }\n        }\n        if (ip == null) {\n            unconstrained.push(jp)\n            continue\n        }\n        pivots.push([ip, jp])\n        is.delete(ip)\n        const invXp = field.divide(field.ONE, xp)\n        for (const j of js) {\n            matrix.modify(ip, j, x => field.multiply(invXp, x))\n        }\n        vector.modify(ip, x => field.multiply(invXp, x))\n        for (const i of is) {\n            const c = matrix.get(i, jp)\n            if (!field.eq(c, field.ZERO)) {\n                for (const j of js) {\n                    matrix.modify(i, j, x => field.subtract(\n                        x, field.multiply(c, matrix.get(ip, j))))\n                }\n                vector.modify(i, x => field.subtract(\n                    x, field.multiply(c, vector.get(ip))))\n            }\n        }\n    }\n\n    // check for consistency among remaining rows\n    let consistent = true\n    for (const i of is) {\n        if (!field.eq(vector.get(i), field.ZERO)) {\n            consistent = false // no consistent solution\n            break\n        }\n    }\n\n    let solution = new vector.constructor()\n    for (const j of js) {\n        solution.set(j, field.ZERO)\n    }\n    for (const j of unconstrained) {\n        solution.set(j, field.ZERO) // arbitrarily pick zero\n    }\n\n    // back substitution\n    pivots.reverse()\n    for (const [u, [i, k]] of pivots.entries()) {\n        let s = vector.get(i)\n        for (const [v, [_, j]] of pivots.entries()) {\n            if (v >= u) {\n                break\n            }\n            s = field.subtract(s, matrix.get(i, j) * solution.get(j))\n        }\n        solution.set(k, s)\n    }\n\n    return {\n        consistent: consistent,\n        solution: solution,\n        unconstrained: unconstrained,\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// DOM manipulation\n\nconst VNODE_KEY = Symbol(\"VNODE_KEY\")\nconst VNODE_SUSPEND_CHILDREN = Symbol(\"VNODE_SUSPEND_CHILDREN\")\nconst VNODE_SYMBOLS = Symbol(\"VNODE_SYMBOLS\")\nconst VNODE_EVENT_LISTENERS = Symbol(\"VNODE_EVENT_LISTENERS\")\n\nfunction vnodeGetSymbol(elem, key) {\n    return (elem[VNODE_SYMBOLS] || {})[key]\n}\n\nfunction vnodeAmendAttributes(attrs, elem) {\n    let listeners = elem[VNODE_EVENT_LISTENERS]\n    let unusedListeners = Object.assign({}, listeners)\n    const keys = Object.keys(attrs)\n    let i = keys.length\n    while (i--) {\n        const k = keys[i]\n        const v = attrs[k]\n        let m = /^on(.+)/.exec(k)\n        if (m) {\n            const event = m[1]\n            if (!listeners) {\n                listeners = {}\n                elem[VNODE_EVENT_LISTENERS] = listeners\n            }\n            let listener = listeners[event]\n            if (listener) {\n                delete unusedListeners[event]\n            } else {\n                listener = [undefined]\n                listeners[event] = listener\n                elem.addEventListener(event, function(e) {\n                    return listener[0].call(this, e)\n                })\n            }\n            listener[0] = v\n        } else if (v == null) {\n            elem.removeAttribute(k, v)\n        } else {\n            if (elem.getAttribute(k) != v) {\n                elem.setAttribute(k, v)\n            }\n        }\n    }\n    const symKeys = Object.getOwnPropertySymbols(attrs)\n    i = symKeys.length\n    while (i--) {\n        let symbols = elem[VNODE_SYMBOLS]\n        if (!symbols) {\n            symbols = {}\n            elem[VNODE_SYMBOLS] = symbols\n        }\n        const k = symKeys[i]\n        symbols[k] = attrs[k]\n    }\n    const unusedEvents = Object.keys(unusedListeners)\n    let j = unusedEvents.length\n    while (j--) {\n        const event = unusedEvents[j]\n        elem.removeEventListener(event, unusedListeners[event])\n    }\n}\n\nfunction vnodeRenderAttributes(attrs, elem) {\n    if (!attrs) {\n        return\n    }\n    let oldAttrs = elem.attributes\n    if (oldAttrs) {\n        let i = 0\n        while (i < oldAttrs.length) {\n            const oldAttr = oldAttrs[i]\n            const name = oldAttr.name\n            if (!attrs.hasOwnProperty(name) && oldAttr.ns == null) {\n                oldAttrs.removeNamedItem(name)\n            } else {\n                i += 1\n            }\n        }\n    }\n    delete elem[VNODE_SYMBOLS]\n    vnodeAmendAttributes(attrs, elem)\n}\n\nfunction vnodeRenderChildren(children, elem) {\n    if (!children) {\n        return\n    }\n    let oldChildren = elem.childNodes\n    if (!oldChildren) {\n        return\n    }\n    // fragment contains a queue of pending elements; if you're about\n    // to increment j without removing an old node, then you should\n    // flush this queue before moving on!\n    let fragment = document.createDocumentFragment()\n    let j = 0\n    for (let i = 0; i < children.length; ++i) {\n        let child = children[i]\n        let oldChild = oldChildren[j]\n        if (child instanceof Vnode) {\n            const key = child.attributes[VNODE_KEY]\n            if (key) {\n                // find matching node, if any\n                while (oldChild) {\n                    if (oldChild instanceof Element ||\n                        oldChild instanceof Text) {\n                        if ((oldChild[VNODE_SYMBOLS] || {})[VNODE_KEY] == key) {\n                            break\n                        }\n                        elem.removeChild(oldChild)\n                    } else {\n                        elem.insertBefore(fragment, oldChild)\n                        j += 1\n                    }\n                    oldChild = oldChildren[j]\n                }\n            } else if (oldChild && (oldChild[VNODE_SYMBOLS] || {})[VNODE_KEY]) {\n                // not a candidate for replacement; try again later\n                oldChild = null\n            }\n            if (oldChild) {\n                // found a candiate; can we update without replacing?\n                // (note: XML is case-sensitive; HTML is not)\n                if (oldChild instanceof HTMLElement\n                    ? (oldChild.nodeName.toLowerCase()\n                        == child.name.toLowerCase())\n                    : (oldChild.namespaceURI == child.namespace &&\n                       oldChild.nodeName == child.name)) {\n                    elem.insertBefore(fragment, oldChild)\n                    j += 1\n                    child.renderTo(oldChild)\n                    continue\n                } else {\n                    elem.removeChild(oldChild)\n                }\n            }\n            child = child.create()\n        } else if (typeof child == \"string\") {\n            if (oldChild instanceof Text) {\n                elem.insertBefore(fragment, oldChild)\n                j += 1\n                if (oldChild.nodeValue != child) {\n                    oldChild.nodeValue = child\n                }\n                continue\n            } else {\n                child = document.createTextNode(child)\n            }\n        }\n        fragment.appendChild(child)\n    }\n    // remove remaining nodes\n    while (j < oldChildren.length) {\n        let oldChild = oldChildren[j]\n        if (oldChild instanceof Element ||\n            oldChild instanceof Text) {\n            // this function is not re-entrant, so this could throw an exception\n            // if a blur event removes the child before we get a chance to;\n            // we work around this by serializing execution of applyRendering\n            elem.removeChild(oldChild)\n        } else {\n            j += 1\n        }\n    }\n    elem.appendChild(fragment)\n}\n\nclass Vnode {\n    constructor(namespace, name, attributes, children) {\n        this.namespace = namespace\n        this.name = name\n        this.attributes = attributes\n        this.children = children\n    }\n\n    // Copy the attributes and children to the given element.\n    // Note: the behavior is unspecified if the element is of a different name.\n    renderTo(elem) {\n        vnodeRenderAttributes(this.attributes, elem)\n        if (!this.attributes[VNODE_SUSPEND_CHILDREN]) {\n            vnodeRenderChildren(this.children, elem)\n        }\n    }\n\n    create() {\n        const namespace = this.namespace\n        let elem = namespace\n                 ? document.createElementNS(namespace, this.name)\n                 : document.createElement(this.name)\n        this.renderTo(elem)\n        return elem\n    }\n}\n\nconst NAMESPACES = {\n    svg: \"http://www.w3.org/2000/svg\",\n    xlink: \"http://www.w3.org/1999/xlink\",\n}\n\nfunction parseNamespace(name) {\n    let namespace = null\n    const m = /([^:]+):(.+)/.exec(name)\n    if (m && NAMESPACES.hasOwnProperty(m[1])) {\n        namespace = NAMESPACES[m[1]]\n        name = m[2]\n    }\n    return [namespace, name]\n}\n\nfunction vnode(name, attributes, ...children) {\n    let namespace\n    ;[namespace, name] = parseNamespace(name)\n    return new Vnode(namespace, name, attributes, children)\n}\n\nlet renderQueue = []\nfunction applyRendering(rendering) {\n    // work around the lack of re-entrancy\n    renderQueue.push(rendering)\n    if (renderQueue.length != 1) {      // we are not alone\n        return\n    }\n    while (renderQueue.length) {\n        const rendering = renderQueue[0]\n        rendering.forEach(spec => {\n            const elem = spec.element\n            if (!elem) {\n                throw new Error(\"invalid elem\")\n            }\n            if (spec.attributes) {\n                vnodeAmendAttributes(spec.attributes, elem)\n            }\n            vnodeRenderChildren(spec.children, elem)\n        })\n        renderQueue.shift()\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Deltas\n//\n// Without qualification, \"deltas\" refer to Kronecker deltas involving\n// magnitudes (j), not projections (m).\n//\n// Each delta is an array of at least two magnitude variables.\n// Within a given list of deltas, the variables must be all distinct.\n\n/** Merges the given deltas and simplifies the result. */\nexport function mergeDeltas(...deltaLists) {\n    let finalDeltas = []\n    let finder = {} // {[entry]: [deltas]} (singleton list)\n    deltaLists.forEach(deltas => deltas.forEach(delta => {\n        if (delta.length < 2) {\n            return\n        }\n        let found = null\n        for (let i = 0; i < delta.length; ++i) {\n            found = finder[delta[i]]\n            if (found) {\n                break\n            }\n        }\n        if (found == null) {\n            found = [[]]\n            finalDeltas.push(found[0])\n        }\n        delta.forEach(x => {\n            const exists = finder[x]\n            if (!exists) {\n                found[0].push(x)\n                finder[x] = found\n            } else if (exists[0] != found[0]) {\n                // merge deltas\n                found[0].push(...exists[0])\n                exists[0].splice(0, exists[0].length)\n                exists[0] = found[0]\n            }\n        })\n    }))\n    // remove the husks\n    return Object.freeze(finalDeltas.map(Object.freeze)\n                                    .filter(delta => delta.length > 1))\n}\n\n/** Tests whether the 'subdeltas' is a subset of (implied by) 'deltas'. */\nexport function containsDeltas(deltas, subdeltas) {\n    deltas = mergeDeltas(deltas)\n    subdeltas = mergeDeltas(subdeltas)\n    let finder = {}\n    deltas.forEach(delta => delta.forEach(x =>\n        finder[x] = delta\n    ))\n    for (let j = 0; j < subdeltas.length; ++j) {\n        const subdelta = subdeltas[j]\n        let found = null\n        for (let i = 0; i < subdelta.length; ++i) {\n            found = finder[subdelta[i]]\n            if (found) {\n                break\n            }\n        }\n        if (found) {\n            for (let i = 0; i < subdelta.length; ++i) {\n                if (finder[subdelta[i]] != found) {\n                    return false\n                }\n            }\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunction equalDeltas(deltas1, deltas2) {\n    return containsDeltas(deltas1, deltas2) && containsDeltas(deltas2, deltas1)\n}\n\nfunction findDeltaEntry(deltas, entry) {\n    for (let j = 0; j < deltas.length; ++j) {\n        for (let i = 0; i < deltas[j].length; ++i) {\n            if (deltas[j][i] == entry) {\n                return [j, i]\n            }\n        }\n    }\n    return null\n}\n\nexport function relatedDelta(deltas, entry) {\n    const ji = findDeltaEntry(deltas, entry)\n    if (!ji) {\n        return [entry]\n    }\n    const [j, i] = ji\n    return [entry].concat(arrayRemoveMany(deltas[j], [i]))\n}\n\n/** Warning: this may not preserve the diagram! */\nexport function removeDeltaEntry(deltas, entry) {\n    const ji = findDeltaEntry(deltas, entry)\n    if (!ji) {\n        return deltas\n    }\n    const [j, i] = ji\n    return Object.freeze(Object.assign([], deltas, {\n        [j]: Object.freeze(arrayRemoveMany(deltas[j], [i])),\n    })).filter(delta => delta.length > 1)\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Superlines\n//\n// Superlines are just magnitudes (j).\n\nexport const EMPTY_SUPERLINE = Object.freeze({\n    phase: 0,\n    summed: false,\n    weight: 0,\n})\n\n/** Convert a superline-like object into a proper superline. */\nfunction ensureSuperline(superline) {\n    return Object.freeze(Object.assign({}, EMPTY_SUPERLINE, superline))\n}\n\n/** Increment the numeric suffix of a string by one.  If there is no suffix,\n   `1` is appended. */\nfunction newLabel(label) {\n    const match = /^([\\s\\S]*?)(\\d*)$/.exec(label)\n    return match[1] + (Number(match[2]) + 1).toString()\n}\n\n/** Generate `count` fresh labels. */\nfunction availLabels(obj) {\n    // avoid \"0\", which is reserved for the actual zero\n    return filter(i => !obj.hasOwnProperty(i),\n                  map(i => i.toString(),\n                      range(1, Number.POSITIVE_INFINITY)))\n}\n\n/** Generate `count` fresh superline labels. */\nfunction availSuperlineLabels(diagram) {\n    let labels = Object.assign({}, diagram.superlines)\n    for (const delta of diagram.deltas) {\n        for (const x of delta) {\n            labels[x] = true\n        }\n    }\n    return availLabels(labels)\n}\n\nfunction isEmptySuperline(superline) {\n    return !superline.phase && !superline.summed && !superline.weight\n}\n\n/** Avoid using this function because it doesn't handle zero lines. */\nfunction mergeSuperlines(...superlines) {\n    let finalSuperline = Object.assign({}, EMPTY_SUPERLINE)\n    superlines.forEach(superline => {\n        finalSuperline.phase = mod(finalSuperline.phase\n                                 + (superline.phase || 0), 4)\n        finalSuperline.weight += superline.weight || 0\n        if (superline.summed != null) {\n            finalSuperline.summed = superline.summed\n        }\n    })\n    return Object.freeze(finalSuperline)\n}\n\nfunction mergeSuperlineLists(...superlineLists) {\n    let finalSuperlines = {}\n    for (const superlines of superlineLists) {\n        for (const id of Object.keys(superlines)) {\n            if (id == \"0\") {\n                finalSuperlines[id] = EMPTY_SUPERLINE\n                continue\n            }\n            const finalSuperline = finalSuperlines[id]\n            let superline = superlines[id]\n            if (finalSuperline) {\n                superline = mergeSuperlines(finalSuperline, superline)\n            }\n            finalSuperlines[id] = superline\n        }\n    }\n    for (const id of Object.keys(finalSuperlines)) {\n        if (id.phase == 0 && id.weight == 0 && !id.summed) {\n            delete finalSuperlines[id]\n        }\n    }\n    return Object.freeze(finalSuperlines)\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Line manipulation\n\n// type Line = {\n//   superline: String,\n//   direction: -1 (left) | 0 | 1 (right),\n//   arrowPos: 0.0 (left) to 1.0 (right),\n//   arcHeight: -INF to INF, (sagitta, + is downward)\n//   angle: 0 to 2PI, (of the direct line, clockwise)\n//   textPos: 0.0 (left) to 1.0 (right),\n//   textOffset: -INF to INF, (+ is downward)\n// }\n//\n// The angle is usually ignored, but if the ratio of arcHeight to lineLength\n// is too big, then 'angle' is used to break the degeneracy.\n//\n// In general, \"pos\" refers to a relative position on a line, with 0.0 being\n// the leftmost point and 1.0 the rightmost.\n\nconst ZERO_LINE = Object.freeze({\n    superline: \"0\",\n    direction: 0,\n    arrowPos: 0.5,\n    arcHeight: 0.0,\n    angle: 0.0,\n    textPos: 0.5,\n    textOffset: 0.0,\n})\n\nexport function newLine(superlineId) {\n    return ensureLine({superline: superlineId})\n}\n\nfunction ensureLine(line) {\n    return Object.freeze(Object.assign({}, ZERO_LINE, line))\n}\n\nfunction reverseLineDirection(line) {\n    return Object.freeze(Object.assign({}, line, {direction: -line.direction}))\n}\n\nfunction reverseLine(line) {\n    line = Object.assign({}, line)\n    if (line.direction != null) {\n        line.direction = -line.direction\n    }\n    if (line.arrowPos != null) {\n        line.arrowPos = 1.0 - line.arrowPos\n    }\n    if (line.arcHeight != null) {\n        line.arcHeight = -line.arcHeight\n    }\n    if (line.angle != null) {\n        line.angle = mod(line.angle + Math.PI, 2 * Math.PI)\n    }\n    if (line.textPos != null) {\n        line.textPos = 1.0 - line.textPos\n    }\n    if (line.textOffset != null) {\n        line.textOffset = -line.textOffset\n    }\n    return Object.freeze(line)\n}\n\nfunction isLineDirectable(line) {\n    return line.superline == \"0\" || mod(line.direction, 2) == 1\n}\n\nfunction mergeDirections(...directions) {\n    return mod(sum(directions) + 1, 4) - 1\n}\n\n/** Beware: this may result in a noncanonical line!\n *\n * Because of averaging, addition isn't quite associative with respect to the\n * superficial attributes.\n *\n * All lines must agree in superline.\n */\nfunction rawConcatLines(...lines) {\n    const n = lines.length\n    const avgProps = [\"arrowPos\", \"arcHeight\",\n                      \"textPos\", \"textOffset\"]\n    let finalLine = {}\n    let sinAngle = 0.0\n    let cosAngle = 0.0\n    let numAngles = 0\n    let counts = {}\n    for (const prop of avgProps) {\n        counts[prop] = 0\n    }\n    for (const [i, line] of lines.entries()) {\n        if (i == 0) {\n            finalLine.superline = line.superline\n        } else if (finalLine.superline != line.superline) {\n            throw new Error(\"cannot add lines with different superlines\")\n        }\n        if (line.direction != null) {\n            if (finalLine.direction == null) {\n                finalLine.direction = 0\n            }\n            finalLine.direction =\n                mergeDirections(finalLine.direction, line.direction)\n        }\n        for (const prop of avgProps) {\n            if (line[prop] != null) {\n                if (finalLine[prop] == null) {\n                    finalLine[prop] = 0\n                }\n                finalLine[prop] += line[prop]\n                counts[prop] += 1\n            }\n        }\n        if (line.angle != null) {\n            sinAngle += Math.sin(line.angle)\n            cosAngle += Math.cos(line.angle)\n            numAngles += 1\n        }\n    }\n    for (const prop of avgProps) {\n        if (counts[prop]) {\n            finalLine[prop] /= counts[prop]\n        }\n    }\n    if (numAngles) {\n        finalLine.angle = Math.atan2(sinAngle, cosAngle)\n    }\n    return Object.freeze(finalLine)\n}\n\n/** Like `rawConcatLines`, but does canonicalization and converts conflicting\n * superlines into a delta. */\nfunction concatLines(...lines) {\n    const canonicalized = canonicalizeLine(rawConcatLines(\n        ...lines.map(line => Object.assign({}, line, {\n            superline: lines[0].superline,\n        }))))\n    return {\n        line: canonicalized.line,\n        phase: canonicalized.phase,\n        delta: lines.map(line => line.superline), // duplicates are fine\n    }\n}\n\nfunction canonicalizeLine(line) {\n    let direction = line.direction % 2\n    let phase = mod(Math.trunc(line.direction / 2), 2) * 2\n    if (line.superline == \"0\") {\n        direction = 0\n        phase = 0\n    }\n    return {\n        line: Object.freeze(Object.assign({}, line, {direction: direction})),\n        phase: phase,\n    }\n}\n\nfunction joinLines(line1, reverse1, line2, reverse2) {\n    line1 = (reverse1 ? reverseLine : identity)(line1)\n    line2 = (reverse2 ? reverseLine : identity)(line2)\n    const superlines = [line1.superline, line2.superline].sort(defaultCmp)\n    line1 = Object.assign({}, line1, {superline: superlines[0]})\n    line2 = Object.assign({}, line1, {superline: superlines[0]})\n    return Object.assign(canonicalizeLine(rawConcatLines(line1, line2)), {\n        otherSuperline: superlines[1]\n    })\n}\n\nfunction getLineInfoBetween(x0, y0, x1, y1, line) {\n    const xMid = (x0 + x1) / 2\n    const yMid = (y0 + y1) / 2\n    let dx = x1 - x0\n    let dy = y1 - y0\n    let lineLength = Math.sqrt(dx * dx + dy * dy)\n    const singular = lineLength == 0.0\n    const trueAngle = Math.atan2(dy, dx)\n    let angle = trueAngle\n    let arcHeight = line.arcHeight\n    // an semiarbitrary sign used to pick a consistent side on lines even\n    // when the line is reversed\n    const halfDisk = mod(line.angle + Math.PI / 2, 2 * Math.PI) < Math.PI\n                   ? -1 : 1\n    if (singular) {\n        // fudge numbers to avoid singularity\n        // (epsilon can't be too small or the SVG rendering becomes jittery)\n        const epsilon = 1e-2\n        dx = epsilon * Math.cos(line.angle)\n        dy = epsilon * Math.sin(line.angle)\n        x0 = xMid - 0.5 * dx\n        y0 = yMid - 0.5 * dy\n        x1 = xMid + 0.5 * dx\n        y1 = yMid + 0.5 * dy\n        lineLength = epsilon\n        angle = line.angle\n        arcHeight = arcHeight == 0.0\n                  ? 50.0 * halfDisk\n                  : sgn(arcHeight) * clamp(50.0, Infinity, Math.abs(arcHeight))\n    }\n    const arc = arcInfo(lineLength, arcHeight)\n    const c = (arc.radius - arcHeight) / lineLength\n    const xCenter = xMid + c * dy\n    const yCenter = yMid - c * dx\n    const arcEx = {\n        xCenter: xCenter,\n        yCenter: yCenter,\n        startAngle: Math.atan2(y0 - yCenter, x0 - xCenter),\n    }\n    return {\n        x0: x0,\n        y0: y0,\n        x1: x1,\n        y1: y1,\n        xMid: xMid,\n        yMid: yMid,\n        dx: dx,\n        dy: dy,\n        angle: angle,\n        trueAngle: trueAngle,\n        lineLength: lineLength,\n        singular: singular,\n        line: line,\n        halfDisk: halfDisk,\n        arcHeight: arcHeight,\n        arc: Object.assign(arc, arcEx),\n    }\n}\n\n/** Calculate geometric information about a line. */\nfunction getLineInfo(diagram, lineId) {\n    const line = diagram.lines[lineId]\n    const ends = endNodeIndices(diagram.nodes, lineId)\n    const node0 = diagram.nodes[ends[0]]\n    const node1 = diagram.nodes[ends[1]]\n    return Object.assign({\n        external: [node0.type, node1.type].includes(\"terminal\"),\n    }, getLineInfoBetween(node0.x, node0.y, node1.x, node1.y, line))\n}\n\n/** Find the closest \"pos\" on a line. */\nfunction findPosOnLine(lineInfo, x, y) {\n    let pos, offset\n    if (lineInfo.arcHeight == 0.0) {\n        const rx = x - lineInfo.x0\n        const ry = y - lineInfo.y0\n        pos = (lineInfo.dx * rx + lineInfo.dy * ry)\n        / Math.pow(lineInfo.lineLength, 2)\n        // left-handed coordinate system!\n        offset = -(rx * lineInfo.dy - ry * lineInfo.dx) / lineInfo.lineLength\n    } else {\n        const arc = lineInfo.arc\n        const rx = x - arc.xCenter\n        const ry = y - arc.yCenter\n        const cycle = Math.abs(Math.PI / arc.inclination)\n        const rawAngle = arc.startAngle - Math.atan2(ry, rx)\n        const shift = 0.5 * cycle - 0.5 // remove the bias toward pos = 1.0\n        pos = mod(rawAngle / (2 * arc.inclination) + shift, cycle) - shift\n        offset = (Math.sqrt(rx * rx + ry * ry) - Math.abs(arc.radius))\n        * sgn(lineInfo.arcHeight)\n    }\n    return {\n        pos: pos,\n        offset: offset,\n    }\n}\n\n/** Translate from a relative \"pos\" to absolute (x, y) coordinates.  `shift`\n * specifies an extra shift in absolute coordinates along the line. */\nfunction positionOnLine(lineInfo, pos, shift) {\n    const arc = lineInfo.arc\n    if (lineInfo.arcHeight == 0.0) {\n        const lineLength = lineInfo.lineLength\n        const newPos = pos + shift / lineLength\n        return {\n            x: lineInfo.x0 + lineInfo.dx * newPos,\n            y: lineInfo.y0 + lineInfo.dy * newPos,\n            normalX: -lineInfo.dy / lineLength,\n            normalY: lineInfo.dx / lineLength,\n            tangentAngle: lineInfo.angle,\n        }\n    } else {\n        const localAngle = 2 * arc.inclination * pos + shift / arc.radius\n        const tangentAngle = lineInfo.angle + arc.inclination - localAngle\n        const normalAngle = tangentAngle + Math.PI / 2\n        const normalX = Math.cos(normalAngle)\n        const normalY = Math.sin(normalAngle)\n        return {\n            x: arc.xCenter + arc.radius * normalX,\n            y: arc.yCenter + arc.radius * normalY,\n            normalX: normalX,\n            normalY: normalY,\n            tangentAngle: tangentAngle,\n        }\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Node manipulation\n\n/** Create a terminal node. */\nexport function terminalNode(lineId, variable, x, y) {\n    // every terminal has an associated name for the \"m\" variable;\n    // because this variable is *free*, rules must never change this variable!\n    // (you are free to rename the lineId whatever you want, but try to reuse\n    // the user's naming if possible)\n    //\n    // when rendering lines connected to terminal(s), be aware that the name(s)\n    // on the terminal(s) *supersede* the name of the line itself (lineId); if\n    // there are two terminals, then an m-delta is implied (this is how we\n    // represent m-deltas)\n    let node = {\n        type: \"terminal\",\n        lines: Object.freeze([lineId]),\n        variable: variable,\n    }\n    if (x != null) {\n        node.x = x\n    }\n    if (y != null) {\n        node.y = y\n    }\n    return Object.freeze(node)\n}\n\n/** Create a Wigner 3-jm node. */\nexport function w3jNode(a, b, c, x, y) {\n    let node = {\n        type: \"w3j\",\n        lines: Object.freeze([a, b, c]),\n    }\n    if (x !== undefined) {\n        node.x = x\n    }\n    if (y !== undefined) {\n        node.y = y\n    }\n    return Object.freeze(node)\n}\n\nfunction endNodeAndLineIndices(nodes, lineId) {\n    let nodeAndLineIndices = []\n    if (lineId == null) {\n        throw new Error(\"lineId must not be null / undefined\")\n    }\n    const numNodes = nodes.length\n    for (let nodeIndex = 0; nodeIndex < numNodes; ++nodeIndex) {\n        const lines = nodes[nodeIndex].lines\n        const numLines = lines.length\n        for (let lineIndex = 0; lineIndex < numLines; ++lineIndex) {\n            const nodeLineId = lines[lineIndex]\n            if (nodeLineId == lineId) {\n                nodeAndLineIndices.push([nodeIndex, lineIndex])\n            }\n        }\n    }\n    if (nodeAndLineIndices.length != 2) {\n        throw new Error(\"line must be connected at 2 points, \"\n                      + `not ${nodeAndLineIndices.length}`)\n    }\n    return nodeAndLineIndices\n}\n\nfunction endNodeIndices(nodes, lineId) {\n    return endNodeAndLineIndices(nodes, lineId).map(x => x[0])\n}\n\nfunction otherNodeAndLineIndex(nodes, nodeIndex, lineIndex) {\n    const lineId = nodes[nodeIndex].lines[lineIndex]\n    if (lineId === undefined) {\n        throw new Error(`cannot find line with lineIndex = ${lineIndex}`)\n    }\n    let nodeAndLineIndices = endNodeAndLineIndices(nodes, lineId)\n    if (lexicalCmp(nodeAndLineIndices[0],\n                   [nodeIndex, lineIndex],\n                   defaultCmp) == 0) {\n        return nodeAndLineIndices[1]\n    } else {\n        return nodeAndLineIndices[0]\n    }\n}\n\nfunction otherNodeIndex(nodes, nodeIndex, lineIndex) {\n    return otherNodeAndLineIndex(nodes, nodeIndex, lineIndex)[0]\n}\n\nfunction isLeftOfLine(nodes, nodeIndex, lineIndex) {\n    return lexicalCmp(otherNodeAndLineIndex(nodes, nodeIndex, lineIndex),\n                      [nodeIndex, lineIndex], defaultCmp) > 0\n}\n\nfunction nearestNodeIndices(nodes, count, x, y) {\n    return nodes\n        .map((node, nodeIndex) => ({\n            distance: Math.pow(x - node.x, 2) + Math.pow(y - node.y, 2),\n            index: nodeIndex\n        }))\n        .sort((x, y) => x.distance - y.distance)\n        .slice(0, count)\n        .map(node => node.index)\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Diagram manipulation\n//\n// NOTE: must maintain invariant that terminals precede all other nodes.\n// Also, the order of nodes is critical!  If you move the nodes around,\n// make sure the lines are also reversed.\n\nexport const EMPTY_DIAGRAM = Object.freeze({\n    nodes: Object.freeze([]),\n    superlines: Object.freeze({}),\n    lines: Object.freeze({}),\n\n    // each entry is an array of j's that are equal to each other\n    deltas: Object.freeze([]),\n})\n\nexport function ensureDiagram(diagram) {\n    return Object.freeze(Object.assign({}, EMPTY_DIAGRAM, diagram))\n}\n\nfunction w3jDiagram(a, b, c, x, y) {\n    if (a == b || b == c || c == a) {\n        throw new Error(\"cannot create w3jDiagram with conflicting labels\")\n    }\n    return ensureDiagram({\n        nodes: Object.freeze([\n            terminalNode(a, a, x - 50, y + 50),\n            terminalNode(b, b, x + 50, y + 50),\n            terminalNode(c, c, x, y - 70),\n            w3jNode(a, b, c, x, y),\n        ]),\n        lines: Object.freeze({\n            [a]: newLine(a),\n            [b]: newLine(b),\n            [c]: newLine(c),\n        }),\n        superlines: Object.freeze({\n            [a]: EMPTY_SUPERLINE,\n            [b]: EMPTY_SUPERLINE,\n            [c]: EMPTY_SUPERLINE,\n        }),\n    })\n}\n\nfunction cgDiagram(a, b, c, x, y) {\n    const diagram = w3jDiagram(a, b, c, x, y)\n    return Object.freeze(Object.assign({}, diagram, {\n        nodes: Object.freeze(Object.assign([], diagram.nodes, {\n            [3]: Object.freeze(Object.assign({}, diagram.nodes[3], {\n                lines: Object.freeze([a, c, b]),\n            })),\n        })),\n        lines: Object.freeze(Object.assign({}, diagram.lines, {\n            [c]: Object.freeze(Object.assign({}, diagram.lines[c], {\n                direction: 1,\n            })),\n        })),\n        superlines: Object.freeze(Object.assign({}, diagram.superlines, {\n            [b]: Object.freeze(Object.assign({}, diagram.superlines[b], {\n                phase: 2,\n            })),\n            [c]: Object.freeze(Object.assign({}, diagram.superlines[c], {\n                weight: 1,\n            })),\n        })),\n    }))\n}\n\nfunction setDiagramLineProps(diagram, lineId, props) {\n    const lines = diagram.lines\n    return Object.freeze(Object.assign({}, diagram, {\n        lines: Object.freeze(Object.assign({}, lines, {\n            [lineId]: Object.freeze(Object.assign({}, lines[lineId], props)),\n        })),\n    }))\n}\n\nfunction setDiagramNodeProps(diagram, nodeIndex, props) {\n    const nodes = diagram.nodes\n    return Object.freeze(Object.assign({}, diagram, {\n        nodes: Object.freeze(Object.assign([], nodes, {\n            [nodeIndex]: Object.freeze(Object.assign({}, nodes[nodeIndex],\n                                                     props)),\n        }))\n    }))\n}\n\nfunction lineAngle(diagram, nodeIndex, lineIndex) {\n    const node = diagram.nodes[nodeIndex]\n    const lineId = node.lines[lineIndex]\n    const line = diagram.lines[lineId]\n    const lineInfo = getLineInfo(diagram, lineId)\n    const reverse = Number(isLeftOfLine(diagram.nodes, nodeIndex, lineIndex))\n    const baseAngle = (lineInfo.singular ? line.angle : lineInfo.angle)\n                    + reverse * Math.PI\n    const sign = reverse ? 1 : -1\n    return baseAngle + sign * lineInfo.arc.inclination\n}\n\nfunction w3jOrientation(diagram, nodeIndex) {\n    const node = diagram.nodes[nodeIndex]\n    if (node.type != \"w3j\") {\n        throw new Error(\"cannot get orientation of generic node\")\n    }\n    const lines = node\n        .lines\n        .map((_, lineIndex) => {\n            const angle = lineAngle(diagram, nodeIndex, lineIndex)\n            return [lineIndex, mod(angle, 2 * Math.PI)]\n        })\n        .sort((line1, line2) => line1[1] - line2[1])\n        .map(([x, _]) => x)\n    return permutSign([0, 1, 2], lines)\n}\n\nfunction mergeDiagrams(diagram1, diagram2) {\n    let diagram = deepClone(diagram1)\n    diagram.superlines = mergeSuperlineLists(diagram1.superlines,\n                                             diagram2.superlines)\n    let renames = {}\n    Object.keys(diagram2.lines).forEach(function(lineId) {\n        let newLineId = lineId\n        while (diagram.lines.hasOwnProperty(newLineId)) {\n            // name collision\n            newLineId = newLabel(newLineId)\n        }\n        renames[lineId] = newLineId\n        diagram.lines[newLineId] = diagram2.lines[lineId]\n    })\n    let terminals = []\n    diagram2.nodes.forEach(function(node) {\n        node = Object.assign({}, node, {\n            lines: node.lines.map(lineId => renames[lineId]),\n        })\n        if (node.type == \"terminal\") {\n            terminals.push(node)\n        } else {\n            diagram.nodes.push(node)\n        }\n    })\n    diagram.nodes = terminals.concat(diagram.nodes)\n    return diagram\n}\n\nfunction isSuperlineExposed(diagram, superlineId) {\n    for (const node of diagram.nodes) {\n        if (node.type == \"terminal\" &&\n            diagram.lines[node.lines[0]].superline == superlineId) {\n            return true\n        }\n    }\n    return false\n}\n\nfunction joinTerminals(diagram, terminalIndex1, terminalIndex2) {\n    diagram = new Diagram(diagram)\n    const terminal1 = diagram.node(terminalIndex1)\n    const terminal2 = diagram.node(terminalIndex2)\n    if (terminal1.type != \"terminal\" || terminal2.type != \"terminal\") {\n        throw \"cannot join non-terminals\"\n    }\n    const line1 = terminal1.line(0)\n    const line2 = terminal2.line(0)\n    let newDiagram = deepClone(diagram.rawDiagram)\n    if (line1.id == line2.id) {\n        if (line1.direction != 0) {\n            return \"cannot form a directed loop\"\n        }\n        newDiagram.superlines[line1.superlineId].weight += 2\n    } else {\n        // TODO can we abstract out this pattern? we do this a lot\n        const combined = concatLines(line1.reverse().line, line2.line)\n        const f = lexicalCmp([line1.node(1).index, line1.lineIndex(1)],\n                             [line2.node(1).index, line2.lineIndex(1)],\n                             defaultCmp) > 0\n                ? reverseLine : identity\n        newDiagram.lines[line1.id] = f(combined.line)\n        line2.rawAssign(newDiagram, 1, line1.id)\n        if (line1.superlineId != line2.superlineId) {\n            newDiagram.superlines[line1.superlineId] = mergeSuperlines(\n                line2.superline,\n                line1.superline,\n                {phase: combined.phase})\n            newDiagram.superlines[line2.superlineId] = EMPTY_SUPERLINE\n        }\n        newDiagram.deltas = mergeDeltas(newDiagram.deltas, [combined.delta])\n    }\n    delete newDiagram.lines[line2.id]\n    newDiagram.nodes = arrayRemoveMany(newDiagram.nodes,\n                                       [terminal1.index, terminal2.index])\n    return new Diagram(newDiagram).removeUnusedSuperlines().rawDiagram\n}\n\nfunction addW1j(diagram, lineId) {\n    diagram = deepClone(diagram)\n    let line = diagram.lines[lineId]\n    // cycle through all possible directions\n    if (line.direction > 0) {\n        line.direction = -1\n    } else if (line.direction < 0) {\n        line.direction = 0\n    } else {\n        line.direction = 1\n    }\n    return diagram\n}\n\nfunction add2j(diagram, lineId) {\n    diagram = new Diagram(diagram)\n    return diagram.substitute({}, {\n        [diagram.line(lineId).superlineId]: {phase: 2}\n    }).rawDiagram\n}\n\nfunction flipW3j(diagram, nodeIndex) {\n    if (diagram.nodes[nodeIndex].type != \"w3j\") {\n        return diagram\n    }\n    diagram = deepClone(diagram)\n    let lines = diagram.nodes[nodeIndex].lines\n    lines.reverse()\n    for (let i = 0; i < 3; ++i) {\n        if (lines[i] == lines[(i + 1) % 3]) {\n            diagram.lines[lines[i]] = reverseLine(diagram.lines[lines[i]])\n            break\n        }\n    }\n    return diagram\n}\n\nfunction isDanglingSuperline(diagram, superlineId) {\n    const lineIds = Object.keys(diagram.lines)\n    let i = lineIds.length\n    while (i--) {\n        if (diagram.lines[lineIds[i]].superline == superlineId) {\n            return false\n        }\n    }\n    return true\n}\n\nfunction deleteNode(diagram, nodeIndex) {\n    diagram = deepClone(diagram)\n    const node = diagram.nodes[nodeIndex]\n    if (node.type == \"terminal\") {\n        const otherIndex = otherNodeIndex(diagram.nodes, nodeIndex, 0)\n        if (diagram.nodes[otherIndex].type != \"terminal\") {\n            throw new Error(\"cannot delete terminal of node\")\n        }\n        const superlineId = diagram.lines[node.lines[0]].superline\n        delete diagram.lines[node.lines[0]]\n        if (isDanglingSuperline(diagram, superlineId)) {\n            delete diagram.superlines[superlineId]\n        }\n        diagram.nodes = arrayRemoveMany(diagram.nodes, [nodeIndex, otherIndex])\n    } else {\n        let terminals = []\n        node.lines.forEach(function(lineId, lineIndex) {\n            const otherIndex = otherNodeIndex(diagram.nodes, nodeIndex, lineIndex)\n            if (otherIndex == nodeIndex) {\n                const line = diagram.lines[lineId]\n                if (!line) {\n                    return\n                }\n                delete diagram.lines[lineId]\n                const superlineId = line.superline\n                if (isDanglingSuperline(diagram, superlineId)) {\n                    delete diagram.superlines[superlineId]\n                }\n                return\n            }\n            if (otherIndex < nodeIndex) {\n                diagram.lines[lineId] = reverseLine(diagram.lines[lineId])\n            }\n            terminals.push(terminalNode(lineId, lineId, node.x, node.y))\n        })\n        diagram.nodes.splice(nodeIndex, 1)\n        diagram.nodes = terminals.concat(diagram.nodes)\n    }\n    return diagram\n}\n\n/** Examine the diagram to see if there are any deltas that are immediately\n * obvious from its topology. */\nfunction inferDeltas(diagram) {\n    let deltas = []\n    let knownZeros = new Set([\"0\"])\n    diagram = new Diagram(diagram)\n    for (const node of diagram.nodes()) {\n        const loop = findW3jLoop(node)\n        if (typeof loop == \"object\") {\n            if (loop.loopLine.direction % 2) {\n                knownZeros.add(loop.cutLine.superlineId)\n            }\n        }\n        if (node.type == \"w3j\") {\n            for (const line of node.lines()) {\n                if (knownZeros.has(line.superlineId)) {\n                    deltas.push([line.cycNodeLine(0, 1).superlineId,\n                                 line.cycNodeLine(0, 2).superlineId])\n                    break\n                }\n            }\n        }\n    }\n    deltas.push(Array.from(knownZeros))\n    return deltas\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Diagrammatic rules\n//\n// We distinguish between transformations used for editing (which generally\n// do not preserve the semantics) and transformations used for derivations\n// that always preserve equivalence.  The latter are called \"rules\".\n\nfunction flipW3jRule(diagram, nodeIndex) {\n    if (diagram.nodes[nodeIndex].type != \"w3j\") {\n        return diagram\n    }\n    diagram = deepClone(flipW3j(diagram, nodeIndex))\n    diagram.nodes[nodeIndex].lines.forEach(lineId =>\n        diagram.superlines = mergeSuperlineLists(diagram.superlines, {\n            [diagram.lines[lineId].superline]: {phase: 1},\n        }))\n    return diagram\n}\n\nfunction flipW1jRule(diagram, lineId) {\n    if (diagram.lines[lineId].superline == \"0\") {\n        diagram = deepClone(diagram)\n        diagram.lines[lineId].direction =\n            (diagram.lines[lineId].direction + 2) % 3 - 1\n    } else if (diagram.lines[lineId].direction) {\n        diagram = deepClone(diagram)\n        diagram.lines[lineId].direction *= -1\n        diagram.superlines = mergeSuperlineLists(diagram.superlines, {\n            [diagram.lines[lineId].superline]: {phase: 2}})\n    }\n    return diagram\n}\n\nfunction threeArrowRule(diagram, nodeIndex) {\n    const oldDiagram = new Diagram(diagram)\n    diagram = deepClone(diagram)\n    let node = diagram.nodes[nodeIndex]\n    if (node.type != \"w3j\") {\n        return diagram\n    }\n    const loop = findW3jLoop(oldDiagram.node(nodeIndex))\n    let loopId = null\n    if (typeof loop == \"object\") {\n        loopId = loop.loopLine.id\n    }\n\n    let direction = 0\n    // figure out the direction that would minimize the phase change\n    node.lines.forEach(function(lineId, lineIndex) {\n        const line = diagram.lines[lineId]\n        if (isLeftOfLine(diagram.nodes, nodeIndex, lineIndex)) {\n            direction -= line.direction\n        } else {\n            direction += line.direction\n        }\n    })\n    if (direction == 0) {\n        // we still don't have a direction, so let's just pick \"outgoing\"\n        direction = 1\n    } else if (direction == -3) {\n        // if all outgoing, completely reverse the direction\n        direction = -2\n    } else {\n        // normalize to one\n        direction = direction / Math.abs(direction)\n    }\n    node.lines.forEach(function(lineId, lineIndex) {\n        let line = Object.assign({}, diagram.lines[lineId])\n        if (isLeftOfLine(diagram.nodes, nodeIndex, lineIndex)) {\n            line.direction += direction\n        } else {\n            line.direction -= direction\n        }\n        diagram.lines[lineId] = line\n    })\n    node.lines.forEach(function(lineId, lineIndex) {\n        const line = diagram.lines[lineId]\n        const canonicalized = canonicalizeLine(line)\n        diagram.lines[lineId] = canonicalized.line\n        diagram.superlines = mergeSuperlineLists(diagram.superlines, {\n            [line.superline]: {phase: canonicalized.phase},\n        })\n    })\n    return diagram\n}\n\n/** @returns {Object<lineId, [nodeIndex1, lineIndex1,\n *                            nodeIndex2, lineIndex2]>} */\nfunction getLineEnds(diagram) {\n    let lineEnds = {}\n    diagram.nodes.forEach((node, nodeIndex) => {\n        node.lines.forEach((lineId, lineIndex) => {\n            let ends = lineEnds[lineId]\n            if (!ends) {\n                lineEnds[lineId] = [nodeIndex, lineIndex]\n            } else if (ends.length == 2) {\n                if (lexicalCmp([ends[0], ends[1]],\n                               [nodeIndex, lineIndex],\n                               defaultCmp) < 0) {\n                    lineEnds[lineId].push(nodeIndex, lineIndex)\n                } else {\n                    lineEnds[lineId].splice(0, 0, nodeIndex, lineIndex)\n                }\n            } else {\n                throw new Error(\"line must be connected to exactly 2 nodes\")\n            }\n        })\n    })\n    return lineEnds\n}\n\nclass DiagramLine {\n    constructor(diagram, id, reversed) {\n        console.assert(diagram)\n        this.diagram = diagram\n        this.id = id\n        this.reversed = Boolean(reversed)\n        Object.freeze(this)\n    }\n\n    get rawLine() {\n        return this.diagram.rawDiagram.lines[this.id]\n    }\n\n    get line() {\n        const f = this.reversed ? reverseLine : identity\n        return f(this.diagram.rawDiagram.lines[this.id])\n    }\n\n    get superline() {\n        return this.diagram.superline(this.superlineId)\n    }\n\n    get superlineId() {\n        return this.line.superline\n    }\n\n    get direction() {\n        if (this.rawLine.direction == null) {\n            return null\n        }\n        return this.rawLine.direction * (1 - this.reversed * 2)\n    }\n\n    node(end) {\n        const lineEnds = this.diagram._lineEnds[this.id]\n        return new DiagramNode(this.diagram,\n                               lineEnds[(this.reversed + end) % 2 * 2])\n    }\n\n    lineIndex(end) {\n        const lineEnds = this.diagram._lineEnds[this.id]\n        return lineEnds[(this.reversed + end) % 2 * 2 + 1]\n    }\n\n    cycNodeLine(end, offset) {\n        return this.node(end).line((this.lineIndex(end) + offset) % 3)\n    }\n\n    /** Called automatically when used as the name of a property. */\n    toString() {\n        return (this.reversed ? \"-\" : \"+\") + this.id\n    }\n\n    signedRebase(diagram) {\n        return diagram.signedLine(this.id, this.reversed)\n    }\n\n    reverse() {\n        return new DiagramLine(this.diagram, this.id, !this.reversed)\n    }\n\n    concat(...lines) {\n        return rawConcatLines(lines.map(line => line.line))\n    }\n\n    static removeSign(signedId) {\n        const id = signedId.substr(1)\n        let reversed = false\n        if (signedId[0] == \"-\") {\n            reversed = !reversed\n        } else if (signedId[0] != \"+\") {\n            throw new Error(`not a valid signed line ID: ${signedId}`)\n        }\n        return [id, reversed]\n    }\n\n    rawAssign(rawDiagram, end, lineId) {\n        rawDiagram.nodes[this.node(end).index].lines[this.lineIndex(end)] = lineId\n    }\n\n    testCuttability() {\n        let errors = [subdiagramOrientability(this),\n                      subdiagramOrientability(this.reverse())].filter(identity)\n        if (errors.length == 2) {\n            errors.sort((x, y) => x.priority - y.priority)\n            return errors[0].error\n        }\n        return null\n    }\n}\n\nclass DiagramNode {\n    constructor(diagram, index) {\n        this.diagram = diagram\n        this.index = index\n        Object.freeze(this)\n    }\n\n    get rawNode() {\n        return this.diagram.rawDiagram.nodes[this.index]\n    }\n\n    get type() {\n        return this.rawNode.type\n    }\n\n    get variable() {\n        if (this.type != \"terminal\") {\n            throw new Error(\"node is not a terminal\")\n        }\n        return this.rawNode.variable\n    }\n\n    get numLines() {\n        return this.rawNode.lines.length\n    }\n\n    line(index) {\n        const lineId = this.rawNode.lines[index]\n        const lineEnd = this.diagram._lineEnds[lineId]\n        const reversed = lineEnd[2] == this.index && lineEnd[3] == index\n        return new DiagramLine(this.diagram, lineId, reversed)\n    }\n\n    lines() {\n        return map(index => this.line(index), range(0, this.numLines))\n    }\n\n    get xy() {\n        return [this.rawNode.x, this.rawNode.y]\n    }\n}\n\nexport class Diagram {\n    constructor(rawDiagram) {\n        this.rawDiagram = Object.freeze(rawDiagram) || EMPTY_DIAGRAM\n        this._cache = {}\n        Object.freeze(this)\n    }\n\n    static deserialize(s) {\n        return new Diagram(JSON.parse(s))\n    }\n\n    get serialize() {\n        return JSON.stringify(this.rawDiagram)\n    }\n\n    get _lineEnds() {\n        let lineEnds = this._cache.lineEnds\n        if (!lineEnds) {\n            lineEnds = getLineEnds(this.rawDiagram)\n            this._cache.lineEnds = lineEnds\n        }\n        return lineEnds\n    }\n\n    get terminals() {\n        let terminals = this._cache.terminals\n        if (!terminals) {\n            terminals = {}\n            for (const node of this.nodes()) {\n                if (node.type == \"terminal\") {\n                    if (terminals[node.variable]) {\n                        throw new Error(\"duplicate terminal variables\")\n                    }\n                    terminals[node.variable] = node\n                }\n            }\n            this._cache.terminals = terminals\n        }\n        return terminals\n    }\n\n    terminal(variable) {\n        return this.terminals[variable]\n    }\n\n    get numNodes() {\n        return this.rawDiagram.nodes.length\n    }\n\n    node(index) {\n        return new DiagramNode(this, index)\n    }\n\n    * nodes() {\n        const numNodes = this.numNodes\n        for (let index = 0; index < numNodes; ++index) {\n            yield this.node(index)\n        }\n    }\n\n    get lineIds() {\n        return Object.keys(this.rawDiagram.lines)\n    }\n\n    signedLine(signedId, reversed) {\n        const [id, sign] = DiagramLine.removeSign(signedId)\n        return this.line(id, sign != Boolean(reversed))\n    }\n\n    line(id, reversed) {\n        return new DiagramLine(this, id, reversed)\n    }\n\n    lines() {\n        return map(id => this.line(id), this.lineIds)\n    }\n\n    get superlines() {\n        return this.rawDiagram.superlines\n    }\n\n    superline(superlineId) {\n        return this.superlines[superlineId]\n    }\n\n    hasSuperline(superlineId) {\n        return !!this.superline(superlineId)\n    }\n\n    isEquallyConstrained(superlineId, deltas) {\n        const related = relatedDelta(this.rawDiagram.deltas, superlineId)\n        const otherRelated = relatedDelta(deltas, superlineId)\n        return equalDeltas([related], [otherRelated])\n    }\n\n    renameLines(renames) {\n        let lines = {}\n        for (const lineId of Object.keys(this.rawDiagram.lines)) {\n            const newLineId = renames.hasOwnProperty(lineId)\n                            ? renames[lineId]\n                            : lineId\n            lines[newLineId] = this.rawDiagram.lines[lineId]\n        }\n        const nodes = this.rawDiagram.nodes.map(node =>\n            Object.freeze(Object.assign({}, node, {\n                lines: Object.freeze(node.lines.map(lineId =>\n                    propOr(renames, lineId, lineId)\n                ))\n            }))\n        )\n        return new Diagram(Object.assign({}, this.rawDiagram, {\n            nodes: Object.freeze(nodes),\n            lines: Object.freeze(lines),\n        }))\n    }\n\n    desumExposedSuperlines() {\n        return new Diagram(Object.assign({}, this.rawDiagram, {\n            superlines: mergeSuperlineLists(\n                this.rawDiagram.superlines,\n                ...Object.entries(this.rawDiagram.superlines)\n                .map(([superlineId, superline]) => (\n                    isSuperlineExposed(this.rawDiagram, superlineId)\n                    ? {[superlineId]: {summed: false}}\n                    : {}\n                ))),\n        }))\n    }\n\n    renameSuperlines(renames) {\n        return new Diagram(Object.assign({}, this.rawDiagram, {\n            lines: Object.freeze(Object.assign(\n                {},\n                ...Object.entries(this.rawDiagram.lines)\n                .map(([lineId, line]) => ({\n                    [lineId]: Object.freeze(Object.assign({}, line, {\n                        superline: propOr(renames, line.superline,\n                                          line.superline),\n                    })),\n                })))),\n            superlines: mergeSuperlineLists(\n                ...Object.entries(this.rawDiagram.superlines)\n                .map(([superlineId, superline]) => ({\n                    [propOr(renames, superlineId, superlineId)]: superline,\n                }))),\n            deltas: mergeDeltas(\n                this.rawDiagram.deltas.map(delta =>\n                    delta.map(superlineId =>\n                        propOr(renames, superlineId, superlineId)))),\n        })).removeUnusedSuperlines().desumExposedSuperlines()\n    }\n\n    removeUnusedSuperlines() {\n        let marked = Object.assign({}, this.rawDiagram.superlines)\n        for (const superlineId of Object.keys(marked)) {\n            if (!isEmptySuperline(marked[superlineId])) {\n                delete marked[superlineId]\n            }\n        }\n        for (const line of this.lines()) {\n            delete marked[line.superlineId]\n        }\n        for (const delta of this.rawDiagram.deltas) {\n            for (const superlineId of delta) {\n                delete marked[superlineId]\n            }\n        }\n        let superlines = Object.assign({}, this.rawDiagram.superlines)\n        for (const superlineId of Object.keys(marked)) {\n            delete superlines[superlineId]\n        }\n        if (superlines[\"0\"]) {\n            superlines[\"0\"] = EMPTY_SUPERLINE\n        }\n        return new Diagram(Object.assign({}, this.rawDiagram, {\n            superlines: superlines,\n        }))\n    }\n\n    /** Substitute a portion of this diagram for another subdiagram.\n     *\n     * Patterns are similar to diagrams, but also slightly different:\n     *\n     * - lineIds must refer to existing lines and must be prefixed by `+` or `-`\n     *   to indicate whether it should be treated as reversed\n     * - `line.direction: MATCH_ANY` will absorb any direction\n     */\n    substitute(pattern, replacement, flags) {\n        // schematic idea:\n        //\n        // orig: --- X1 --- N1 --- N2 --- X2 ---\n        // patt:     T1 --- N1 --- N2 --- T2\n        // repl:     T1 ------- N3 ------ T2\n        // new:  --- X1 ------- N3 ------ X2 ---\n        //\n        // anchor = a node that where gluing occurs;\n        //   for 'pattern', all terminals are anchors\n        //   for 'replacement', only terminals that match the pattern are\n        //\n        // the interesting/tricky parts occur on the terminals of the pattern;\n        // this is where we have to glue the original diagram to the\n        // replacement subdiagram.\n        //\n        // we have to make sure that the phases on X1-N1 are appropriately\n        // merged into X1-N3 and similarly for N2-X2, and also account for\n        // degenerate cases\n\n        flags = flags || {}\n        pattern = ensureDiagram(pattern)\n        replacement = ensureDiagram(replacement)\n        const rawDiagram = this.rawDiagram\n        const pattDiagram = new Diagram(pattern)\n        let replDiagram = new Diagram(replacement)\n\n        // DELTAS\n        // ------\n\n        // (shared with other parts)\n        let deltaMerge = [rawDiagram.deltas, replacement.deltas]\n\n        // match deltas\n        if (!containsDeltas(rawDiagram.deltas, pattern.deltas)) {\n            throw new Error(\"mismatch in deltas\")\n        }\n\n        // SHARED LINES\n        // ------------\n\n        // we allow a limited form of sharing: two pattern lines can map onto\n        // the same original line as long as the orientation is different;\n        // this in turn has the potential to create loops\n        let sharedLines = {}\n        let seenLines = {}\n        for (const pattLine of pattDiagram.lines()) {\n            const id = DiagramLine.removeSign(pattLine.id)[0]\n            const seen = seenLines[id]\n            if (seen) {\n                if (!(seen.node(0).type == \"terminal\" ||\n                      seen.node(1).type == \"terminal\")\n                    || !(pattLine.node(0).type == \"terminal\" ||\n                         pattLine.node(1).type == \"terminal\")) {\n                    throw new Error(\"a single internal line cannot \"\n                                  + \"match multiple lines\")\n                }\n                if (pattLine.node(0).type == \"terminal\"\n                    && pattLine.node(1).type == \"terminal\") {\n                    // this causes ambiguity and breakage\n                    throw new Error(\"a lone pattern line cannot be shared\")\n                }\n                if (sharedLines[pattLine.id] || sharedLines[seen.id]) {\n                    throw new Error(\"looped lines can only appear twice\")\n                }\n                sharedLines[pattLine.id] = seen.id\n                sharedLines[seen.id] = pattLine.id\n                continue\n            }\n            seenLines[id] = pattLine\n        }\n\n        // LINE RENAMING\n        // -------------\n\n        // (shared with other parts)\n        let newLines = Object.assign({}, rawDiagram.lines)\n\n        // must remove the pattern lines first, because we want to know which\n        // line IDs are available to us\n        for (const pattLine of pattDiagram.lines()) {\n            const lineId = DiagramLine.removeSign(pattLine.id)[0]\n            console.assert(newLines[lineId] || sharedLines[pattLine.id])\n            delete newLines[lineId]\n        }\n        // rename the replacement diagram to avoid conflicting line IDs\n        // and also replace the dummy line IDs\n        let freshLineIds = availLabels(newLines)\n        let lineRenames = {}\n        for (const line of replDiagram.lines()) {\n            if (line.id.startsWith(\"$\") || newLines.hasOwnProperty(line.id)) {\n                lineRenames[line.id] = freshLineIds.next().value\n            }\n        }\n        replDiagram = replDiagram.renameLines(lineRenames)\n        replacement = replDiagram.rawDiagram\n\n        // SUPERLINES\n        // ----------\n\n        // (shared with other parts)\n        let superlineMerge = [rawDiagram.superlines]\n\n        // match superlines and adjust phases\n        let summedSuperlines = new Set()\n        for (const superlineId of Object.keys(pattern.superlines)) {\n            const pattSuperline = pattern.superlines[superlineId]\n            const superline = rawDiagram.superlines[superlineId]\n            if (pattSuperline.summed) {\n                if (superlineId != \"0\") {\n                    if (!superline.summed) {\n                        throw new Error(\"expected summed superline\")\n                    }\n                    if (pattSuperline.weight != superline.weight) {\n                        throw new Error(\"weight of summed superline must match\")\n                    }\n                    if (pattSuperline.phase != superline.phase) {\n                        throw new Error(\"phase of summed superline must match\")\n                    }\n                    if (!this.isEquallyConstrained(superlineId,\n                                                   replacement.deltas)) {\n                        throw new Error(\"deltas of summed superline must match\")\n                    }\n                    summedSuperlines.add(superlineId)\n                }\n                superlineMerge.push({[superlineId]: {summed: false}})\n            }\n            superlineMerge.push({\n                [superlineId]: {\n                    weight: -pattSuperline.weight,\n                    phase: -pattSuperline.phase,\n                },\n            })\n        }\n        // forbid variable capture\n        for (const superlineId of Object.keys(replacement.superlines)) {\n            const replSuperline = replacement.superlines[superlineId]\n            if (replSuperline.summed) {\n                const pattSuperline = pattern.superlines[superlineId]\n                if (pattSuperline) {\n                    if (!pattSuperline.summed) {\n                        throw new Error(\"summed variable conflicts \"\n                                      + \"with pattern\")\n                    }\n                } else if (rawDiagram.superlines[superlineId]) {\n                    throw new Error(\"summed variable conflicts with original\")\n                }\n            }\n        }\n        superlineMerge.push(replacement.superlines)\n\n        // NODES\n        // -----\n\n        // match nodes and adjust phases\n        for (const pattNode of pattDiagram.nodes()) {\n            if (pattNode.type == \"terminal\") {\n                continue\n            }\n            if (pattNode.numLines == 0) {\n                throw new Error(\"singleton nodes are not supported\")\n            }\n            const node = pattNode.line(0).signedRebase(this).node(0)\n            if (node.type != pattNode.type) {\n                throw new Error(\"node type mismatch\")\n            }\n            const nodeLines = Array.from(node.rawNode.lines)\n            const pattNodeLines = Array.from(pattNode.rawNode.lines)\n            if (node.type == \"w3j\") {\n                const uniqueLines = permutSign(nodeLines, nodeLines)\n                const sign = permutSign(\n                    nodeLines,\n                    pattNodeLines.map(signedId =>\n                        DiagramLine.removeSign(signedId)[0]))\n                if (uniqueLines && sign == 0) {\n                    throw new Error(\"node lines mismatch\")\n                }\n                if (sign < 0) {\n                    superlineMerge.push(\n                        {[nodeLines[0]]: {phase: 1}},\n                        {[nodeLines[1]]: {phase: 1}},\n                        {[nodeLines[2]]: {phase: 1}},\n                    )\n                }\n            } else if (lexicalCmp(nodeLines, pattNodeLines, defaultCmp) != 0) {\n                throw new Error(\"node lines mismatch\")\n            }\n        }\n\n        // LINES\n        // -----\n\n        // match lines and adjust phases\n        let matchedLineIds = new Set()\n        for (const pattLine of pattDiagram.lines()) {\n            const pattNode0 = pattLine.node(0)\n            const pattNode1 = pattLine.node(1)\n            const line = pattLine.signedRebase(this)\n            if (line.superlineId != pattLine.superlineId) {\n                throw new Error(\"superline ID mismatch in lines\")\n            }\n            if (pattNode0.type != \"terminal\"\n                && pattNode1.type != \"terminal\"\n                && pattLine.direction != null) {\n                const diffDirection = mergeDirections(line.direction,\n                                                     -pattLine.direction)\n                if (line.superlineId != \"0\" && diffDirection % 2 != 0) {\n                    throw new Error(\"directedness mismatch in lines\")\n                }\n                superlineMerge.push({\n                    [line.superlineId]: {phase: diffDirection},\n                })\n            }\n            matchedLineIds.add(line.id)\n        }\n        // prevent summed superlines from appearing outside the pattern\n        const patternSuperlineSet = new Set(Object.keys(pattern.superlines))\n        for (const line of this.lines()) {\n            if (!matchedLineIds.has(line.id) &&\n                summedSuperlines.has(line.superlineId)) {\n                throw new Error(\"summed line must not appear outside match\")\n            }\n        }\n\n        let nodes = rawDiagram.nodes.map(node => Object.assign({}, node, {\n            lines: node.lines.slice(),\n        }))\n        let replNodes = replacement.nodes.map(node => Object.assign({}, node, {\n            lines: node.lines.slice(),\n        }))\n        let seenReplLines = {}\n        // find the node that we should join to\n        //\n        // context: this, pattDiagram, nodes, replNodes, seenReplLines\n        const findJoiningNode = replLine => {\n            // There's several cases to consider here.\n            //\n            // In the simplest case, with no shared lines, we have:\n            //\n            // orig  N1 --->---\n            // patt     ---<--- TP\n            // repl     --->--- TR\n            //\n            // A shared line case might look like this:\n            //\n            //          -------------------------\n            //         /                         \\\n            //         \\                         /\n            // orig     -->---             ------\n            // patt    ---<--- TP1     TP2 --->---\n            // repl    --->--- TR1     TR2 --->---\n            //\n            // This could go on for several jumps, if the node opposite to\n            // TR2 is an anchor too.  It could even loop back to itself.\n            let lines = [replLine.line]\n            while (true) {\n                const replNode = replLine.node(1)\n                const result = {\n                    type: \"replacement\",\n                    lines: lines,\n                    line: replLine,\n                    lineId: replLine.id,\n                    nodes: replNodes,\n                }\n                if (replNode.type != \"terminal\") {\n                    return result\n                }\n                const pattNode = pattDiagram.terminal(replNode.variable)\n                if (!pattNode) {\n                    return result\n                }\n                seenReplLines[replLine.id] = true\n                const pattLine = pattNode.line(0)\n                const line = pattLine.signedRebase(this).reverse()\n                // avoid consuming phases twice if the pattern line is\n                // terminal-to-terminal\n                if (pattLine.node(1).type != \"terminal\" || !pattLine.reversed) {\n                    lines.push(pattLine.line, line.line)\n                }\n                const otherPattLineId = sharedLines[pattLine.id]\n                if (!otherPattLineId) {\n                    // no shared line, so joining node is from original diagram\n                    return {\n                        type: \"original\",\n                        lines: lines,\n                        line: line,\n                        lineId: replLine.id,\n                        nodes: nodes,\n                    }\n                }\n                // we have shared line, so joining node comes from elsewhere\n                const otherPattLine = pattDiagram.line(otherPattLineId,\n                                                       pattLine.reversed)\n                const otherPattNode = otherPattLine.node(0)\n                if (otherPattNode.type != \"terminal\") {\n                    throw new Error(\"expected terminal node\")\n                }\n                lines.push(otherPattLine.reverse().line)\n                replLine = replDiagram.terminal(otherPattNode.variable).line(0)\n                if (seenReplLines[replLine.id]) {\n                    // we found a loop\n                    return {\n                        type: \"cycle\",\n                        lines: lines,\n                    }\n                }\n                lines.push(replLine.line)\n            }\n        }\n        function getPart(joining) {\n            switch (joining.type) {\n                case \"replacement\":\n                    return joining.line.node(1).type == \"terminal\" ? -1 : 1\n                case \"original\":\n                    return 0\n                default:\n                    throw new Error(\"joining type not valid here\")\n            }\n        }\n        for (const replLine of replDiagram.lines()) {\n            if (seenReplLines[replLine.id]) {\n                continue // avoid double-counting\n            }\n            const joining0 = findJoiningNode(replLine.reverse())\n            if (joining0.type == \"cycle\") {\n                // special case: cycle\n                const combined = concatLines(...joining0.lines)\n                deltaMerge.push([combined.delta])\n                if (combined.line.direction % 2) {\n                    throw new Error(\"directed loops are forbidden\")\n                }\n                superlineMerge.push({\n                    [combined.line.superline]: {\n                        phase: combined.phase,\n                        weight: 2,\n                    },\n                })\n                continue\n            }\n            const joining1 = findJoiningNode(replLine)\n            const lineId = joining0.lineId\n            const nodeIndex0 = joining0.line.node(1).index\n            const nodeIndex1 = joining1.line.node(1).index\n            const lineIndex0 = joining0.line.lineIndex(1)\n            const lineIndex1 = joining1.line.lineIndex(1)\n            const lines = joining0.lines\n                                  .map(reverseLine)\n                                  .reverse()\n                                  .concat(joining1.lines.slice(1))\n            const f = lexicalCmp([getPart(joining0), nodeIndex0, lineIndex0],\n                                 [getPart(joining1), nodeIndex1, lineIndex1],\n                                 defaultCmp) > 0\n                    ? reverseLine : identity\n            joining0.nodes[nodeIndex0].lines[lineIndex0] = lineId\n            joining1.nodes[nodeIndex1].lines[lineIndex1] = lineId\n            const combined = concatLines(...lines)\n            // prefer superlines that aren't summed to avoid\n            // exposing them as external lines\n            deltaMerge.push([combined.delta])\n            console.assert(!newLines[lineId])\n            let superline = combined.line.superline\n            for (const superlineId of combined.delta) {\n                if (!this.superline(superlineId) ||\n                    !this.superline(superlineId).summed) {\n                    superline = superlineId\n                    break\n                }\n            }\n            newLines[lineId] = ensureLine(f(Object.assign({}, combined.line, {\n                superline: superline,\n            })))\n            superlineMerge.push({\n                [combined.line.superline]: {phase: combined.phase},\n            })\n        }\n\n        const newNodes = Array.prototype.concat(\n            replacement.nodes.filter((node, nodeIndex) =>\n                node.type == \"terminal\" && !pattDiagram.terminal(node.variable)\n            ),\n            arrayRemoveMany(\n                nodes,\n                Array.from(\n                    map(node => node.line(0)\n                                    .signedRebase(this)\n                                    .node(0)\n                                    .index,\n                        filter(node => node.type != \"terminal\",\n                               pattDiagram.nodes())))),\n            replacement.nodes.filter(node => node.type != \"terminal\"))\n\n        const newDiagram = new Diagram(Object.assign({}, rawDiagram, {\n            nodes: newNodes,\n            lines: newLines,\n            superlines: mergeSuperlineLists(...superlineMerge),\n            deltas: mergeDeltas(...deltaMerge),\n        })).removeUnusedSuperlines()\n\n        if (flags.withLineRenames) {\n            return {diagram: newDiagram, lineRenames: lineRenames}\n        } else {\n            return newDiagram\n        }\n    }\n}\n\nfunction findW3jLoop(node) {\n    if (node.type != \"w3j\") {\n        return \"not a Wigner 3-jm symbol\"\n    }\n    for (let i = 0; i < 3; ++i) {\n        if (node.line(i).id == node.line((i + 1) % 3).id) {\n            return {\n                cutLine: node.line((i + 2) % 3),\n                loopLine: node.line(i),\n            }\n        }\n    }\n    return \"no loops found\"\n}\n\nfunction loopElimRule(diagram, lineId, nodeIndex) {\n    diagram = new Diagram(diagram)\n    const loopNode = diagram.line(lineId).node(0)\n    if (loopNode.index != diagram.line(lineId).node(1).index) {\n        return \"no loops found\"\n    }\n    const loop = findW3jLoop(loopNode)\n    if (typeof loop != \"object\") {\n        return loop\n    }\n    if (!isLineDirectable(loop.loopLine.line)) {\n        return \"loop must be directed\"\n    }\n    const otherNode = loop.cutLine.node(1)\n    if (otherNode.type != \"w3j\") {\n        diagram = deepClone(diagram.rawDiagram)\n        diagram.deltas = mergeDeltas(\n            diagram.deltas,\n            [[diagram.lines[loop.cutLine.id].superline, \"0\"]])\n        diagram.lines[loop.cutLine.id].superline = \"0\"\n        diagram.superlines[\"0\"] = EMPTY_SUPERLINE\n        return diagram\n    }\n    if (otherNode.index != nodeIndex && loopNode.index != nodeIndex) {\n        return \"not sure what you're trying to do\"\n    }\n    const ld = loop.loopLine\n    const lc = loop.cutLine\n    const lb = loop.cutLine.cycNodeLine(1, 1).reverse()\n    const la = loop.cutLine.cycNodeLine(1, 2).reverse()\n    if (la.id == lb.id && !isLineDirectable(la.line)) {\n        // other loop must be directed too if we want to eliminate it\n        diagram = deepClone(diagram.rawDiagram)\n        diagram.deltas = mergeDeltas(\n            diagram.deltas,\n            [[diagram.lines[loop.cutLine.id].superline, \"0\"]])\n        diagram.lines[loop.cutLine.id].superline = \"0\"\n        diagram.superlines[\"0\"] = EMPTY_SUPERLINE\n        return diagram\n    }\n    const md = ld.toString()\n    const mc = lc.toString()\n    const mb = lb.toString()\n    const ma = la.toString()\n    const jd = ld.superlineId\n    const jc = lc.superlineId\n    const jb = lb.superlineId\n    const ja = la.superlineId\n    return diagram.substitute({\n        nodes: [\n            terminalNode(ma, \"a\"),\n            terminalNode(mb, \"b\"),\n            w3jNode(md, md, mc),\n            w3jNode(mc, mb, ma),\n        ],\n        lines: {\n            [md]: {superline: jd, direction: +1},\n            [mc]: {superline: jc, direction: null},\n            [mb]: {superline: jb, direction: 0},\n            [ma]: {superline: ja, direction: +1},\n        },\n        superlines: {\n            [ja]: {weight: 1},\n        },\n    }, {\n        nodes: [\n            terminalNode(\"$1\", \"a\"),\n            terminalNode(\"$1\", \"b\"),\n        ],\n        lines: {\n            $1: {superline: jb, direction: 0,\n                 arcHeight: -8 * lb.line.arcHeight}, // empirically works...\n        },\n        superlines: {\n            [jd]: {weight: 1},\n            \"0\": {},\n        },\n        deltas: [\n            [\"0\", jc],\n        ],\n    }).rawDiagram\n}\n\nfunction loopIntroRule(diagram, lineId, xy1, xy2) {\n    diagram = new Diagram(diagram)\n    const line = diagram.line(lineId)\n    const dxy = vectorSubtract(xy2, xy1)\n    const angle = Math.atan2(dxy[1], dxy[0])\n    return diagram.substitute({\n        nodes: [\n            terminalNode(line.toString(), \"a\"),\n            terminalNode(line.toString(), \"b\"),\n        ],\n        lines: {\n            [line]: {superline: line.superlineId, direction: 0},\n        },\n    }, {\n        nodes: [\n            terminalNode(\"$1\", \"a\"),\n            terminalNode(\"$2\", \"b\"),\n            w3jNode(\"$4\", \"$4\", \"$3\", ...xy2),\n            w3jNode(\"$3\", \"$2\", \"$1\", ...xy1),\n        ],\n        lines: {\n            $4: {superline: \"0\", direction: +1,\n                 angle: angle - 0.5 * Math.PI, arcHeight: 50.0},\n            $3: {superline: \"0\", direction: 0},\n            $2: {superline: line.superlineId, direction: 0,\n                 arcHeight: -line.line.arcHeight / 4},\n            $1: {superline: line.superlineId, direction: +1,\n                 arcHeight: -line.line.arcHeight / 2},\n        },\n        superlines: {\n            [line.superlineId]: {weight: 1},\n        },\n    }).rawDiagram\n}\n\nfunction w3jIntroRule(diagram, lineId1, lineId2, reversed, diagonal) {\n    diagram = new Diagram(diagram)\n    let line1 = diagram.line(lineId1)\n    let line2 = diagram.line(lineId2)\n    if ((vectorDot(\n        vectorSubtract(line1.node(1).xy, line1.node(0).xy),\n        vectorSubtract(line2.node(1).xy, line2.node(0).xy),\n    ) < 0) != Boolean(reversed)) {\n        line2 = line2.reverse()\n    }\n    const xy1 = vectorAdd(\n        scalarMultiply(0.375, vectorAdd(line1.node(0).xy, line2.node(0).xy)),\n        scalarMultiply(0.125, vectorAdd(line1.node(1).xy, line2.node(1).xy)),\n    )\n    const xy2 = vectorAdd(\n        scalarMultiply(0.125, vectorAdd(line1.node(0).xy, line2.node(0).xy)),\n        scalarMultiply(0.375, vectorAdd(line1.node(1).xy, line2.node(1).xy)),\n    )\n    const j = availSuperlineLabels(diagram.rawDiagram).next().value\n    const arcHeight1 = line1.node(0).index == line2.node(0).index ? 50.0 : 0.0\n    const arcHeight2 = line1.node(1).index == line2.node(1).index ? 50.0 : 0.0\n    return diagram.substitute({\n        nodes: [\n            terminalNode(line1.toString(), \"a\"),\n            terminalNode(line1.toString(), \"b\"),\n            terminalNode(line2.toString(), \"c\"),\n            terminalNode(line2.toString(), \"d\"),\n        ],\n        lines: {\n            [line1]: {superline: line1.superlineId, direction: 0},\n            [line2]: {superline: line2.superlineId, direction: 0},\n        },\n    }, {\n        nodes: [\n            terminalNode(\"$1\", \"a\"),\n            terminalNode(\"$2\", \"b\"),\n            terminalNode(\"$3\", \"c\"),\n            terminalNode(\"$4\", \"d\"),\n            w3jNode(\"$1\", \"$3\", \"$5\", ...xy1),\n            w3jNode(\"$2\", \"$4\", \"$5\", ...xy2),\n        ],\n        lines: {\n            $1: {superline: line1.superlineId, direction: Number(diagonal),\n                 arcHeight: -arcHeight1},\n            $2: {superline: line1.superlineId, direction: Number(diagonal),\n                 arcHeight: -arcHeight2},\n            $3: {superline: line2.superlineId, direction: 0,\n                 arcHeight: arcHeight1},\n            $4: {superline: line2.superlineId, direction: 0,\n                 arcHeight: arcHeight2},\n            $5: {superline: j, direction: 0},\n        },\n        superlines: {\n            [j]: {phase: 0, weight: 2, summed: true},\n        },\n    }).rawDiagram\n}\n\nfunction w3jElimRule(diagram, lineId) {\n    diagram = new Diagram(diagram)\n    const line = diagram.line(lineId)\n    const superline = line.superline\n    if (!superline.summed) {\n        return `j[${line.superlineId}] must be summed over`\n    }\n    if (superline.phase != 0) {\n        return `j[${line.superlineId}] must not have any phases`\n    }\n    if (superline.weight != 2) {\n        return `weight of j[${line.superlineId}] must be exactly 2`\n    }\n    if (!diagram.isEquallyConstrained(line.superlineId, [])) {\n        return `j[${line.superlineId}] must not be constrained by deltas`\n    }\n    for (const otherLine of diagram.lines()) {\n        if (otherLine.id != line.id && otherLine.superlineId == line.superlineId) {\n            return `j[${line.superlineId}] must not appear anywhere else`\n        }\n    }\n    if (line.node(0).type != \"w3j\" || line.node(1).type != \"w3j\") {\n        return \"expected Wigner 3-j symbols\"\n    }\n    const line1 = line.cycNodeLine(0, 1).reverse()\n    const line2 = line.cycNodeLine(1, 1).reverse()\n    const line3 = line.cycNodeLine(0, 2).reverse()\n    const line4 = line.cycNodeLine(1, 2).reverse()\n    if (line1.superlineId != line2.superlineId\n        || line3.superlineId != line4.superlineId) {\n        return \"opposing j's don't match\"\n    }\n    const lineIdOther = line1.id == line3.id ? line4.id : line3.id\n    console.assert(line1.id, lineIdOther)\n    return diagram.substitute({\n        nodes: [\n            terminalNode(line1.toString(), \"a\"),\n            terminalNode(line2.toString(), \"b\"),\n            terminalNode(line3.toString(), \"c\"),\n            terminalNode(line4.toString(), \"d\"),\n            w3jNode(line1.toString(), line3.toString(), line.toString()),\n            w3jNode(line2.toString(), line4.toString(), line.toString()),\n        ],\n        lines: {\n            [line1]: {superline: line1.superlineId, direction: 0},\n            [line2]: {superline: line2.superlineId, direction: 0},\n            [line3]: {superline: line3.superlineId, direction: 0},\n            [line4]: {superline: line4.superlineId, direction: 0},\n            [line]: {superline: line.superlineId, direction: 0},\n        },\n        superlines: {\n            [line.superlineId]: {phase: 0, weight: 2, summed: true},\n        },\n    }, {\n        nodes: [\n            terminalNode(line1.id, \"a\"),\n            terminalNode(line1.id, \"b\"),\n            terminalNode(lineIdOther, \"c\"),\n            terminalNode(lineIdOther, \"d\"),\n        ],\n        lines: {\n            [line1.id]: {superline: line1.superlineId, direction: 0},\n            [lineIdOther]: {superline: line3.superlineId, direction: 0},\n        },\n    }).rawDiagram\n}\n\nfunction getAmbientDirections(diagram, ignoreExternal) {\n    // lines we don't care about:\n    // - external lines with no pre-existing direction\n    // - zero lines\n    // however, unlike zero lines, we do still need to *show* the correct\n    // arrows, so we can't toss out those external lines entirely!\n    let excludedLineIds = []\n    let directions = new RealSparseVector()\n    for (const line of diagram.lines()) {\n        if (line.superlineId != \"0\") {\n            if ([line.node(0).type, line.node(1).type].includes(\"terminal\")\n                && (ignoreExternal || line.direction % 2 == 0)) {\n                excludedLineIds.push(line.id)\n            }\n            directions.set(line.id, 1 - mod(line.direction, 2))\n        }\n    }\n    let matrix = new RealSparseMatrix()\n    for (const node of diagram.nodes()) {\n        if (node.type == \"w3j\") {\n            for (const line of node.lines()) {\n                if (line.superlineId != \"0\") {\n                    matrix.modify(line.id, node.index,\n                                  x => x + (line.reversed ? -1 : 1))\n                }\n            }\n        }\n    }\n    let subdirections = directions.copy()\n    let submatrix = matrix.map(x => mod(x, 2))\n    for (const lineId of excludedLineIds) {\n        subdirections.delete(lineId)\n        submatrix.deleteRow(lineId)\n    }\n    const result = sparseGaussElim(GF2_FIELD, submatrix, subdirections)\n    const ambient = sparseMatrixVectorMultiply(REAL_FIELD, matrix,\n                                               result.solution.map(x => -x))\n    return {\n        orientable: result.consistent,\n        directions: ambient,\n        target: subdirections,\n    }\n}\n\nfunction getConnectedSubdiagram(line0) {\n    let closed = true\n    let isolated = true\n    let nodeIndices = new Set()\n    let lines = {}\n    let candidates = [line0]\n    while (candidates.length > 0) {\n        const line = candidates.pop()\n        if (lines.hasOwnProperty(line.id)) {\n            if (line.id == line0.id && line.reversed == line0.reversed) {\n                isolated = false\n            }\n            continue\n        }\n        const node = line.node(1)\n        if (node.type == \"terminal\") {\n            closed = false\n        }\n        nodeIndices.add(node.index)\n        lines[line.id] = line.rawLine\n        for (const line of node.lines()) {\n            candidates.push(line)\n        }\n    }\n    const rawDiagram = line0.diagram.rawDiagram\n    return {\n        closed: closed,\n        isolated: isolated,\n        diagram: Object.assign({}, rawDiagram, {\n            nodes: rawDiagram.nodes.filter((_, nodeIndex) =>\n                nodeIndices.has(nodeIndex)),\n            lines: lines,\n        }),\n    }\n}\n\nfunction subdiagramOrientability(line0) {\n    const subdiagram = getConnectedSubdiagram(line0)\n    if (!subdiagram.isolated) {\n        return {\n            error: \"only bridges can be cut\",\n            priority: 1,\n        }\n    }\n    if (!subdiagram.closed) {\n        return {\n            error: \"subdiagram must be closed\",\n            priority: 2,\n        }\n    }\n    const diagram = Object.assign({}, subdiagram.diagram)\n    diagram.lines = Object.assign({}, diagram.lines)\n    diagram.lines[line0.id] = Object.assign({}, diagram.lines[line0.id], {\n        superline: \"0\",\n    })\n    const ambient = getAmbientDirections(new Diagram(diagram), true)\n    if (!ambient.orientable) {\n        return {\n            error: \"diagram is non-orientable\",\n            priority: 0,\n        }\n    }\n    return null\n}\n\nfunction cutRule(diagram, lineId, xy1, xy2) {\n    diagram = new Diagram(diagram)\n    const line = diagram.line(lineId)\n    if (vectorDot(vectorSubtract(xy1, xy2),\n                  vectorSubtract(line.node(0).xy, line.node(1).xy)) < 0) {\n        [xy1, xy2] = [xy2, xy1]\n    }\n    if (line.superlineId != \"0\") {\n        let error = line.testCuttability()\n        if (error) {\n            return error\n        }\n    }\n    const dxy = vectorSubtract(xy1, xy2)\n    const angle = Math.atan2(dxy[1], dxy[0])\n    const result = diagram.substitute({\n        nodes: [\n            terminalNode(line.toString(), \"a\"),\n            terminalNode(line.toString(), \"b\"),\n        ],\n        lines: {\n            [line]: {superline: line.superlineId, direction: 0},\n        },\n    }, {\n        nodes: [\n            terminalNode(\"$1\", \"a\"),\n            terminalNode(\"$2\", \"b\"),\n            w3jNode(\"$1\", \"$3\", \"$3\", xy1[0], xy1[1]),\n            w3jNode(\"$2\", \"$4\", \"$4\", xy2[0], xy2[1]),\n        ],\n        lines: {\n            $1: {superline: line.superlineId, direction: 0,\n                 arcHeight: -0.5 * line.line.arcHeight},\n            $2: {superline: line.superlineId, direction: 0,\n                 arcHeight: -0.25 * line.line.arcHeight},\n            $3: {superline: \"0\", direction: 0,\n                 angle: angle + 0.5 * Math.PI, arcHeight: 50},\n            $4: {superline: \"0\", direction: 0,\n                 angle: angle + 1.5 * Math.PI, arcHeight: 50},\n        },\n        deltas: [\n            [\"0\", line.superlineId],\n        ],\n    }, {withLineRenames: true})\n    diagram = result.diagram.rawDiagram\n    // try to eliminate the loops if possible\n    const renames = result.lineRenames\n    const loop1Id = result.diagram.line(renames.$3).id\n    const loop2Id = result.diagram.line(renames.$4).id\n    const loopNode1Index = result.diagram.line(loop1Id).node(0).index\n    // kind of fragile: relying on the fact that pruning doesn't relabel lines\n    let newDiagram = loopElimRule(diagram, loop1Id, loopNode1Index)\n    if (typeof newDiagram == \"string\") {\n        return diagram\n    }\n    diagram = newDiagram\n    const loopNode2Index = new Diagram(diagram).line(loop2Id).node(0).index\n    newDiagram = loopElimRule(diagram, loop2Id, loopNode2Index)\n    if (typeof newDiagram == \"string\") {\n        return diagram\n    }\n    return newDiagram\n}\n\nfunction glueRule(diagram, lineId1, lineId2, xy1, xy2) {\n    diagram = new Diagram(diagram)\n    const line1 = diagram.line(lineId1)\n    const line2 = diagram.line(lineId2)\n    if (line1.id == line2.id) {\n        return diagram // not supported (tricky to implement / easy workaround)\n    }\n    return diagram.substitute({\n        nodes: [\n            terminalNode(line1.toString(), \"a\"),\n            terminalNode(line1.toString(), \"b\"),\n            terminalNode(line2.toString(), \"c\"),\n            terminalNode(line2.toString(), \"d\"),\n        ],\n        lines: {\n            [line1]: {superline: line1.superlineId, direction: +1},\n            [line2]: {superline: line2.superlineId, direction: +1},\n        },\n    }, {\n        nodes: [\n            terminalNode(\"$1\", \"a\"),\n            terminalNode(\"$2\", \"b\"),\n            terminalNode(\"$3\", \"c\"),\n            terminalNode(\"$4\", \"d\"),\n            w3jNode(\"$1\", \"$2\", \"$5\", xy1[0], xy1[1]),\n            w3jNode(\"$3\", \"$4\", \"$5\", xy2[0], xy2[1]),\n        ],\n        lines: {\n            $1: {superline: line1.superlineId, direction: 0},\n            $2: {superline: line1.superlineId, direction: 0},\n            $3: {superline: line2.superlineId, direction: 0},\n            $4: {superline: line2.superlineId, direction: 0},\n            $5: {superline: \"0\", direction: 0},\n        },\n        superlines: mergeSuperlineLists( // these superlineIds might collide!\n            {[line1.superlineId]: {weight: +1}},\n            {[line2.superlineId]: {weight: +1}},\n        ),\n    }).rawDiagram\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Drawing\n\nfunction renderArrow(update, diagram, lineId, ambient) {\n    const arrowHeadSize = 15\n    const line = diagram.lines[lineId]\n    let bad = false\n    let expectedDirection = false\n    let direction = line.direction\n    if (ambient) {\n        expectedDirection = ambient.target.get(lineId)\n        const ambientDirection = ambient.directions.get(lineId)\n        bad = !direction == !ambientDirection\n        direction = direction || ambientDirection\n    }\n    if (direction == 0 && !expectedDirection) {\n        return []\n    }\n    if (line.arrowPos < 0.0) {\n        line.arrowPos = 0.0\n    } else if (line.arrowPos > 1.0) {\n        line.arrowPos = 1.0\n    }\n    const info = getLineInfo(diagram, lineId)\n    // the coordinate we need is the tip of the arrow (which follows the\n    // contour of the line), but we want to try to keep the body of\n    // the arrow centered\n    const correction = direction * arrowHeadSize / 2\n    const position = positionOnLine(info, line.arrowPos, correction)\n    const rawPosition = positionOnLine(info, line.arrowPos, 0)\n    const angle = position.tangentAngle\n                + Number(direction < 0) * Math.PI\n    return [vnode(\n        \"svg:g\",\n        {\n            \"class\": \"arrow \"\n                   + (!line.direction ? \"ambient \" : \"\")\n                   + (info.external ? \"external \" : \"\")\n                   + (bad ? \"bad \" : \"\"),\n            onmousedown: function(e) {\n                if (e.buttons == 1) {\n                    update(startDrag(rawPosition.x, rawPosition.y, {\n                        superficial: true,\n                    }, (diagram, x, y, snap) => {\n                        const pos = findPosOnLine(info, x, y).pos\n                        let lines = Object.assign({}, diagram.lines)\n                        // prevent arrows from getting stuck under nodes\n                        lines[lineId] = Object.assign({}, lines[lineId], {\n                            arrowPos: clamp(0.1, 0.9, round(snap && 0.1, pos)),\n                        })\n                        return Object.assign({}, diagram, {lines: lines})\n                    }))\n                    e.stopPropagation()\n                } else if (e.buttons == 2 && e.ctrlKey) {\n                    update(modifyDiagram({superficial: true}, diagram => {\n                        let lines = Object.assign({}, diagram.lines)\n                        lines[lineId] = Object.assign({}, lines[lineId], {\n                            arrowPos: 0.5,\n                        })\n                        return Object.assign({}, diagram, {lines: lines})\n                    }))\n                    e.stopPropagation()\n                }\n            },\n        },\n        vnode(\"svg:circle\", {\n            \"class\": \"hit\",\n            r: 15,\n            cx: rawPosition.x,\n            cy: rawPosition.y,\n        }),\n        direction ? vnode(\"svg:use\", {\n            \"class\": \"arrowhead\",\n            href: \"#arrowhead\",\n            x: -arrowHeadSize,\n            y: -arrowHeadSize / 2,\n            width: arrowHeadSize,\n            height: arrowHeadSize,\n            transform: `translate(${position.x}, ${position.y}) `\n                     + `rotate(${angle * 180 / Math.PI})`,\n        }) : vnode(\"svg:circle\", {\n            \"class\": \"arrowhead\",\n            cx: position.x,\n            cy: position.y,\n            r: arrowHeadSize / 2,\n        }),\n    )]\n}\n\nfunction renderLine(update, editor, lineId, ambient) {\n    const diagram = editor.snapshot.diagram\n    const line = diagram.lines[lineId]\n    const superline = diagram.superlines[line.superline]\n    const minTextOffset = 20\n    const info = getLineInfo(diagram, lineId)\n    const position = positionOnLine(info, line.textPos, 0)\n    let textOffset = line.textOffset\n    if (textOffset == 0) {\n        textOffset = minTextOffset * info.halfDisk\n    } else if (textOffset > 0 && textOffset < minTextOffset) {\n        textOffset = minTextOffset\n    } else if (textOffset < 0 && textOffset > -minTextOffset) {\n        textOffset = -minTextOffset\n    }\n    let d = `M ${info.x0} ${info.y0} `\n    if (info.arc.radius == Infinity) {\n        // don't make Inkscape sad\n        d += `L `\n    } else {\n        const radius = Math.abs(info.arc.radius)\n        d += `A ${radius} ${radius} 0 `\n           + `${Number(info.arc.large)} ${Number(info.arc.sweep)} `\n    }\n    d += `${info.x1} ${info.y1}`\n    const textX = position.x + textOffset * position.normalX\n    const textY = position.y + textOffset * position.normalY\n    function onmousedown(e) {\n        const [x, y] = toSvgCoords([e.clientX, e.clientY])\n        if (e.buttons == 1) {\n            update(startDrag(x, y, {\n                superficial: true,\n            }, (diagram, x, y, snap) => {\n                let change\n                if (info.singular) {\n                    const dx = x - info.xMid\n                    const dy = y - info.yMid\n                    const angle = Math.atan2(dy, dx) - Math.PI / 2\n                    const height = Math.sqrt(dx * dx + dy * dy)\n                    change = {\n                        angle: round(snap && Math.PI / 6, angle),\n                        arcHeight: clamp(20.0, Infinity,\n                                         round(snap && 20.0, height)),\n                    }\n                } else {\n                    change = {\n                        angle: info.trueAngle,\n                        arcHeight: round(snap && 20.0,\n                                         threePointArc(x, y,\n                                                       info.x0, info.y0,\n                                                       info.x1, info.y1)),\n                    }\n                }\n                return setDiagramLineProps(diagram, lineId, change)\n            }))\n            e.stopPropagation()\n        } else if (e.buttons == 2 && e.ctrlKey == true) {\n            update(modifyDiagram({superficial: true}, diagram =>\n                info.singular ? diagram : setDiagramLineProps(diagram, lineId, {\n                    angle: info.angle,\n                    arcHeight: 0.0,\n                })\n            ))\n            e.stopPropagation()\n        }\n    }\n    return vnode(\n        \"svg:g\",\n        {\n            // prevent hover effects from sticking when nodes change\n            [VNODE_KEY]: lineId,\n            \"class\": \"line \"\n                   + (line.superline == \"0\" ? \"zero \" : \"\")\n                   + (superline.summed ? \"summed \" : \"\")\n                   + (superline.phase % 2 ? \"one-j \" : \"\")\n                   + (mod(superline.phase, 4) >= 2 ? \"two-j \" : \"\")\n                   + ((editor.trackStart.type == \"line\" &&\n                       editor.trackStart.lineId == lineId)\n                   || (editor.trackStop.type == \"line\" &&\n                       editor.trackStop.lineId == lineId)\n                    ? (editor.trackType + \" \") : \"\"),\n            onmouseenter: function(e) {\n                update(setHover({\n                    type: \"line\",\n                    lineId: lineId,\n                }))\n            },\n            onmouseleave: function(e) {\n                update(setHover({type: null}))\n            },\n        },\n        vnode(\"svg:title\", {}, `j[${line.superline}] m[${lineId}]`),\n        // this path (1) increases hit area (2) helps delineate crossing lines\n        vnode(\"svg:path\", {\n            \"class\": \"bg\",\n            d: d,\n            onmousedown: onmousedown,\n        }),\n        vnode(\"svg:path\", {\n            \"class\": \"fg\",\n            d: d,\n            onmousedown: onmousedown,\n        }),\n        vnode(\"svg:path\", {\n            \"class\": \"pith\",\n            d: d,\n            onmousedown: onmousedown,\n        }),\n        vnode(\"svg:path\", {\n            \"class\": \"hit\",\n            d: d,\n            onmousedown: onmousedown,\n        }),\n        vnode(\"svg:text\", {\n            \"class\": \"label\",\n            x: textX,\n            y: textY,\n            onmousedown: function(e) {\n                if (e.buttons == 1) {\n                    update(startDrag(textX, textY, {\n                        superficial: true,\n                    }, (diagram, x, y, snap) => {\n                        const where = findPosOnLine(info, x, y)\n                        // prevent text from getting stuck under nodes\n                        return setDiagramLineProps(diagram, lineId, {\n                            textPos: clamp(0.1, 0.9,\n                                           round(snap && 0.1, where.pos)),\n                            textOffset: round(snap && 10.0, where.offset),\n                        })\n                    }))\n                    e.stopPropagation()\n                } else if (e.buttons == 2 && e.ctrlKey == true) {\n                    update(modifyDiagram({superficial: true}, diagram =>\n                        setDiagramLineProps(diagram, lineId, {\n                            textPos: 0.5,\n                            textOffset: 0.0,\n                        })\n                    ))\n                    e.stopPropagation()\n                }\n            },\n        }, line.superline),\n        ...renderArrow(update, diagram, lineId, ambient),\n    )\n}\n\nfunction renderNode(update, editor, nodeIndex, frozen) {\n    const diagram = editor.snapshot.diagram\n    const node = diagram.nodes[nodeIndex]\n    let gChildren = [vnode(\"svg:title\", {},\n                           node.type == \"w3j\"\n                         ? `{${node.lines.join(\" \")}} #${nodeIndex}`\n                         : node.type == \"terminal\"\n                         ? `m[${node.variable}] #${nodeIndex}`\n                         : node.type)]\n\n    if (node.type == \"w3j\") {\n        const circularArrowSize = 30\n        const orientation = w3jOrientation(diagram, nodeIndex) > 0\n                          ? \"flipped \" : \"\"\n        gChildren.push(vnode(\"svg:circle\", {\n            \"class\": \"bg \" + orientation,\n            r: 20,\n        }))\n        gChildren.push(vnode(\"svg:circle\", {\n            \"class\": \"fg \" + orientation,\n            r: 18,\n        }))\n        gChildren.push(vnode(\"svg:circle\", {\n            \"class\": \"hit \" + orientation,\n            r: 25,\n        }))\n        gChildren.push(vnode(\"svg:use\", {\n            \"class\": \"arrow \" + orientation,\n            href: \"#clockwise\",\n            x: -circularArrowSize / 2,\n            y: -circularArrowSize / 2,\n            width: circularArrowSize,\n            height: circularArrowSize,\n        }))\n\n    } else if (node.type == \"terminal\") {\n        const frozenClass = frozen ? \"frozen \" : \"\"\n        gChildren.push(vnode(\"svg:circle\", {\n            \"class\": \"fg \" + frozenClass,\n            r: 8,\n        }))\n        gChildren.push(vnode(\"svg:circle\", {\n            \"class\": \"hit\",\n            r: 15,\n        }))\n\n    } else {\n        gChildren.push(vnode(\"svg:circle\", {\n            \"class\": \"fg\",\n            r: 20,\n        }))\n        gChildren.push(vnode(\"svg:circle\", {\n            \"class\": \"hit\",\n            r: 25,\n        }))\n        gChildren.push(vnode(\"svg:text\", {\n            \"class\": \"label\",\n        }))\n    }\n\n    return vnode(\"svg:g\", {\n        // prevent hover effects from sticking when nodes change\n        [VNODE_KEY]: objectId(node),\n        \"class\": \"node \"\n               + node.type + \" \"\n               + ((editor.trackStart.type == \"node\" &&\n                   editor.trackStart.nodeIndex == nodeIndex)\n               || (editor.trackStop.type == \"node\" &&\n                   editor.trackStop.nodeIndex == nodeIndex)\n                ? (editor.trackType + \" \") : \"\"),\n        transform: `translate(${node.x}, ${node.y})`,\n        onmouseenter: function(e) {\n            update(setHover({\n                type: \"node\",\n                nodeIndex: nodeIndex,\n            }))\n        },\n        onmouseleave: function(e) {\n            update(setHover({type: null}))\n        },\n        onmousedown: function(e) {\n            if (e.buttons == 1) {\n                update(startDrag(node.x, node.y, {\n                    // moving terminals and/or custom nodes\n                    // changes the semantics of the diagram\n                    superficial: node.type == \"w3j\",\n                }, (diagram, x, y, snap) =>\n                    setDiagramNodeProps(diagram, nodeIndex, {\n                        x: round(snap && 20.0, x),\n                        y: round(snap && 20.0, y),\n                    })\n                ))\n                e.stopPropagation()\n            } else if (e.buttons == 4) {\n                if (node.type == \"terminal\") {\n                    return\n                }\n                if (e.shiftKey) { // do it twice!\n                    update(modifyDiagram({equivalent: true}, diagram =>\n                        flipW3jRule(\n                            flipW3jRule(diagram, nodeIndex),\n                            nodeIndex)))\n                } else {\n                    update(modifyDiagram({equivalent: true}, diagram =>\n                        flipW3jRule(diagram, nodeIndex)))\n                }\n                e.stopPropagation()\n            } else if (e.buttons == 2) {\n                if (node.type == \"terminal\") {\n                    return\n                }\n                update(modifyDiagram({equivalent: true}, diagram =>\n                    threeArrowRule(diagram, nodeIndex)))\n                e.stopPropagation()\n            }\n        },\n    }, ...gChildren)\n}\n\nfunction cmpSuperlineId(x, y) {\n    if (x == \"0\") {\n        if (y == \"0\") {\n            return 0\n        }\n        return -1\n    }\n    if (y == \"0\") {\n        return +1\n    }\n    let d = x.length - y.length\n    if (d == 0) {\n        d = Number(x > y) - Number(x < y)\n    }\n    return d\n}\n\nconst GREEK_LATEX = {\n    \"\": \"A\",\n    \"\": \"\\\\alpha\",\n    \"\": \"B\",\n    \"\": \"\\\\beta\",\n    \"\": \"\\\\Gamma\",\n    \"\": \"\\\\gamma\",\n    \"\": \"\\\\Delta\",\n    \"\": \"\\\\delta\",\n    \"\": \"E\",\n    \"\": \"\\\\varepsilon\",\n    \"\": \"\\\\epsilon\",\n    \"\": \"Z\",\n    \"\": \"\\\\zeta\",\n    \"\": \"H\",\n    \"\": \"\\\\eta\",\n    \"\": \"\\\\Theta\",\n    \"\": \"\\\\theta\",\n    \"\": \"\\\\vartheta\",\n    \"\": \"I\",\n    \"\": \"\\\\iota\",\n    \"\": \"K\",\n    \"\": \"\\\\kappa\",\n    \"\": \"\\\\varkappa\",\n    \"\": \"\\\\Lambda\",\n    \"\": \"\\\\lambda\",\n    \"\": \"M\",\n    \"\": \"\\\\mu\",\n    \"\": \"N\",\n    \"\": \"\\\\nu\",\n    \"\": \"\\\\Xi\",\n    \"\": \"\\\\xi\",\n    \"\": \"O\",\n    \"\": \"o\",\n    \"\": \"\\\\Pi\",\n    \"\": \"\\\\pi\",\n    \"\": \"\\\\varpi\",\n    \"\": \"P\",\n    \"\": \"\\\\rho\",\n    \"\": \"\\\\varrho\",\n    \"\": \"\\\\Sigma\",\n    \"\": \"\\\\sigma\",\n    \"\": \"\\\\varsigma\",\n    \"\": \"T\",\n    \"\": \"\\\\tau\",\n    \"\": \"Y\",\n    \"\": \"\\\\Upsilon\",\n    \"\": \"\\\\upsilon\",\n    \"\": \"\\\\Phi\",\n    \"\": \"\\\\varphi\",\n    \"\": \"\\\\phi\",\n    \"\": \"X\",\n    \"\": \"\\\\chi\",\n    \"\": \"\\\\Psi\",\n    \"\": \"\\\\psi\",\n    \"\": \"\\\\Omega\",\n    \"\": \"\\\\omega\",\n}\nconst GREEK_LETTERS = \"\"\nconst IDENT_CHAR_REGEX = `['_.,\\\\w${GREEK_LETTERS}]`\n\nfunction isValidSuperlineId(superlineId) {\n    // prevent exotic characters from messing up the delta input syntax\n    return !!new RegExp(`^${IDENT_CHAR_REGEX}+$`).exec(superlineId)\n}\n\nfunction isLoopLine(line) {\n    return line.node(0).type == \"w3j\"\n        && line.node(0).index == line.node(1).index\n        && (line.superlineId == \"0\" || line.direction % 2)\n}\n\nfunction editSummed(diagram, superlineId) {\n    if (superlineId == \"0\") {\n        return \"\"\n    }\n    if (isSuperlineExposed(diagram, superlineId)) {\n        return \"\"\n    }\n    const superline = diagram.superlines[superlineId]\n    // special case: eliminate summations through deltas\n    if (superline.summed) {\n        const deltas = diagram.deltas\n        const found = findDeltaEntry(deltas, superlineId)\n        if (found) {\n            const deltas = diagram.deltas\n            const newSuperlineId = deltas[found[0]][(found[1] + 1) %\n                deltas[found[0]].length]\n            const summed = diagram.superlines[superlineId].summed\n                        && diagram.superlines[newSuperlineId].summed\n            diagram = new Diagram(diagram).renameSuperlines({\n                    [superlineId]: newSuperlineId,\n                }).rawDiagram\n            diagram = Object.assign({}, diagram)\n            diagram.superlines = Object.assign({}, diagram.superlines)\n            diagram.superlines[newSuperlineId] = Object.assign(\n                {}, diagram.superlines[newSuperlineId], {summed: summed})\n            return {\n                equivalent: true,\n                diagram: diagram,\n            }\n        }\n    }\n    diagram = deepClone(diagram)\n    diagram.superlines[superlineId].summed =\n        !superline.summed\n    return {\n        equivalent: false,\n        diagram: diagram\n    }\n}\n\nfunction introSum(diagram, superlineId) {\n    // introduce sum[j_fresh] delta[j_fresh j]\n    const freshSuperlineId = availSuperlineLabels(diagram).next().value\n    diagram = deepClone(diagram)\n    diagram.superlines[freshSuperlineId] = Object.assign({}, EMPTY_SUPERLINE, {\n        summed: true,\n    })\n    diagram.deltas = mergeDeltas(diagram.deltas, [\n        [superlineId, freshSuperlineId],\n    ])\n    return {\n        equivalent: true,\n        diagram: diagram,\n    }\n}\n\nfunction renderJTableau(update, superlines, editor) {\n    const frozen = editor.snapshot.frozen\n    const focus = editor.focus\n    return Array.from(new Set(\n        Object.keys(superlines).concat(\"0\")\n    )).sort(cmpSuperlineId).map(superlineId => {\n        const focusedName = focus.type == \"tableauJName\"\n                         && focus.superlineId == superlineId\n        const superline = superlineId == \"0\"\n                        ? EMPTY_SUPERLINE\n                        : superlines[superlineId]\n        const twoJ = vnode(\"span\", {\"class\": \"two-j\"}, \"\\u2022\\u2022\")\n        let phase\n        switch (mod(superline.phase, 4)) {\n            case 0:\n                phase = [\"\\xa0\\xa0\\xa0\"]\n                break\n            case 1:\n                phase = [\"\\u2022\\xa0\\xa0\"]\n                break\n            case 2:\n                phase = [twoJ, \"\\xa0\"]\n                break\n            case 3:\n                phase = [twoJ, \"\\u2022\"]\n                break\n        }\n        let weight = superline.weight\n                   ? (superline.weight > 0\n                    ? \"+\"\n                    : superline.weight < 0\n                    ? \"\\u2212\"\n                    : \"\")\n                   + Math.abs(superline.weight)\n                   : \"\"\n        return vnode(\n            \"tr\", {},\n            vnode(\"td\", {\n                \"class\": \"summed\",\n                onmousedown: function(e) {\n                    if (e.buttons == 1) {\n                        update(modifyDiagramWith(diagram =>\n                            editSummed(diagram, superlineId)))\n                        e.stopPropagation()\n                    } else if (e.buttons == 4) {\n                        update(modifyDiagramWith(diagram =>\n                            introSum(diagram, superlineId)))\n                        e.stopPropagation()\n                    }\n                },\n            }, superline.summed ? \"\\u2211\" : \"\"),\n            vnode(\"td\", {\n                \"class\": \"name\",\n                contenteditable: superlineId != \"0\",\n                spellcheck: \"false\",\n                [VNODE_SUSPEND_CHILDREN]: focusedName,\n                onfocus: function(e) {\n                    update(setFocus({\n                        type: \"tableauJName\",\n                        superlineId: superlineId,\n                    }))\n                },\n                onblur: function(e) {\n                    let newSuperlineId = this.textContent\n                    newSuperlineId = newSuperlineId.trim()\n                    if (!newSuperlineId) {\n                        newSuperlineId = \"0\"\n                    }\n                    update(editor => {\n                        modifyDiagramWith(diagram => {\n                            diagram = new Diagram(diagram)\n                            if (superlineId == newSuperlineId\n                                || !isValidSuperlineId(newSuperlineId)) {\n                                return \"\"\n                            }\n                            const superline = diagram.superline(superlineId)\n                            const deltas = diagram.rawDiagram.deltas\n                            // special case for loop lines, which can\n                            // change into anything\n                            if (frozen\n                                && superline.phase == 0\n                                && !superline.summed\n                                && !findDeltaEntry(deltas, superlineId)) {\n                                let numLoops = 0\n                                for (const line of diagram.lines()) {\n                                    if (line.superlineId == superlineId) {\n                                        if (isLoopLine(line)) {\n                                            numLoops += 1\n                                        } else {\n                                            numLoops = null\n                                            break\n                                        }\n                                    }\n                                }\n                                if (numLoops != null\n                                    && superline.weight == -numLoops) {\n                                    return {\n                                        equivalent: true,\n                                        diagram: diagram.renameSuperlines({\n                                            [superlineId]: newSuperlineId,\n                                        }).rawDiagram,\n                                    }\n                                }\n                            }\n                            return {\n                                equivalent: superline.summed\n                                         && !diagram.superline(newSuperlineId),\n                                diagram: diagram.renameSuperlines({\n                                    [superlineId]: newSuperlineId,\n                                }).rawDiagram,\n                            }\n                        })(editor)\n                        clearFocus(editor)\n                    })\n                },\n            }, superlineId == \"0\"\n                ? vnode(\"span\", {\"class\": \"zero\"}, \"0\")\n                : superlineId),\n            vnode(\"td\", Object.assign({\n                \"class\": \"phase \"\n                       + (editor.drag.type == \"phase\"\n                       && editor.drag.superlineId == superlineId ? \"drag \" : \"\")\n                       + (editor.drop.type == \"phase\"\n                       && editor.drop.superlineId == superlineId ? \"drop \" : \"\"),\n                oncontextmenu: function(e) { e.preventDefault() },\n                onmousedown: function(e) {\n                    if (e.buttons == 2) {\n                        update(modifyDiagram({}, diagram => {\n                            return Object.assign({}, diagram, {\n                                superlines: mergeSuperlineLists(\n                                    diagram.superlines,\n                                    {[superlineId]: {phase: +1}}),\n                            })\n                        }))\n                        e.stopPropagation()\n                        e.preventDefault()\n                    } else if (e.buttons == 4) {\n                        update(modifyDiagram({}, diagram => {\n                            return Object.assign({}, diagram, {\n                                superlines: mergeSuperlineLists(\n                                    diagram.superlines,\n                                    {[superlineId]: {phase: -1}}),\n                            })\n                        }))\n                        e.stopPropagation()\n                        e.preventDefault()\n                    }\n                },\n            }, handleDrag(update, (editor, e) => ({\n                type: \"phase\",\n                superlineId: superlineId,\n            })), handleDrop(update, (editor, e) => {\n                if (editor.drag.type != \"phase\"\n                    || editor.drag.superlineId == superlineId\n                    || (editor.snapshot.frozen &&\n                        !containsDeltas(editor.snapshot.diagram.deltas,\n                                        [[editor.drag.superlineId,\n                                          superlineId]]))) {\n                    return null\n                }\n                return {\n                    type: \"phase\",\n                    superlineId: superlineId,\n                }\n            }, (editor, e) => {\n                modifyDiagramWith(diagram => {\n                    const equivalent = containsDeltas(diagram.deltas,\n                                                      [[editor.drag.superlineId,\n                                                        superlineId]])\n                    diagram = Object.assign({}, diagram, {\n                        superlines: mergeSuperlineLists(\n                            diagram.superlines,\n                            {\n                                [editor.drag.superlineId]: {phase: -1},\n                                [superlineId]: {phase: +1},\n                            }\n                        )\n                    })\n                    return {equivalent: equivalent, diagram: diagram}\n                })(editor)\n            })), ...phase),\n            vnode(\"td\", Object.assign({\n                \"class\": \"weight \"\n                       + (editor.drag.type == \"weight\"\n                       && editor.drag.superlineId == superlineId ? \"drag \" : \"\")\n                       + (editor.drop.type == \"weight\"\n                       && editor.drop.superlineId == superlineId ? \"drop \" : \"\"),\n                oncontextmenu: function(e) { e.preventDefault() },\n                onmousedown: function(e) {\n                    if (e.buttons == 2) {\n                        update(modifyDiagram({}, diagram => {\n                            return Object.assign({}, diagram, {\n                                superlines: mergeSuperlineLists(\n                                    diagram.superlines,\n                                    {[superlineId]: {weight: +1}}),\n                            })\n                        }))\n                        e.stopPropagation()\n                        e.preventDefault()\n                    } else if (e.buttons == 4) {\n                        update(modifyDiagram({}, diagram => {\n                            return Object.assign({}, diagram, {\n                                superlines: mergeSuperlineLists(\n                                    diagram.superlines,\n                                    {[superlineId]: {weight: -1}}),\n                            })\n                        }))\n                        e.stopPropagation()\n                        e.preventDefault()\n                    }\n                },\n            }, handleDrag(update, (editor, e) => ({\n                type: \"weight\",\n                superlineId: superlineId,\n            })), handleDrop(update, (editor, e) => {\n                if (editor.drag.type != \"weight\"\n                    || editor.drag.superlineId == superlineId\n                    || (editor.snapshot.frozen &&\n                        !containsDeltas(editor.snapshot.diagram.deltas,\n                                        [[editor.drag.superlineId,\n                                          superlineId]]))) {\n                    return null\n                }\n                return {\n                    type: \"weight\",\n                    superlineId: superlineId,\n                }\n            }, (editor, e) => {\n                modifyDiagramWith(diagram => {\n                    const equivalent = containsDeltas(diagram.deltas,\n                                                      [[editor.drag.superlineId,\n                                                        superlineId]])\n                    diagram = Object.assign({}, diagram, {\n                        superlines: mergeSuperlineLists(\n                            diagram.superlines,\n                            {\n                                [editor.drag.superlineId]: {weight: -1},\n                                [superlineId]: {weight: +1},\n                            }\n                        )\n                    })\n                    return {equivalent: equivalent, diagram: diagram}\n                })(editor)\n            })), weight),\n        )\n    })\n}\n\nfunction editDelta(deltaIndex, input) {\n    return diagram => {\n        const oldDeltas = diagram.deltas\n        let invalid = null\n        diagram = Object.assign({}, diagram)\n        diagram.deltas = oldDeltas.slice()\n        diagram.deltas.splice(\n            deltaIndex, 1,\n            ...input.split(/[;\\n]/).map(delta =>\n                delta.split(\"=\").map(s => {\n                    s = s.trim()\n                    if (s && !isValidSuperlineId(s)) {\n                        invalid = s\n                    }\n                    return s\n                }).filter(identity)))\n        if (invalid != null) {\n            return \"invalid label: \" + invalid\n        }\n        diagram.deltas = mergeDeltas(diagram.deltas)\n        diagram.superlines = Object.assign({}, diagram.superlines)\n        for (const delta of diagram.deltas) {\n            for (const j of delta) {\n                if (!diagram.superlines[j]) {\n                    diagram.superlines[j] = EMPTY_SUPERLINE\n                }\n            }\n        }\n        const inferredDeltas = inferDeltas(diagram)\n        const oldInferredDeltas = mergeDeltas(inferredDeltas, oldDeltas)\n        const newInferredDeltas = mergeDeltas(inferredDeltas, diagram.deltas)\n        let equivalent = equalDeltas(oldInferredDeltas, newInferredDeltas)\n        diagram = new Diagram(diagram)\n        if (!equivalent) {\n            // inferDeltas doesn't infer zero lines due to bridges between\n            // orientable subdiagrams for efficiency reasons; instead we look\n            // for the remaining j's in the zero delta and try to infer those\n            const oldZeroDelta = new Set(relatedDelta(oldInferredDeltas, \"0\"))\n            const newZeroDelta = new Set(relatedDelta(newInferredDeltas, \"0\"))\n            let diff = new Set([...oldZeroDelta, ...newZeroDelta]\n                .filter(x => !oldZeroDelta.has(x) || !newZeroDelta.has(x)))\n            const diffDelta = [\"0\", ...diff]\n            if (equalDeltas(mergeDeltas([diffDelta], oldInferredDeltas),\n                            mergeDeltas([diffDelta], newInferredDeltas))) {\n                for (const line of diagram.lines()) {\n                    if (diff.has(line.superlineId) && !line.testCuttability()) {\n                        diff.delete(line.superlineId)\n                    }\n                }\n                equivalent = diff.size == 0\n            }\n        }\n        return {\n            equivalent,\n            diagram: diagram.removeUnusedSuperlines().rawDiagram,\n        }\n    }\n}\n\nfunction renderDeltaJ(j) {\n    return j == \"0\"\n         ? vnode(\"span\", {\"class\": \"zero\"}, \"0\")\n         : String(j)\n}\n\nfunction renderDeltaTableau(update, deltas, focus, frozen) {\n    return vnode(\"ul\", {}, ...deltas.concat([null]).map((delta, deltaIndex) => {\n        const focused = focus.type == \"delta\"\n                     && focus.deltaIndex == deltaIndex\n        const children = delta == null\n                       ? [vnode(\"i\", {}, \"(create \\u03b4)\")]\n                       : arrayIntercalate(\" = \", Array.from(delta)\n                                                      .map(renderDeltaJ))\n        return vnode(\"li\", {\n            \"class\": delta == null ? \"tip \" : \"\",\n            contenteditable: \"true\",\n            spellcheck: \"false\",\n            [VNODE_SUSPEND_CHILDREN]: focused,\n            onmousedown: function(e) {\n                if (e.buttons == 4) {\n                    update(modifyDiagramWith(editDelta(deltaIndex, \"\")))\n                    e.preventDefault()\n                }\n            },\n            onfocus: function(e) {\n                if (delta == null) {\n                    this.textContent = \"\"\n                    // clearing the text somehow deselects the text\n                    // so this is a workaround\n                    let range = document.createRange()\n                    range.selectNodeContents(this)\n                    let sel = window.getSelection()\n                    sel.removeAllRanges()\n                    sel.addRange(range)\n                }\n                update(setFocus({type: \"delta\", deltaIndex: deltaIndex}))\n            },\n            onblur: function(e) {\n                const input = this.textContent\n                update(editor => {\n                    modifyDiagramWith(editDelta(deltaIndex, input))(editor)\n                    clearFocus(editor)\n                })\n            },\n        }, ...children)\n    }))\n}\n\nfunction renderVariable(type, name) {\n    if (type == \"j\" && name == \"0\") {\n        return \"0\"\n    }\n    name = name.replace(\"\", \"'\")\n               .replace(\"_\", \"\\\\_\")\n               .replace(new RegExp(`[${GREEK_LETTERS}]`),\n                        x => GREEK_LATEX[x] + \" \")\n    return `${type}_{${name}}`\n}\n\nfunction renderEquationLine(diagram, nodeIndex, lineIndex, summedVars) {\n    const lineId = diagram.nodes[nodeIndex].lines[lineIndex]\n    const line = diagram.lines[lineId]\n    const otherIndex = otherNodeIndex(diagram.nodes, nodeIndex, lineIndex)\n    const otherNode = diagram.nodes[otherIndex]\n    // avoid redundant summation over an m-delta\n    const mName = otherNode.type == \"terminal\"\n                ? otherNode.variable\n                : lineId\n    const mNaked = renderVariable(\"m\", mName)\n    const jm = {\n        j: renderVariable(\"j\", diagram.lines[lineId].superline),\n        m: otherIndex < nodeIndex && line.direction != 0\n         ? `-${mNaked}`\n         : mNaked,\n    }\n    if (line.superline.summed) {\n        summedVars.js[jm.j] = true\n    }\n    if (otherNode.type != \"terminal\") {\n        summedVars.ms[mNaked] = true\n    }\n    return jm\n}\n\nfunction renderEquation(diagram, container) {\n    const nodes = diagram.nodes\n    let s = \"\"\n    let summedVars = {js: {}, ms: {}}\n    let phases = []\n    let mDeltas = []\n    nodes.forEach(function(node, nodeIndex) {\n        if (node.type == \"terminal\") {\n            const otherIndex = otherNodeIndex(nodes, nodeIndex, 0)\n            if (otherIndex > nodeIndex) {\n                return\n            }\n            const var1 = nodes[otherIndex].variable\n            const var2 = node.variable\n            if (var1 == var2) {\n                return\n            }\n            const m1 = renderVariable(\"m\", var1)\n            const m2 = renderVariable(\"m\", var2)\n            switch (diagram.lines[node.lines[0]].direction) {\n                case 0:\n                    mDeltas.push(`\\\\delta_{${m1}, ${m2}}`)\n                    break\n                case -1:\n                    mDeltas.push(`\\\\delta_{${m1}, -${m2}}`)\n                    break\n                case 1:\n                    mDeltas.push(`\\\\delta_{-${m1}, ${m2}}`)\n                    break\n                default:\n                    throw new Error(`unnormalized direction: ${direction}`)\n            }\n        } else if (node.type == \"w3j\") {\n            s += \"\\\\begin{pmatrix}\"\n            let jRow = \"\"\n            let mRow = \"\"\n            node.lines.forEach(function(lineId, lineIndex) {\n                if (lineIndex > 0) {\n                    jRow += \" & \"\n                    mRow += \" & \"\n                }\n                const jm = renderEquationLine(diagram, nodeIndex,\n                                              lineIndex, summedVars)\n                jRow += jm.j\n                mRow += jm.m\n            })\n            s += jRow + \" \\\\\\\\\"\n            s += mRow + \" \\\\\\\\\"\n            s += \"\\\\end{pmatrix}\"\n        } else {\n            s += \"\\\\mathtt{${node.type}}_{\"\n            node.lines.forEach(function(lineId, lineIndex) {\n                if (lineIndex > 0) {\n                    s += \" \"\n                }\n                const jm = renderEquationLine(diagram, nodeIndex,\n                                              lineId, summedVars)\n                s += jm[0] + \" \" + jm[1]\n            })\n            s += \"}\"\n        }\n    })\n    let weights = \"\"\n    Object.keys(diagram.superlines).forEach(function(superlineId) {\n        const superline = diagram.superlines[superlineId]\n        const jVar = renderVariable(\"j\", superlineId)\n        switch (mod(superline.phase, 4)) {\n            case 0:\n                break\n            case 1:\n                phases.push(`+ ${jVar}`)\n                break\n            case 2:\n                phases.push(`+ 2 ${jVar}`)\n                break\n            case 3:\n                phases.push(`- ${jVar}`)\n                break\n        }\n        if (superline.weight == 0) {\n        } else if (superline.weight == 2) {\n            weights += ` (2 ${jVar} + 1)`\n        } else if (superline.weight % 2 == 0) {\n            weights += ` (2 ${jVar} + 1)^{${superline.weight / 2}}`\n        } else {\n            weights += ` (2 ${jVar} + 1)^{${superline.weight} / 2}`\n        }\n    })\n    Object.keys(diagram.lines).forEach(function(lineId) {\n        const line = diagram.lines[lineId]\n        let name\n        switch (line.direction) {\n            case 0:\n                return\n            case -1:\n                const node2 = nodes[endNodeIndices(nodes, lineId)[1]]\n                if (node2.type == \"terminal\") {\n                    name = node2.variable\n                } else {\n                    name = lineId\n                }\n                break\n            case 1:\n                const node1 = nodes[endNodeIndices(nodes, lineId)[0]]\n                if (node1.type == \"terminal\") {\n                    name = node1.variable\n                } else {\n                    name = lineId\n                }\n                break\n            default:\n                throw new Error(`unnormalized direction: ${direction}`)\n        }\n        const j = renderVariable(\"j\", diagram.lines[lineId].superline)\n        const m = renderVariable(\"m\", name)\n        phases.push(`+ ${j} ${line.direction < 0 ? \"+\" : \"-\"} ${m}`)\n    })\n    let summedVarsStr =\n        Object.keys(summedVars.js)\n              .concat(Object.keys(summedVars.ms)).join(\", \")\n    if (summedVarsStr) {\n        summedVarsStr = `\\\\sum_{${summedVarsStr}}`\n    }\n    let phasesStr = phases.join(\" \")\n    if (phasesStr) {\n        if (phasesStr.startsWith(\"+ \")) {\n            phasesStr = phasesStr.substr(2)\n        }\n        phasesStr = `(-1)^{${phasesStr}}`\n    }\n    const mDeltasStr = mDeltas.join(\" \")\n    const jDeltas = diagram.deltas.map(js => {\n        if (js.length < 2) {\n            return \"\"\n        }\n        const j0 = renderVariable(\"j\", js[0])\n        return js.slice(1)\n                 .map(j => `\\\\delta_{${j0} ${renderVariable(\"j\", j)}}`)\n                 .join(\" \")\n    }).join(\" \")\n    container.textContent = `\\\\[${summedVarsStr} ${jDeltas} ${mDeltasStr} `\n                          + `${weights} ${phasesStr} ${s}\\\\]`\n    MathJax.Hub.Queue([\"Typeset\", MathJax.Hub])\n}\n\nfunction renderTrack(trackType, start, stop) {\n    return [\n        vnode(\"svg:circle\", {\n            \"class\": trackType,\n            cx: start[0],\n            cy: start[1],\n            r: 8,\n        }),\n        vnode(\"svg:path\", {\n            \"class\": trackType,\n            d: `M ${start[0]} ${start[1]} `\n             + `L ${stop[0]} ${stop[1]} `,\n        }),\n        vnode(\"svg:circle\", {\n            \"class\": trackType,\n            cx: stop[0],\n            cy: stop[1],\n            r: 8,\n        }),\n    ]\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// State management\n//\n// The \"update\" function is responsible for making changes to the model (and\n// updating the DOM as needed).  It has type (&mut Editor -> ()) -> ().\n// In the future, \"update\" may ask for a Promise instead.\n\nconst ALT = 0x1\nconst CTRL = 0x2\nconst SHIFT = 0x4\n\nconst EMPTY_SNAPSHOT = {\n    diagram: EMPTY_DIAGRAM,\n    frozen: false,\n    showAmbient: true,\n}\n\nfunction newEditor() {\n    return {\n        snapshot: EMPTY_SNAPSHOT,\n        savedSnapshot: EMPTY_SNAPSHOT,\n        savedHash: \"\",\n        staleEquation: true,\n\n        // controls\n        error: \"\",\n        notice: \"An editor for angular momentum diagrams\",\n        hover: {type: null},\n        focus: {type: null},\n        drag: {type: null},\n        drop: {type: null},\n        mouseX: null,\n        mouseY: null,\n        trackType: null,\n        trackStart: {type: null, xy: null},\n        trackStop: {type: null, xy: null},\n    }\n}\n\nfunction saveEditor(editor) {\n    editor.savedSnapshot = editor.snapshot\n    editor.savedHash = \"#\" + encodeURIComponent(JSON.stringify(editor.snapshot))\n    window.location.hash = editor.savedHash\n}\n\nfunction loadEditor(editor) {\n    const hash = window.location.hash\n    // prevent hashchange listener from observing our own changes\n    if (hash.length < 3) {\n        Object.assign(editor, newEditor())\n    } else if (editor.savedHash != hash) {\n        editor.snapshot = JSON.parse(decodeURIComponent(hash.substr(1)))\n        editor.staleEquation = true\n        editor.savedSnapshot = editor.snapshot\n        editor.savedHash = hash\n    }\n}\n\nfunction toSvgCoords(p) {\n    if (!p) {\n        return p\n    }\n    const rect = document.getElementById(\"diagram\").getBoundingClientRect()\n    return [p[0] - rect.left, p[1] - rect.top]\n}\n\nfunction renderEditor(update, editor) {\n    const diagram = editor.snapshot.diagram\n    let ambient = null\n    if (editor.snapshot.showAmbient) {\n        // first try to match external lines (not needed, but looks nicer)\n        ambient = getAmbientDirections(new Diagram(diagram), false)\n        if (!ambient.orientable) {\n            // if it's not orientable, it might be because the external-line\n            // constraints aren't satisfiable\n            ambient = getAmbientDirections(new Diagram(diagram), true)\n        }\n    }\n    return [\n        {\n            element: window,\n            attributes: {\n                onhashchange: _ => update(loadEditor),\n                onkeydown: e => update(keyDown.bind(null, e)),\n                onmousemove: e => update(mouseMove(e)),\n                onmouseup: e => update(mouseUp(e)),\n            },\n        },\n        {\n            element: document.getElementsByTagName(\"body\")[0],\n            attributes: {\n                \"class\": editor.snapshot.frozen ? \"frozen\" : \"\",\n            },\n        },\n        {\n            element: document.getElementById(\"notice\"),\n            attributes: {\n                \"class\": editor.error ? \"warning\" : \"\",\n            },\n            children: [editor.error || editor.notice],\n        },\n        {\n            element: document.getElementById(\"freeze\"),\n            attributes: {\n                \"class\": editor.snapshot.frozen ? \"active\" : \"\",\n            },\n        },\n        {\n            element: document.getElementById(\"ambient\"),\n            attributes: {\n                \"class\": editor.snapshot.showAmbient ? \"active\" : \"\",\n            },\n        },\n        {\n            element: document.getElementById(\"diagram\"),\n            attributes: {\n                oncontextmenu: function(e) { e.preventDefault() },\n                onmousedown: e => {\n                    if (e.buttons == 4) {\n                        update(startTrack(e, \"track1\"))\n                        e.stopPropagation()\n                    } else if (e.buttons == 2) {\n                        update(startTrack(e, \"track2\"))\n                        e.stopPropagation()\n                    }\n                },\n            },\n        },\n        {\n            element: document.getElementById(\"diagram-lines\"),\n            children: Object.keys(diagram.lines).map(lineId =>\n                renderLine(update, editor, lineId, ambient)),\n        },\n        {\n            element: document.getElementById(\"diagram-nodes\"),\n            children: diagram.nodes.map((_, nodeIndex) =>\n                renderNode(update, editor, nodeIndex, editor.snapshot.frozen)),\n        },\n        {\n            element: document.getElementById(\"diagram-track\"),\n            children: editor.trackStop.xy != null\n                    ? renderTrack(editor.trackType,\n                                  toSvgCoords(editor.trackStart.xy),\n                                  toSvgCoords(editor.trackStop.xy))\n                    : [],\n        },\n        {\n            element: document.getElementById(\"tableau-body\"),\n            children: renderJTableau(update, diagram.superlines, editor),\n        },\n        {\n            // Kronecker delta relations\n            element: document.getElementById(\"delta-tableau\"),\n            children: [renderDeltaTableau(update, diagram.deltas,\n                                          editor.focus, editor.snapshot.frozen)],\n        },\n        {\n            element: document.getElementById(\"equation-container\"),\n            attributes: {\n                \"class\": editor.staleEquation ? \"stale\" : \"\",\n            },\n        },\n        {\n            element: document.getElementById(\"equation\"),\n            attributes: {\n                onclick: e => update(freshenEquation(e.currentTarget)),\n            },\n        },\n    ]\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Actions\n\n/** Supported boolean flags:\n *   transient,\n *   equivalent,\n *   superficial (implies equivalent),\n *   toggleFreeze (implies superficial),\n *   toggleAmbient (implies superficial),\n *   clearHover.\n */\nfunction modifyDiagram(flags, diagramTransform) {\n    return modifyDiagramWith(diagram => Object.assign(flags, {\n        diagram: diagramTransform(diagram),\n    }))\n}\n\n/** Similar to modifyDiagram, but gets the flags from the result of the\n   transformation. */\nfunction modifyDiagramWith(transformer) {\n    return editor => {\n        const result = transformer(editor.snapshot.diagram, editor.snapshot.frozen)\n        if (result == null || (typeof result == \"object\"\n                            && result.diagram == null)) {\n            setError(editor, \"not yet implemented\")\n            return\n        }\n        if (typeof result == \"string\") { // error?\n            setError(editor, result)\n            return\n        }\n        const superficial = result.superficial\n                         || result.toggleFreeze\n                         || result.toggleAmbient\n        const equivalent = result.equivalent\n                        || superficial\n        const diagram = result.diagram\n        if (editor.snapshot.frozen && !equivalent) {\n            // nonequivalent changes are forbidden while frozen\n            return\n        }\n        if (typeof diagram == \"string\") { // error?\n            setError(editor, diagram)\n            return\n        }\n        editor.snapshot = Object.assign({}, editor.snapshot, {\n            diagram: diagram,\n            frozen: Boolean(result.toggleFreeze) != editor.snapshot.frozen,\n            showAmbient: Boolean(result.toggleAmbient) !=\n                editor.snapshot.showAmbient,\n        })\n        if (!result.transient) {\n            saveEditor(editor)\n        }\n        if (result.clearHover) {\n            setHover({type: null})(editor)\n        }\n        editor.staleEquation = !superficial || editor.staleEquation\n    }\n}\n\nfunction getModifiers(event) {\n    return event.altKey | (event.ctrlKey << 1) | (event.shiftKey << 2)\n}\n\nfunction freshenEquation(container) {\n    return editor => {\n        if (editor.staleEquation) {\n            editor.staleEquation = false\n            renderEquation(editor.snapshot.diagram, container)\n        }\n    }\n}\n\nlet errorTimeout = 0\nfunction setError(editor, msg) {\n    editor.error = msg\n    if (errorTimeout) {\n        window.clearTimeout(errorTimeout)\n    }\n    errorTimeout = window.setTimeout(function() {\n        const update = getUpdate(editor)\n        update(editor => editor.error = \"\")\n    }, 10000)\n}\n\nfunction setHover(entity) {\n    return editor => {\n        editor.hover = entity\n    }\n}\n\nfunction setFocus(entity) {\n    return editor => {\n        editor.focus = entity\n    }\n}\n\nconst clearFocus = setFocus({type: null})\n\nfunction handleDrag(update, canDrag) {\n    return {\n        [ENABLE_DRAG]: \"true\",\n        draggable: \"true\",\n        ondragstart: function(e) {\n            // Firefox needs this to work\n            e.dataTransfer.setData(\"text/plain\", null)\n            update(editor => {\n                const dragState = canDrag.call(this, editor, e)\n                if (dragState) {\n                    editor.drag = dragState\n                }\n            })\n        },\n        ondragend: function(e) {\n            update(editor => editor.drag = {type: null})\n        },\n    }\n}\n\nfunction handleDrop(update, canDrop, drop) {\n    function dragleave(e) {\n        update(editor => editor.drop = {type: null})\n    }\n    return {\n        ondragenter: function(e) {\n            update(editor => {\n                const dropState = canDrop.call(this, editor, e)\n                if (dropState) {\n                    editor.drop = dropState\n                }\n            })\n        },\n        ondragleave: dragleave,\n        ondragexit: dragleave,\n        ondragover: function(e) {\n            update(editor => {\n                const dropState = canDrop.call(this, editor, e)\n                if (dropState) {\n                    editor.drop = dropState\n                    e.preventDefault()\n                }\n            })\n        },\n        ondrop: function(e) {\n            update(editor => {\n                e.preventDefault()\n                drop.call(this, editor, e)\n                editor.drag = {type: null}\n                editor.drop = {type: null}\n            })\n        },\n    }\n}\n\nfunction startTrack(event, trackType) {\n    return editor => {\n        editor.trackType = trackType\n        editor.trackStart.xy = [event.clientX, event.clientY]\n        if (editor.hover.type == \"line\") {\n            editor.trackStart.type = \"line\"\n            editor.trackStart.lineId = editor.hover.lineId\n        }\n    }\n}\n\nfunction updateTrack(event) {\n    return editor => {\n        if (editor.trackStart.xy == null) {\n            return\n        }\n        editor.trackStop.xy = [event.clientX, event.clientY]\n        if (editor.trackStart.type != null) {\n            if (editor.hover.type == \"line\") {\n                editor.trackStop.type = \"line\"\n                editor.trackStop.lineId = editor.hover.lineId\n            } else if (editor.hover.type == \"node\") {\n                editor.trackStop.type = \"node\"\n                editor.trackStop.nodeIndex = editor.hover.nodeIndex\n            } else {\n                editor.trackStop.type = null\n            }\n        }\n    }\n}\n\nfunction isSuperlineOfLineUnique(diagram, lineId) {\n    const line0 = diagram.lines[lineId]\n    if (line0.superline == \"0\") {\n        return false\n    }\n    for (const [id, line] of Object.entries(diagram.lines)) {\n        if (id != lineId &&\n            line.superline == line0.superline) {\n            return false\n        }\n    }\n    return !findDeltaEntry(diagram.deltas, line0.superline)\n}\n\nfunction generateLoopSuperline(diagram, lineId) {\n    let line = new Diagram(diagram).line(lineId)\n    if (!isLoopLine(line)) {\n        return null\n    }\n    if (isSuperlineOfLineUnique(diagram, lineId)) {\n        return diagram\n    }\n    // a loop line can become whatever it wants\n    diagram = Object.assign({}, diagram)\n    const newLabel = availSuperlineLabels(diagram).next().value\n    const oldLabel = diagram.lines[lineId].superline\n    if (line.lineIndex(0) == 0\n        && line.lineIndex(1) == 2) {\n        line = line.reverse()\n    }\n    diagram.lines = Object.assign({}, diagram.lines, {\n        [lineId]: Object.assign({}, diagram.lines[lineId], {\n            direction: line.reversed ? -1 : 1,\n            superline: newLabel,\n        })\n    })\n    const phase = line.direction == -1 ? 2 : 0\n    diagram.superlines = mergeSuperlineLists(diagram.superlines, {\n        [oldLabel]: ensureSuperline({weight: +1, phase: phase}),\n        [newLabel]: ensureSuperline({weight: -1}),\n    })\n    return new Diagram(diagram).removeUnusedSuperlines().rawDiagram\n}\n\nfunction finishTrack(editor, event) {\n    if (editor.trackStop.xy == null\n        || (editor.trackStart.type == editor.trackStop.type\n         && editor.trackStart.nodeIndex == editor.trackStop.nodeIndex\n         && editor.trackStart.lineId == editor.trackStop.lineId\n         && vectorSquare(vectorSubtract(editor.trackStart.xy,\n                                        editor.trackStop.xy)) < 10)) {\n        if (editor.trackStart.type == \"line\") {\n            if (editor.trackType == \"track2\") {\n                if (editor.snapshot.frozen) {\n                    modifyDiagram({equivalent: true}, diagram =>\n                        flipW1jRule(diagram, editor.trackStart.lineId))(editor)\n                } else {\n                    modifyDiagram({}, diagram =>\n                        addW1j(diagram, editor.trackStart.lineId))(editor)\n                }\n                return\n            } else if (editor.trackType == \"track1\") {\n                const lineId = editor.trackStart.lineId\n                if (editor.snapshot.frozen) {\n                    modifyDiagram({equivalent: true}, diagram => {\n                        const result = generateLoopSuperline(diagram, lineId)\n                        if (result) {\n                            return result\n                        }\n                        const line = Object.assign({}, diagram.lines[lineId])\n                        const found = findDeltaEntry(diagram.deltas, line.superline)\n                        if (!found) {\n                            return diagram\n                        }\n                        const [j, i] = found\n                        line.superline = diagram.deltas[j][(i + 1) %\n                            diagram.deltas[j].length]\n                        return Object.assign({}, diagram, {\n                            lines: Object.assign({}, diagram.lines, {\n                                [lineId]: line,\n                            }),\n                        })\n                    })(editor)\n                } else {\n                    modifyDiagram({}, diagram => {\n                        // don't bother if it's already unique\n                        if (isSuperlineOfLineUnique(diagram, lineId)) {\n                            return diagram\n                        }\n                        diagram = Object.assign({}, diagram)\n                        const newLabel = availSuperlineLabels(diagram).next().value\n                        diagram.lines = Object.assign({}, diagram.lines, {\n                            [lineId]: Object.assign({}, diagram.lines[lineId], {\n                                superline: newLabel,\n                            })\n                        })\n                        diagram.superlines = mergeSuperlineLists(diagram.superlines, {\n                            [newLabel]: EMPTY_SUPERLINE\n                        })\n                        return diagram\n                    })(editor)\n                }\n                return\n            }\n        }\n    } else {\n        const stopXy = toSvgCoords(editor.trackStop.xy)\n        const startXy = toSvgCoords(editor.trackStart.xy)\n        if (editor.trackType == \"track1\") { // red - middle\n            if (editor.trackStop.type == \"line\") {\n                if (editor.trackStart.lineId == editor.trackStop.lineId) {\n                    modifyDiagram({equivalent: true, clearHover: true}, diagram =>\n                        w3jElimRule(diagram, editor.trackStart.lineId))(editor)\n                } else {\n                    modifyDiagram({equivalent: true, clearHover: true}, diagram =>\n                        glueRule(diagram, editor.trackStart.lineId,\n                                 editor.trackStop.lineId,\n                                 startXy, stopXy))(editor)\n                }\n            } else if (editor.trackStart.type == \"line\") {\n                modifyDiagram({equivalent: true, clearHover: true}, diagram =>\n                    loopIntroRule(diagram,\n                                  editor.trackStart.lineId,\n                                  startXy,\n                                  stopXy))(editor)\n            }\n        } else if (editor.trackType == \"track2\") { // green - right\n            if (editor.trackStop.type == \"line\") {\n                if (editor.trackStart.lineId == editor.trackStop.lineId) {\n                    modifyDiagram({equivalent: true, clearHover: true}, diagram =>\n                        cutRule(diagram, editor.trackStart.lineId,\n                                startXy, stopXy))(editor)\n                } else {\n                    modifyDiagram({\n                        equivalent: true,\n                        clearHover: true,\n                    }, diagram => {\n                        // prefer orientable diagrams\n                        let candidateDiagram\n                        for (const diagonal of [false, true]) {\n                            candidateDiagram =\n                                w3jIntroRule(diagram,\n                                             editor.trackStart.lineId,\n                                             editor.trackStop.lineId,\n                                             event.shiftKey,\n                                             diagonal)\n                            const ambient = getAmbientDirections(\n                                new Diagram(candidateDiagram), true)\n                            if (ambient.orientable) {\n                                return candidateDiagram\n                            }\n                        }\n                        return candidateDiagram\n                    })(editor)\n                }\n            } else if (editor.trackStop.type == \"node\") {\n                modifyDiagram({equivalent: true, clearHover: true}, diagram =>\n                    loopElimRule(diagram,\n                                 editor.trackStart.lineId,\n                                 editor.trackStop.nodeIndex))(editor)\n            }\n        }\n    }\n}\n\nfunction clearTrack(editor, event) {\n    finishTrack(editor, event)\n    editor.trackType = null\n    editor.trackStart = {type: null, xy: null}\n    editor.trackStop = {type: null, xy: null}\n}\n\nfunction mouseUp(event) {\n    return editor => {\n        if (editor.dragger) {\n            modifyDiagram(editor.draggerFlags, identity)(editor)\n            editor.dragger = null\n        } else {\n            clearTrack(editor, event)\n        }\n        event.stopPropagation()\n        event.preventDefault()\n    }\n}\n\nconst ENABLE_DRAG = Symbol(\"ENABLE_DRAG\")\n\nfunction mouseMove(event) {\n    return editor => {\n        let svg = document.getElementById(\"diagram\")\n        const rect = svg.getBoundingClientRect()\n        editor.rawMouseX = event.clientX\n        editor.rawMouseY = event.clientY\n        editor.mouseX = event.clientX - rect.left\n        editor.mouseY = event.clientY - rect.top\n        if (editor.dragger) {\n            modifyDiagram(\n                Object.assign({}, editor.draggerFlags, {transient: true}),\n                diagram => editor.dragger(\n                    diagram,\n                    event.clientX + editor.dragOffsetX,\n                    event.clientY + editor.dragOffsetY,\n                    event.ctrlKey))(editor)\n            event.stopPropagation()\n        } else {\n            updateTrack(event)(editor)\n        }\n        // prevent user from selecting things by accident;\n        // we can't do this in mousedown, because that breaks deselection;\n        // we also can't use user-select, because that also breaks deselection\n        // (a textbox might *look* like it's deselected, but middle-click paste\n        // and backspace still works!);\n        // it also breaks dragging too ... be careful!\n        if (!vnodeGetSymbol(event.target, ENABLE_DRAG)\n            && editor.focus.type == null) {\n            event.preventDefault()\n        }\n    }\n}\n\nfunction startDrag(x, y, flags, dragger) {\n    return editor => {\n        editor.dragger = dragger\n        editor.draggerFlags = flags\n        editor.dragOffsetX = x - editor.rawMouseX\n        editor.dragOffsetY = y - editor.rawMouseY\n    }\n}\n\nfunction traverseElem(elem, f) {\n    if (!elem instanceof Element) {\n        return\n    }\n    f(elem)\n    let children = elem.children\n    for (const i of range(0, children.length)) {\n        traverseElem(children[i], f)\n    }\n}\n\nfunction applyStylesheet(stylesheet, elem) {\n    traverseElem(elem, elem => {\n        let style = []\n        for (const selector of Object.keys(stylesheet)) {\n            if (elem.matches(selector)) {\n                const rule = stylesheet[selector]\n                for (const prop of Object.keys(rule)) {\n                    const propName = prop.replace(/[A-Z]/g, c =>\n                        \"-\" + c.toLowerCase())\n                    if (propName == \"transform\") {\n                        // Inkscape doesn't handle transforms in style\n                        elem.setAttribute(propName, rule[prop])\n                    } else if (filter(propName)) {\n                        style.push(propName + \": \" + rule[prop])\n                    }\n                }\n            }\n        }\n        const inlineStyle = elem.getAttribute(\"style\")\n        if (inlineStyle) {\n            style.push(inlineStyle)\n        }\n        if (style.length) {\n            elem.setAttribute(\"style\", style.join(\"; \"))\n        }\n    })\n}\n\nlet prevKey\nfunction keyDown(e, editor) {\n    const snapshot = editor.snapshot\n    const update = f => f(editor)\n\n    if (prevKey == \"\\x3a\" && e.key == \"\\x33\") {\n        editor.notice = prevKey + e.key\n    }\n\n    // don't steal focus when editing text\n    if (editor.focus.type != null) {\n        return\n    }\n\n    // reload\n    if (getModifiers(e) == 0 && e.key == \"r\") {\n        window.location.href = \"\"\n        e.preventDefault()\n        return\n    }\n\n    // help\n    if (getModifiers(e) == SHIFT && e.key == \"?\") {\n        window.location.href = document.getElementById(\"help-link\").href;\n        e.preventDefault()\n        return\n    }\n\n    // help\n    if (getModifiers(e) == 0 && e.key == \"v\") {\n        update(modifyDiagram({toggleAmbient: true}, identity))\n        e.preventDefault()\n        return\n    }\n\n    // mouse events require the position\n    if (editor.mouseX === null) {\n        return\n    }\n\n    // create Clebsch-Gordan coefficient\n    if (getModifiers(e) == 0 && e.key == \"f\") {\n        update(modifyDiagram({toggleFreeze: true}, identity))\n        e.preventDefault()\n        return\n    }\n\n    // create Clebsch-Gordan coefficient\n    if (getModifiers(e) == 0 && e.key == \"c\") {\n        update(modifyDiagram({}, diagram => {\n            const labels = Array.from(take(3, availSuperlineLabels(diagram)))\n            return mergeDiagrams(diagram,\n                                 cgDiagram(labels[0],\n                                           labels[1],\n                                           labels[2],\n                                           editor.mouseX,\n                                           editor.mouseY))\n        }))\n        e.preventDefault()\n        return\n    }\n\n    // create Wigner 3-jm\n    if (getModifiers(e) == 0 && e.key == \"w\") {\n        update(modifyDiagram({}, diagram => {\n            const labels = Array.from(take(3, availSuperlineLabels(diagram)))\n            return mergeDiagrams(diagram, w3jDiagram(labels[0],\n                                                     labels[1],\n                                                     labels[2],\n                                                     editor.mouseX,\n                                                     editor.mouseY))\n        }))\n        e.preventDefault()\n        return\n    }\n\n    // attach\n    if (getModifiers(e) == 0 && e.key == \"a\") {\n        update(modifyDiagram({}, diagram => {\n            const nearest = nearestNodeIndices(diagram.nodes, 2,\n                                               editor.mouseX,\n                                               editor.mouseY)\n            if (!(nearest.length == 2 &&\n                  diagram.nodes[nearest[0]].type == \"terminal\" &&\n                  diagram.nodes[nearest[1]].type == \"terminal\")) {\n                return \"no nearby terminals found\"\n            } else {\n                return joinTerminals(diagram, nearest[0], nearest[1])\n            }\n        }))\n        e.preventDefault()\n        return\n    }\n\n    // create Wigner 1-jm\n    if (getModifiers(e) == 0 && e.key == \"m\" && editor.hover.type == \"line\") {\n        update(modifyDiagram({}, diagram =>\n            addW1j(diagram, editor.hover.lineId)))\n        e.preventDefault()\n        return\n    }\n\n    // add 2j phase / flip Wigner 3j node\n    if (getModifiers(e) == 0 && e.key == \"j\") {\n        if (editor.hover.type == \"line\") {\n            update(modifyDiagram({}, diagram =>\n                add2j(diagram, editor.hover.lineId)))\n            e.preventDefault()\n            return\n        } else if (editor.hover.type == \"node\") {\n            update(modifyDiagram({}, diagram =>\n                flipW3j(diagram, editor.hover.nodeIndex)))\n            e.preventDefault()\n            return\n        }\n    }\n\n    // delete node\n    if (getModifiers(e) == 0 && e.key == \"x\") {\n        update(modifyDiagram({}, diagram => {\n            const nodes = diagram.nodes\n            const nearest = nearestNodeIndices(nodes, 1,\n                                               editor.mouseX,\n                                               editor.mouseY)\n            if (nearest.length != 1 ||\n                (nodes[nearest[0]].type == \"terminal\" &&\n                 nodes[otherNodeIndex(nodes, nearest[0], 0)].type\n                    != \"terminal\")) {\n                return \"no nearby nodes found\"\n            } else {\n                return deleteNode(diagram, nearest[0])\n            }\n        }))\n        e.preventDefault()\n        return\n    }\n\n    // save as SVG\n    if (getModifiers(e) == 0 && e.key == \"s\") {\n        const diagram = document.getElementById(\"diagram\")\n        let svg = diagram.cloneNode(true)\n        const rect = diagram.getBoundingClientRect()\n        svg.setAttribute(\"viewBox\", `0 0 ${rect.width} ${rect.height}`)\n        applyStylesheet(diagramStylesheet, svg)\n        // downgrade href attribute to the deprecated xlink:href\n        traverseElem(svg, elem => {\n            const href = elem.getAttribute(\"href\")\n            if (href) {\n                elem.removeAttribute(\"href\")\n                elem.setAttributeNS(NAMESPACES.xlink, \"href\", href)\n            }\n        })\n        const url = URL.createObjectURL(\n            new Blob([new XMLSerializer().serializeToString(svg)],\n                     {type: \"image/svg+xml;charset=utf-8\"}))\n        let a = document.createElement(\"a\")\n        a.href = url\n        a.download = \"diagram.svg\"\n        document.getElementsByTagName(\"body\")[0].appendChild(a)\n        a.click()\n        a.remove()\n        URL.revokeObjectURL(url)\n    }\n\n    prevKey = e.key\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Global stuff\n\nfunction getUpdate(editor) {\n    return (...changes) => {\n        const update = getUpdate(editor)\n        const n = changes.length\n        for (let i = 0; i < n; ++i) {\n            changes[i](editor)\n        }\n        applyRendering(renderEditor(update, editor))\n    }\n}\n\nexport function main() {\n    let editor = {}\n    Object.assign(editor, newEditor())\n    const update = getUpdate(editor)\n    update(loadEditor)\n}\n","import { main } from './script.js';\nmain();\n"],"names":["module","exports","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","identity","x","defaultEq","y","defaultCmp","lexicalCmp","xs","ys","cmp","nx","length","ny","i","r","permutSign","permut","Map","entries","has","set","visited","Set","sign","size","x0","values","next","value","delete","sgn","mod","clamp","min","max","round","dx","bitXor","range","start","stop","map","f","filter","take","arrayRemoveMany","indices","slice","Array","from","sort","Error","splice","currentId","idMap","WeakMap","propOr","def","deepClone","JSON","parse","stringify","threePointArc","y0","x1","y1","x2","y2","ax","ay","bx","by","cx","cy","det","t","radius","Math","sqrt","pow","vectorAdd","v0","vs","v","vi","vectorSubtract","vectorDot","v1","v2","s","keys","scalarMultiply","c","REAL_FIELD","ZERO","ONE","add","subtract","multiply","divide","eq","GF2_FIELD","assign","RealSparseVector","zero","SparseVector","constructor","iterable","this","data","k","copy","Symbol","iterator","modify","toTable","RealSparseMatrix","SparseMatrix","j","row","rows","cachedGet","rowKeys","colKeys","js","deleteRow","VNODE_KEY","VNODE_SUSPEND_CHILDREN","VNODE_SYMBOLS","VNODE_EVENT_LISTENERS","vnodeAmendAttributes","attrs","elem","listeners","unusedListeners","m","exec","event","listener","addEventListener","e","removeAttribute","getAttribute","setAttribute","symKeys","getOwnPropertySymbols","symbols","unusedEvents","removeEventListener","vnodeRenderChildren","children","oldChildren","childNodes","fragment","document","createDocumentFragment","child","oldChild","Vnode","attributes","Element","Text","removeChild","insertBefore","HTMLElement","nodeName","toLowerCase","name","namespaceURI","namespace","renderTo","create","nodeValue","createTextNode","appendChild","oldAttrs","oldAttr","ns","removeNamedItem","vnodeRenderAttributes","createElementNS","createElement","NAMESPACES","svg","xlink","vnode","parseNamespace","renderQueue","mergeDeltas","deltaLists","finalDeltas","finder","forEach","deltas","delta","found","push","exists","freeze","containsDeltas","subdeltas","subdelta","equalDeltas","deltas1","deltas2","findDeltaEntry","entry","relatedDelta","ji","concat","EMPTY_SUPERLINE","phase","summed","weight","ensureSuperline","superline","newLabel","label","match","Number","toString","availLabels","POSITIVE_INFINITY","availSuperlineLabels","diagram","labels","superlines","isEmptySuperline","mergeSuperlines","finalSuperline","mergeSuperlineLists","superlineLists","finalSuperlines","id","ZERO_LINE","direction","arrowPos","arcHeight","angle","textPos","textOffset","newLine","superlineId","ensureLine","line","reverseLine","PI","isLineDirectable","mergeDirections","directions","sum","rawConcatLines","lines","avgProps","finalLine","sinAngle","cosAngle","numAngles","counts","sin","cos","atan2","concatLines","canonicalized","canonicalizeLine","trunc","getLineInfo","lineId","ends","endNodeIndices","nodes","node0","node1","external","type","includes","xMid","yMid","dy","lineLength","singular","trueAngle","halfDisk","epsilon","Infinity","abs","arc","inclination","large","sweep","halfLength","theta","asin","arcInfo","xCenter","yCenter","arcEx","startAngle","getLineInfoBetween","findPosOnLine","lineInfo","pos","offset","rx","ry","cycle","shift","positionOnLine","newPos","normalX","normalY","tangentAngle","localAngle","normalAngle","terminalNode","variable","node","w3jNode","b","endNodeAndLineIndices","nodeAndLineIndices","numNodes","nodeIndex","numLines","lineIndex","otherNodeAndLineIndex","otherNodeIndex","isLeftOfLine","nearestNodeIndices","count","distance","index","EMPTY_DIAGRAM","ensureDiagram","w3jDiagram","setDiagramLineProps","props","mergeDiagrams","diagram1","diagram2","renames","newLineId","terminals","isSuperlineExposed","addW1j","flipW3j","reverse","isDanglingSuperline","lineIds","flipW3jRule","DiagramLine","reversed","console","assert","Boolean","rawLine","rawDiagram","end","lineEnds","_lineEnds","DiagramNode","cycNodeLine","signedRebase","signedLine","removeSign","signedId","substr","rawAssign","testCuttability","errors","subdiagramOrientability","priority","error","rawNode","lineEnd","xy","Diagram","_cache","deserialize","serialize","getLineEnds","terminal","hasSuperline","isEquallyConstrained","renameLines","desumExposedSuperlines","renameSuperlines","removeUnusedSuperlines","marked","substitute","pattern","replacement","flags","pattDiagram","replDiagram","deltaMerge","sharedLines","seenLines","pattLine","seen","newLines","freshLineIds","lineRenames","startsWith","superlineMerge","summedSuperlines","pattSuperline","pattNode","nodeLines","pattNodeLines","uniqueLines","matchedLineIds","pattNode0","pattNode1","diffDirection","replNodes","seenReplLines","findJoiningNode","replLine","replNode","result","otherPattLineId","otherPattLine","otherPattNode","getPart","joining","joining0","combined","joining1","nodeIndex0","nodeIndex1","lineIndex0","lineIndex1","newNodes","newDiagram","withLineRenames","findW3jLoop","cutLine","loopLine","loopElimRule","loopNode","loop","otherNode","ld","lc","lb","la","md","mc","mb","ma","jd","jc","jb","ja","$1","w3jIntroRule","lineId1","lineId2","diagonal","line1","line2","xy1","xy2","arcHeight1","arcHeight2","$2","$3","$4","$5","getAmbientDirections","ignoreExternal","excludedLineIds","matrix","subdirections","submatrix","field","vector","is","unconstrained","pivots","jp","pop","xp","ip","invXp","consistent","solution","u","_","sparseGaussElim","ambient","rng","sparseMatrixVectorMultiply","orientable","target","line0","subdiagram","closed","isolated","nodeIndices","candidates","getConnectedSubdiagram","renderNode","update","editor","frozen","snapshot","gChildren","join","circularArrowSize","orientation","lineAngle","w3jOrientation","href","width","height","frozenClass","trackStart","trackStop","trackType","transform","onmouseenter","setHover","onmouseleave","onmousedown","buttons","startDrag","superficial","snap","setDiagramNodeProps","stopPropagation","shiftKey","modifyDiagram","equivalent","oldDiagram","loopId","threeArrowRule","cmpSuperlineId","GREEK_LATEX","GREEK_LETTERS","IDENT_CHAR_REGEX","isValidSuperlineId","RegExp","isLoopLine","renderJTableau","focus","focusedName","twoJ","modifyDiagramWith","newSuperlineId","editSummed","freshSuperlineId","introSum","contenteditable","spellcheck","onfocus","setFocus","onblur","textContent","trim","numLoops","clearFocus","drag","drop","oncontextmenu","preventDefault","handleDrag","handleDrop","editDelta","deltaIndex","input","oldDeltas","invalid","split","inferredDeltas","knownZeros","inferDeltas","oldInferredDeltas","newInferredDeltas","oldZeroDelta","newZeroDelta","diff","diffDelta","renderDeltaJ","String","renderDeltaTableau","focused","sep","arrayIntercalate","createRange","selectNodeContents","sel","window","getSelection","removeAllRanges","addRange","renderVariable","replace","renderEquationLine","summedVars","otherIndex","mNaked","jm","ms","SHIFT","EMPTY_SNAPSHOT","showAmbient","newEditor","savedSnapshot","savedHash","staleEquation","notice","hover","mouseX","mouseY","loadEditor","hash","location","decodeURIComponent","toSvgCoords","p","rect","getElementById","getBoundingClientRect","left","top","renderEditor","element","onhashchange","onkeydown","keyDown","bind","onmousemove","rawMouseX","clientX","rawMouseY","clientY","dragger","draggerFlags","transient","dragOffsetX","dragOffsetY","ctrlKey","updateTrack","ENABLE_DRAG","onmouseup","flipW1jRule","isSuperlineOfLineUnique","oldLabel","generateLoopSuperline","stopXy","startXy","clearHover","otherLine","line3","line4","lineIdOther","w3jElimRule","glueRule","dxy","loopIntroRule","loop1Id","loop2Id","cutRule","candidateDiagram","finishTrack","clearTrack","getElementsByTagName","startTrack","info","position","textX","textY","change","where","bad","expectedDirection","ambientDirection","correction","rawPosition","arrowHeadSize","renderArrow","renderLine","onclick","container","currentTarget","phases","mDeltas","var1","var2","m1","m2","jRow","mRow","weights","jVar","node2","summedVarsStr","phasesStr","mDeltasStr","jDeltas","j0","MathJax","Hub","Queue","renderEquation","diagramTransform","transformer","setError","toggleFreeze","toggleAmbient","encodeURIComponent","saveEditor","getModifiers","altKey","errorTimeout","msg","clearTimeout","setTimeout","getUpdate","entity","canDrag","draggable","ondragstart","dataTransfer","setData","dragState","ondragend","canDrop","dragleave","ondragenter","dropState","ondragleave","ondragexit","ondragover","ondrop","traverseElem","prevKey","cgDiagram","nearest","terminalIndex1","terminalIndex2","terminal1","terminal2","joinTerminals","add2j","deleteNode","cloneNode","stylesheet","style","selector","matches","rule","propName","inlineStyle","setAttributeNS","url","URL","createObjectURL","Blob","XMLSerializer","serializeToString","download","click","remove","revokeObjectURL","changes","rendering","spec","applyRendering","main"],"ignoreList":[],"sourceRoot":""}